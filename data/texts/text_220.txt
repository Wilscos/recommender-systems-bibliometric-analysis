With the advancement of digital media, the online retail sector has started to gain a lot of importance. Coupled with other factors like the COVID-19 pandemic, people often tend to prefer online shopping for fashion items. Hence, the content that is shown to users on fashion websites is very important. In order to sustain user interest on a platform, it is important to display as much relevant information as possible and also rank the items according to their relevance. Hence, the development of a robust recommendation system is very important. The main task in the FARFETCH Recommendation Challenge is to predict the optimal ranking of the 6 products in a given impression, such that products with higher probability of being clicked by the user in that recommendation context have lower rank (ﬁrst positions). We can use click through data and product attributes along with the contextual similarity of a product in order to improve equal contribution Abstract. In the FARFETCH Fashion Recommendation challenge, the participants needed to predict the order in which various products would be shown to a user in a recommendation impression. The data was provided in two phases - a validation phase and a test phase. The validation phase had a labelled training set that contained a binary column indicating whether a product has been clicked or not. The dataset comprises over 5,000,000 recommendation events, 450,000 products and 230,000 unique users. It represents real, unbiased, but anonymised, interactions of actual users of the FARFETCH platform. The ﬁnal evaluation was done according to the performance in the second phase. A total of 167 participants participated in the challenge, and we secured the 6th rank during the ﬁnal evaluation with an MRR of 0.4658 on the test set. We have designed a unique context-aware system that takes the similarity of a product to the user context into account to rank products more eﬀectively. Post evaluation, we have been able to ﬁne-tune our approach with an MRR of 0.4784 on the test set, which would have placed us at the 3rd position. Keywords: Recommendation · Gradient Boosting · XGBOOST · Bayesian search the quality of recommendations. We have tried to approach the problem using various ranking algorithms as well as a binary classiﬁcation task, and the latter approach has proven to be more eﬀective. We have been able to improve our results by around 15% using a context-aware post-processing approach that makes use of the similarity of a product to the user context, achieving a ﬁnal MRR of 0.4814 on the validation set and 0.4658 on the test set during the original course of the competition. Post evaluation, we have been able to improve our performance on the test set drastically by ﬁne-tuning the threshold parameter in our post-processing approach, achieving an MRR of 0.4784. The problem statement has been provided as a part of the FARFETCH Fashion Recommendations Challenge 2021 [3]. We have been provided with a large sample of FARFETCH’s recommendations system impressions and associated click events. An impression is a list of 6 products that were shown to a user in a recommendations UI module in a given context(type of page, date, etc), with a label identifying which of the 6 products have been clicked. The goal of the competition is to predict the optimal ranking of the 6 products in a given impression, such that products with a higher probability of being clicked by the user in the recommendation context has lower rank. 2.0.1 Dataset Description : The dataset is a large sample of FARFETCH’s recommendations system impressions and associated click events, captured over a period of 2 months. Each row of data has a query id which is a unique identiﬁer of a recommendation impression. In the initial phase of the competition, we had access to a training set of 3.5 million rows that includes a target label, is click, and a validation set of about 0.6 million rows without a target label for making the initial submissions. The dataset contains 229064 unique users, 443150 unique products, and 813729 unique impression lists. A separate attribute dataset is provided which contains the attribute information for each of the products. Considering all the data present, there are 3 numerical attributes and around 20 categorical ones. The target label identiﬁes which of the 6 products in the impression were clicked. The position of the products within the list is unknown in this dataset. In the ﬁnal phase, we had access to another unlabelled test set with around 0.6 million rows for ﬁnal evaluation. 2.0.2 Evaluation Metric : During the competition, models were evaluated using Mean Reciprocal Rank (MRR), deﬁned as follows: where, where N is the number of impressions, and for the i-th impression in the dataset, rank Initially, we tried to approach the problem as a ranking task with lambdarank as the objective function. However, further experimentation proved that approaching it as a simple binary classiﬁcation problem to predict the clickout probability of a product using the binary cross-entropy objective, and ranking the products using the prediction probabilities yield much superior results. One of the most important steps in our solution was the feature engineering part, since it was challenging as well as time-consuming. We have created around 80 features based on user, session, product, clickout, and other relevant attributes. Our results have been further boosted using the context-aware post processing technique that we have employed. The main data preprocessing that we needed to employ in this problem was categorical variable encoding. The given dataset has a lot of categorical columns, most of which have a large number of distinct categories. We have used label encoding as the standard categorical variable encoding technique over approaches like one-hot encoding due to the sparsity in the data. This is the most important step of our solution. A carefully engineered feature may have the potential to explain the signiﬁcance of a product within a query quite eﬀectively. Broadly, we have two types of features- click-out features and non click-out features. These features are not dependent on whether a particular product has been clicked out or not. They are further sub-divided into the following categories: Session-based Features: These features include session speciﬁc aggregate and frequency features. Aggregate features include the mean, maximum, minimum product price and start online date in a session while frequency features include product frequency, main colour frequency, etc in a particular session. For example, the product session click proportion feature, which is the most important feature of our best performing method, is a type of repeated clicks rate feature. It is the ratio of the total number of clicks on the product under consideration in a particular session to the total number of clicks on all the products in the same session. Query-based Features: These features include the aggregated like mean, maximum and minimum product price and start online date within a particular query. Global Static Features: Features like the total number of users who have interacted with a particular product, number of impressions that a particular product appears in, etc. compose this set of features. Popularity Features: These features provide information about various product attributes like popularity of brand id, category id, main colour, etc. User-tier features: User-tier speciﬁc aggregate features like the mean, maximum and minimum product price and start online date are included in this sub-category of features. Ranking Features: This features are basically the ranking of a product within an impression based on the product price and start online date. Diﬀerence Features: These features basically convey the comparison of a particular feature against an aggregate like feature, for example, the diﬀerence between a particular product price and the mean product price in that session. These features are dependent on whether a particular product has been clicked out or not. They are further sub-divided into the following categories: Global Static features: These features include details about click interactions of a product like number of unique users who have clicked on a particular product, the price of a product when it was last clicked, etc. Popularity features: These features indicate the popularity of an attribute by computing percentage of click on a particular attribute. For example, the percentage click on a particular brand id among all clicked brands, the percentage click on a particular main colour among all clicked main colours, etc. User-tier features: Users are segmented into various tiers based on some attributes. The user-tier features include the aggregates like mean, maximum and minimum product price and start online date of clicked products based on the user tier. Diﬀerence Features: The diﬀerence features include the diﬀerence of product price and start online date and the mean of those features among the clicked products. They convey how a particular product attribute compares to the same attribute among clicked products. Weekly features: These features explain attribute variation at a weekly level. For example, the mean price of clicked products each week, the frequency of product clicks each week, etc. make up some of these features. The main motivation behind incorporation context-awareness in the recommendation system is that it enables us to generate recommendations more relevant to the speciﬁc contextual situation of an user. A context-based recommendation system gains special importance when information from multiple contexts are aggregated. For example, the products that a user might be interested in from the “Books” context might be totally irrelevant and have no predictive value for recommendations for the same user when he decides to purchase some products from the “Clothing” context. Gediminas et al. [1] has shown how context provides additional capabilities in recommendation systems and how the general notion of context can be modelled in recommendation systems. We have designed a PCS feature, that computes the similarity of a particular product to its corresponding user context. The context is basically a product that a user originally searched for, and recommendations are shown based on the context item. Hence, the similarity of the context item to another product provides an understanding about the relevance of a particular product to the original context. The PCS value is computed as follows: For each product P {l, l, . . . l set of numerical features, and U features. S(P where, S(P product attributes, φ features of the feature lists, and n(.) is the set cardinality. Gradient Boosting is a classical machine learning approach of converting weak learners into a strong one, by gradually, additively, and sequentially training numerous models. In the boosting approach, a new tree is a ﬁt on a modiﬁed version of the original data set. We have employed this approach to build our classiﬁer model. 3.3.1 Ranking Approach We have used LightGBM for the ranking approach. In order to use it for ranking, we use lambdarank as an objective function. The idea of lambdarank is to use the gradient of cost with respect to model score instead of cost. An important input to the ranking model is a list containing the length of each group, or the number of products in each impression, i.e. number of impressions corresponding to each query id, besides the features and the labels. The products within a query are ranked using the predicted probability values obtained using the trained LightGBM Ranker model. 3.3.2 Binary Classiﬁcation Approach In this approach, we treat the task as a simple binary classiﬁcation problem with the target being whether a product is clicked or not, i.e. is indicates the probability of the product being clicked, where a value closer to 1 denotes a higher click probability. We have experimented with LightGBM-[4] and XGBOOST [2] classiﬁers. The latter one has proven to be more eﬀective as, we can notice from the results Table 1 that the XGBOOST model achieves a higher MRR than the LightGBM model in both the cases, with and without }, where Uis the set of single-element categorical features, Uis the , P) is the PCS value between Pand P, Nis the total number of ﬁltering on both validation and test sets. The model is trained using binary cross-entropy as the objective function. During inference, we rank the products within a query using their predicted probability values obtained from the model, i.e. the probability that the product will be clicked. In order to improve the ranking of products within an impression, we have employed context-aware post-processing technique. Basically, we need to decide upon a threshold product-context similarity value. If the maximum productcontext similarity within an impression is lower than this threshold, we rank the products within the impression using the model prediction probabilities. However, if the maximum value is higher than the threshold, we rank the products in the impression using the product-context similarity values only. The threshold value for a particular dataset is decided upon using an ablation study of the product-context similarity column with diﬀerent threshold values. Post evaluation, after the availability of the validation and test labels, we have observed that setting a threshold value around 0.45-0.50 helps us achieve the best results. We have performed all our experiments on a system with 32GB RAM and 2.2 GHz QuadCore Intel Core i7 Processor. It was also equipped with a NVIDIA GTX 1080 GPU with 12 GB VRAM. We have tried to approach this problem both as a ranking task as well as a binary classiﬁcation problem. The latter approach has proven to be more eﬀective since the XGBOOST model achieves a higher MRR than the LightGBM model in both the cases, with and without ﬁltering on both validation and test sets as shown in Table 1. We have also been able to improve our results drastically using a post-processing approach, making use of the similarity of a product to the corresponding user context. 4.0.1 Experimental Settings : In the case of the ranking approach, we have used the LightGBM-[4]Ranker algorithm with lambdarank as the objective function. In the binary classiﬁcation approach, we have run 2 experiments using LightGBM and XGBOOST [2] with binary cross-entropy as the objective function. dataset of around 3.5 million rows. We have randomly sampled out 25000 query ids, i.e. 150,000 rows without replacement and used it as a validation set to tune our models during the competition. The remaining rows in the labelled dataset was used to train our model. Whenever the MRR on the validation set is more than that of a previous iteration, we save the corresponding trained model. During inference, we load up the best model based on the performance on the validation set and use it to obtain predictions. After obtaining the raw model predictions, we apply the post-processing technique to rank the products within a query. 4.0.3 Hyperparameter Tuning : In each of our approaches, we need to tune around 10 hyperparameters. Some of these include learning rate, max leaves, max depth, etc. We observed that we need to search over a fairly large range of values to get the optimum values of these parameters. Hence, we are using a Bayesian search approach. More speciﬁcally, we are using the BayesSearchCV utility from scikit-learn parameters. Our best parameters obtained for each of the models are tabulated in section A.2 from Appendix A. The results from our 3 approaches are tabulated in Table 1 below. These results have been obtained after ﬁne-tuning the threshold parameter post completion of the competition. As we can observe from the results, the XGBOOST [2] Classiﬁer has been able to achieve the best results. The feature importances for this model are tabulated in A.1. We have also been able to improve our ﬁnal performance on the test set by setting an appropriate threshold value of 0.51. As observed from the results in ﬁgures 1 and 2, the best results are obtained for a threshold value around 0.45-0.50. We can observe that initially, the MRR increases with the increase in the value of threshold till it reaches a peak for both the validation and test sets, and thereafter decreases. As far as the features are concerned, the proportion of clicks on a product in a particular session seems to be a really important one as can be observed from Table 2 in Appendix A. This might be due to the fact that it provides some information about the overall popularity of a product within a user session, and hence, helps the model make a better prediction. The other important features are mainly based on the absolute value of the product price or its related features, like the price of the product when it was clicked last, the diﬀerence of a particular product price from the mean price of clicked products, etc. This shows that the price of a product is a major area of concern for users, which is quite expected. The popularity of a product revolves around its price to a great extent. In this paper, we have presented an approach to eﬀectively rank the products within a recommendation impression module. We have experimented with both a ranking approach and a binary classiﬁcation one, and the latter one has proven to https://scikit-optimize.github.io/stable/modules/generated/skopt.BayesSearchCV.html https://scikit-learn.org/stable/ https://scikit-optimize.github.io/stable/ Fig. 1. MRR Variation with PCS threshold on Validation Set be more eﬀective. Our unique product-context similarity feature helps us improve the performance from a vanilla classiﬁcation approach drastically, and achieve a signiﬁcantly higher MRR on the validation and test sets. In the future, various ensembles of classiﬁcation techniques or hybrid ensembles of classiﬁcation and ranking techniques can be tried out in combination with the context-aware postprocessing. Also, it might also be worthy to try out deep learning approaches using CNN, LSTM, etc. The code for this paper is available here. Table 1. Results of diﬀerent approaches on validation and test set