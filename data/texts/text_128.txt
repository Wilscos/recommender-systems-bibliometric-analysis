tourists in an unfamiliar city. Due to the popularity of location-based social networks, an unprecedented volume of historical trips and itineraries, each represented as an ordered sequence of Points-Of-Interest (POIs) visited, has become available. This opens up a new avenue to learn popular and suitable itineraries from the historical trip data. In the past few years, many techniques [1], [2], [3], [4] have been proposed that learn from historical trips in the city and recommend the most popular itinerary from a given source s to a given destination d. Intuitively, such a popular itinerary system returns a sequence of POIs which has been most frequently adopted by past users while traveling from s to d. However, recommending a single itinerary is often too restrictive and may not meet a user’s needs. Therefore, it is preferable to recommend multiple alternative itineraries. Quality alternative itineraries must not only be popular, but also dissimilar (or diverse) to each other. Without loss of generality, we use the terms diversity and dissimilarity interchangeably as both refer to the alternate itineraries with minimum overlap. In this paper, we propose learningbased techniques to report k alternative itineraries that are popular and are also dissimilar to each other. To the best of our knowledge, we are the ﬁrst to learn multiple quality alternative itineraries from historical routes that are both popular and diverse with each other at the same time. Fig. 1: Different routes in Rome, each from the Central Station s to a hotel d, passing through POIs pto p. Motivating Example: Figure 1 shows an example where, for a source s (Rome Central Station) and a destination d (a hotel), ﬁve different historical routes (Rto R) are shown in solid black colored lines that pass through nine POIs in total (pto p). Assume that the routes in descending order of popularity are given as R, R, R, Rand R. Existing systems that return the most popular itinerary would learn to return R. If the user wants the top-2 popular itineraries, Rand Rwould be recommended which are both very similar to each other as R= (s, p, p, p, d) and R= (s, p, p, p, p, d). This may not be desirable for a user looking for alternative itineraries to choose from. Also, if a system attempts to return diverse itineraries not considering their popularity, it may return Rand R= (s, p, p, p, d). This may also be not desirable, as itinerary Ris not well supported by the historical trips. In this case, a better solution is to return two popular yet diverse itineraries such as R= (s, p, p, p, p, d) and I= (s, p, p, p, d). These two will be considered as quality alternatives by the querying user. Note that I(shown in red dotted lines) does not exist in the historical routes. Our learning-based algorithms are able to discover popular and diverse itineraries that do not necessarily exist in the historical trips (e.g., I). Limitations of Existing Works: All existing learningbased itinerary recommendation systems [1], [2], [3], [4] are designed to recommend the most popular itinerary and, to the best of our knowledge, there does not exist any learning-based technique to recommend multiple alternative itineraries. There exists some search-based techniques [5], [6], [7], [8] that return a set of diverse itineraries based on pre-deﬁned popularity and/or diversity objective functions. However, these techniques are not applicable to the problem studied in this paper because the notion of diversity used in these techniques is different from ours. For example, [5] aims to return routes such that the POIs within a route have diverse features. In contrast, we consider two itineraries to be more diverse if they have a smaller overlap (i.e., have fewer common POIs), so that they would be considered as alternatives with respect to each other. Also, [6] deﬁnes diversity to be the minimum Euclidean distance of any two POIs in two different itineraries. Thus, two itineraries that have even one common POI are considered to have zero diversity even if all other POIs are very different and far from each other. Furthermore, these search-based techniques suffer from a number of limitations. First of all, most of these works only consider optimising either the popularity or the diversity, and do not take both into account at the same time while recommending a set of itineraries. However as we explain in our motivating example, attempting to optimize only diversity or only popularity without considering the other would not lead to quality alternative itineraries. Secondly, as noted in [9], it is not trivial to deﬁne quantitative measures to evaluate the quality of alternative itineraries and there is no agreed deﬁnition of what constitutes a set of high-quality alternative itineraries. But these search-based techniques typically require explicit modeling of popularity and/or diversity. Users may not have any prior knowledge to deﬁne and tune such metrics and, more importantly, these techniques may not be able to recommend suitable itineraries if the user fails to do so. Thirdly, since these systems do not learn from the historical trips, they cannot incorporate the semantics of the sequence of visits in their solution. Last but not the least, these algorithms are unable to handle userdeﬁned constraints which limit their applicability. Our Contributions: We address the above limitations and propose two novel deep-learning-based algorithms, called DeepAltTrip-LSTM and DeepAltTrip-Samp, that learn from the historical trips and recommend k alternative itineraries that are both popular and diverse. A key component of these algorithms is the Itinerary Net (ITRNet), which estimates the likelihood of different POIs to be in an itinerary, using two LSTMs. Also, both of our algorithms are metric-agnostic in the sense that these do not require or rely on any speciﬁc diversity or popularity metrics, i.e., the users do not need to worry about deﬁning suitable popularity or diversity metrics. Nevertheless, we extensively evaluate the algorithms using some widely used popularity and diversity metrics on real-world datasets, and these experimental studies show that both algorithms recommend high quality alternatives. In many real-world applications, users may want to impose certain constraints on the alternative itineraries recommended by the system. For example, the total cost to visit the POIs (including traveling cost and entry tickets etc.) in each recommended itinerary must not be more than a user deﬁned budget or each recommended itinerary must pass through some speciﬁc “must-see” POIs chosen by the user etc. Existing learning-based algorithms are unable to trivially handle such constraints. We propose a novel sampling algorithm, DeepAltTrip-Samp, that can seamlessly handle a wide variety of such user deﬁned constraints. It employs an enhanced Markov Chain Monte Carlo (MCMC) algorithm, a variation of Gibbs sampling [10], which facilitates in pruning the candidate itineraries that do not meet the user deﬁned criteria. Our contributions in this paper are summarized below. called, DeepAltTrip-LSTM and DeepAltTrip-Samp, to recommend k alternative itineraries using historical trips without requiring any explicit popularity or diversity modeling. is that it can seamlessly support additional constraints on the generated itineraries. real world datasets drawn from two domains and evaluate the algorithms on several widely used popularity and diversity metrics. The results demonstrate that our metric-agnostic algorithms propose high quality results and signiﬁcantly outperform the competitors. To our knowledge, there is no work that directly solves the problem of recommending multiple alternative itineraries through learning from historical trips. However, there are three realms of work relevant to our problem: traditional trip recommendation system that recommends a single itinerary, either through heuristics or through learning; search based techniques that attempt to return top k itineraries based on an optimization problem to maximize an explicitly deﬁned objective function; and POI recommendation methods that are mostly focused on recommending individual POIs rather than itineraries. 2.1 Trip Recommendation Systems Earlier works model tour recommendation as an orienteering problem, where the goal is to ﬁnd an itinerary that maximizes a certain objective function (e.g., popularity) satisfying given constraints (e.g., budget). [11] constructs itineraries based on user visits by ﬁrst constructing a POI graph and then generating an itinerary based on this graph that maximizes the total POI popularity within the user budget. [12] argues that popular routes cannot be properly inferred only through counting from historical routes, and proposes a heuristic solution by ﬁrst obtaining a transfer network and then inferring itineraries based upon an absorbing Markov Chain model built based on the network. [13] recommends itineraries based on user budget, time limitations and past historical data. [14] uses a two phased approach where it ﬁrst interacts with the user to know her venue speciﬁcations and then uses crowd-sourced data to generate personalized POIs for the user. [1], [15] provide personalized user recommendation through modeling the problem as an integer programming problem given the budget constraints. [2] is the ﬁrst to learn POI preferences and optimize the itinerary based on historical trip data and various features such as POI category, distance, and visiting time. Several other variations of the trip recommendation problem have been studied [16], [17], [18]. A comprehensive survey on this group of works is presented in [18]. Since human mobility is correlated with the location and category of POIs, [19] and [3] proposed an adversarial model to generate a itinerary for a user query. [4] provide a personalized itinerary through a Nerualized A* search using LSTM and self attention to estimate an observable cost and an MLP leveraging graph attention models to estimate the heuristic cost. All of the above methods provide a single itinerary for a given source and destination, and cannot be trivially extended for providing k diverse and popular itineraries. This realm of work adopt search based techniques to provide k itineraries. Liang et al. [5] provide top k itineraries through searching, where they use a sub-modular function to specify diversity requirement. Xu et al. [6] compute itineraries maintaining a minimum spatial distance covering a set of POI categories, where the objective is to maximize the popularity satisfying the diversity constraints. Wang et al. [20] leverage POI semantics information to develop an efﬁcient algorithm for providing k itineraries with the least cost. [21] provides top-k trajectories based on user suggested location and category keyword preference. Major focus in all these works is to reduce query processing time for search algorithms, where they gather statistical POI data and require explicit diversity constraints to guide the search process. Another group of works attempt to determine alternative routes for shortest path queries through searching in a road network graph. [22], [23] leverage penalty based techniques to increase edge weights of previously used paths to gain k shortest paths which maintain some diversity. [24] creates separate shortest-path trees from the source and destination nodes. The connecting branches, called plateaus are considered for alternative routes, as longer plateaus tend to have higher dissimilarity. [7], [8] deﬁne a dissimilarity function and then attempt to ﬁnd alternative paths that exceed a pre-deﬁned user dissimilarity threshold. In contrast to these works, the focus of our work is to develop a learning based approach that ﬁnds popular and diverse itineraries based on the historical trips. 2.3 POI Recommendations Another group of works orthogonal to our research is next POI recommendation [25], [26], [27], where the objective is to recommend one or multiple POIs to visit next based on user’s preferences. Another set of works include package-POI recommendations [28], [29], which provide diversity in a group of POIs in a region. However none of above techniques focus on recommendation of itineraries (i.e., an ordered sequence of POIs). Let Q = {p, p, ..., p} be the list of N POIs in a city. Each POI p∈ Q is represented as a (loc, cat) pair, where loc is the location of prepresented by its latitude and longitude co-ordinates hlat, longi and cat ∈ C is the category type of p. Let D be a multiset containing all historical routes of the past users visiting POIs in Q. Each route R ∈ D is an ordered sequence (r, r, ..., r) of POI visits, where r∈ Q is the POI at position t in the route and T is the total number of POIs in the route. Given historical routes D and a query q(s, d, k) with starting location s ∈ Q, ending location d ∈ Q and an integer k, our aim is to recommend a set of k alternative itineraries {I, I, ..., I} that are both diverse and popular, where each itinerary Iis an ordered sequence of POIs (r, r, ..., r) with r= s and r= d. Intuitively by popular itineraries we mean that the sequence of POIs visited have been frequently adopted by past users going from s to d, and by diversity or dissimilarity we mean that the set of recommended itineraries have minimal overlap. Speciﬁc metrics to evaluate popularity and diversity are mentioned in Section 5.3. Note that unlike in a search based procedure a recommended itinerary Iis not necessarily a historical route, i.e., it is possible that I/∈ D. Also note that we attempt to learn to recommend alternative itineraries rather than attempting to maximize any popularity or diversity metric. The DeepAltTrip consists of two main components: (i) the Itinerary Net (ITRNet) to estimate the probabilities of POIs at a particular position of a given itinerary by using two (forward and backward) LSTMs, and (ii) an itinerary generation algorithm to generate k alternative itineraries passing through prominent POIs obtained using the ITRNet. For itinerary generation we propose two variants of DeepAltTrip: ﬁrst one is an LSTM based itinerary generation technique, and the second on is a sampling based technique that provides ﬂexibility to accommodate user constraints. 4.1 ITRNet Model The ITRNet consists of two LSTM’s, namely a forward and a backward LSTM. The forward LSTM takes a partial route sequence from the starting POI and estimates the probability of a POI being the next POI in the route sequence. The backward LSTM takes a route sequence in reverse order, starting from the destination POI, to estimate the next POI in the reverse route sequence. Both LSTM’s also take into consideration the actual source and destination POIs of the route being generated. Let R = (r, r, ..., r, x, r..., r) be a route, p= rand p= rare the source and destination POIs respectively. Formally, given the forward partial sequence r, the source pand destination p, the probability of iPOI p∈ Q replacing x,, can be computed as: Similarly, given the backward partial sequence r, the source pand destination p, the probability of iPOI p∈ Q replacing xcan be computed as: Similarly, we compute the probabilities of all N POIs in Q, which is denoted as N-dimensional vectors P(x|p, p) and P(x|p, p) respectively, where each element i in P(x|p, p) and P(x|p, p) represents the conditional probabilities deﬁned in Equation 1 and 2 respectively. The forward LSTM computes P(x|p, p), while the backward LSTM computes To develop the ITRNet, we ﬁrst compute POI embeddings, which would be later used to train the subsequent ITRNet forward and backward LSTM models. 4.1.1 POI Embedding To capture the spatial and semantic information of POIs in the ITRNet, we use two graph autoencoders [30] to get the embeddings of POIs. These embedding enable the LSTM models to accurately compute the probability of POIs even if the historical visits to the POIs are sparse. We ﬁrst deﬁne two graphs G= (Q, E) and G= (Q, E) for POI categories and spatial distance, respectively and the nodes of both graphs are the POIs. The weight of an edge between two nodes in Gand Gis related to the categorical similarity and the distance of the two corresponding POIs, respectively. The adjacency matrix Afor graph Gis deﬁned as follows. This adjacency matrix captures the categorical similarity between POIs, where POIs with the same category have a connection. On the other hand, the adjacency matrix Aof Gis deﬁned as follows. Here dist(p, p) is the distance between POI p.loc and p.loc, and dand dare the maximum and minimum distances between any two POIs, respectively. We use the Euclidean distance between two POIs calculated using their latitude and longitude, which is a reasonable approximation of the road network distance [31]. Without loss of generality, Euclidean distances can be replaced with road network distances if underlying road network is available. We use exponential terms to amplify the difference between the normalized weight values. The Amatrix gives a larger weight to edges between POIs that are nearer to each other. For the lowest distance d between any two nodes pand p, the edge weight A between them will be 1. On the other hand the two nodes with the maximum distance dbetween them will have an edge weight of 0. We obtain two embeddings Z∈ Rand Z∈ Rfrom the two graph autoencoders respectively, where eand eare the embedding dimensions. We concatenate these two embeddings to obtain the ﬁnal POI embeddings, Z = Z||Z, where Z ∈ R,‘||’ is the concatenation operation and irow of Z corresponds to the embedding of POI p∈ Q. The reconstructed adjacency matrix for A is calculated for both autoencoders, where Z = GCN(X, A). Here, A is the POI ground truth adjacency matrix, X is the featureless identity matrix input, and GCN is a graph convolution operation [32]. The learned node embeddings Zthus captures the categorical and distance information between POIs, which assists the downstream LSTM models to predict the next POI in a route sequence more accurately. We use MSE and cross-entropy loss functions for the autoencoders corresponding to Gand G, respectively. 4.1.2 Forward and Backward LSTM Models This is the main component of ITRNet, which uses two LSTMs to generate two conditional probabilities based on a known partial route sequence, a given source POI and a given destination POI. It also uses the POI embeddings obtained from the previous step. To estimate the forward conditional probability P(x|p, p), we ﬁrst obtain the encoding of the given partial route sequence. The encoding of a sub-route upto any position j, that is the partial route (r, r, ..., r) where 1 ≤ j ≤ t − 1 is obtained using a forward LSTM model as follows. where, z, z, zis the embedding of POI rat step j, source POI pand destination POI prespectively, h is the hidden state LSTM vector at j−1, and his the hidden state vector at step j. After obtaining the encoding of the observed sub-route, we calculate the probability of a POI pfor position t as follows.α where Here zis the POI embedding of POI p, his the subroute encoding upto t − 1 and M LP is a two-layer perceptron network, which outputs a score α∈ R. Passing these scores through a softmax layer gives us the ﬁnal forward conditional probability estimation vector P(x|p, p). The MLP thus computes the probability of a POI pbeing the next POI rin the route, given the encoding of the partial route upto step t − 1 and the embedding of the POI z. Similarly, we develop the backward LSTM model to estimate the backward conditional probability P(x|p, p). It takes the backward sub-route (r, r, ..., r) in reverse order, along with the source POI pand destination POI p. Essentially, we generate the encoding hat step j, where t + 1 ≤ j ≤ T , as follows. Using the above encoding and the earlier POI embeddings we estimate P(x|p, p). The procedure is similar to the procedure to obtain P(x|p, p), so we do not repeat it here. Thus the forward LSTM predicts the next POI given a forward partial route sequence, whereas the backward LSTM predicts the next POI in the reverse partial route sequence, i.e. the immediate previous POI given a sequence of POIs visited after the predicted POI. While training, we adopt the binary cross-entropy loss to train both the LSTM models. 4.2 Generating Itineraries Using ITRNet In this phase, we generate k alternative itinerary recommendations using the ITRNet backward and forward LSTM models. Given a query q(s, d, k), we ﬁrst compute a relevancy score of all POIs for a given source POI s and destination POI d using the ITRNet. Then, at each iteration we extract a prominent POI based on the computed relevancy scores and generate k alternative itineraries each going through a different prominent POI. We ﬁrst describe how we compute the POI relevancy, after that we describe how an itinerary is generated. Finally we describe how k alternative itineraries are obtained in an iterative manner. 4.2.1 Computing POI Relevancy By using the ITRNet, we deﬁne a relevancy function that outputs a relevancy score for every POI for given query source POI s and destination POI d. Consider the route (r= s, r= x, r= d), where xis the variable POI. We deﬁne the relevancy function as follows: relevancy(p) =12(P(x|s, d) + P(x|s, d)) This relevancy function provides higher scores to POIs which are more relevant in the context of the query source and destination POIs. 4.2.2 Generating an Itinerary Based on the relevancy function, we obtain a prominent POI, p, the POI with the maximum relevancy score. After obtaining a prominent POI, we generate an itinerary containing that prominent POI. DeepAltTrip uses the forward and backward LSTM models of ITRNet to generate the partial itinerary from the prominent POI to the source POI and the partial itinerary from the prominent POI to the destination POI. We call the partial itinerary from the source POI to the prominent POI the ﬁrst half itinerary and the partial itinerary from the prominent POI to the destination POI the second half itinerary. We generate the half itineraries starting from the prominent POI p, as then the corresponding LSTM that would be used will output probabilities with the knowledge that the prominent POI is present in the itinerary being generated. There are two ways to develop the full itinerary through generating the ﬁrst and second half itineraries starting from the prominent POI: the backward LSTM model of ITRNet. Then given the ﬁrst half itinerary as partial sequence, generate the second half itinerary using the forward LSTM model. LSTM model. Then given the second half itinerary as a partial sequence, generate the ﬁrst half itinerary in reverse order using the backward LSTM model. Note that in all cases the source and destination POI input to the LSTM models are the query source and destination POIs s and d, respectively. We assume a maximum allowable length of a half itinerary L. To obtain the ﬁrst half itinerary (following the ﬁrst way), we use the backward LSTM of ITRNet. We place the prominent POI at position Land generate POI probabilities P(x|s, d) for positions L− 1 to 1. We determine the position of the source POI in the reverse ﬁrst half itinerary as: We place the source POI in position t. For all other positions from L− 1 down to twe choose the POI rin the sequence through: Note that during this choice we avoid selection of a POI which is already in the partial sequence generated to avoid loops in the recommended itinerary. We also avoid selection of the given source and destination POIs too. Finally we adopt the partial itinerary sequence from position tto L as our ﬁrst half itinerary. After generating the ﬁrst half itinerary, we generate the second half itinerary from position L+1 to 2Lgiven the ﬁrst half itinerary, source POI s and destination POI d. We determine the position of the destination POI in the second half itinerary as: We place the destination POI at t. For all other positions from L+ 1 to twe choose the POI rin the sequence using the forward LSTM model through: Finally we put d at position t. The partial itinerary sequence from L+ 1 to tmake up our second half itinerary. Thus the ﬁrst and second half itineraries make up our desired itinerary from POI s to d through the given prominent POI p. Similarly we can generate the itinerary using the second way as mentioned above. We place the prominent POI p at position L. Among the two generated itineraries, we choose the one with the lowest perplexity or negative log likelihood, calculated using the forward LSTM model: Where I is the itinerary (r, r, · · · , r) of length |I| with r= s and r= d. 4.2.3 Generating k Alternative Itineraries To obtain k alternative itineraries as speciﬁed in a given query q(s, d, k), we generate itineraries iteratively through determining a prominent POI at each iteration. We keep track of the total number of occurrences for all POIs in the itineraries generated until the current iteration. Let O[p] be the number of occurrences of POI pin all the itineraries generated up to the current iteration. At each iteration j, we obtain the set of POIs with minimum occurrence O= {p|O[p] = minO[P]}. Then we obtain the prominent POI pat any iteration as: We then take pand generate an itinerary as described in Section 4.2.2 using pas the prominent POI. After obtaining an itinerary we update the values of O[p] for each pin the itinerary obtained in this iteration. We run the same process k times and obtain our desired k itineraries. An overview of the whole DeepAltTripsystem is given in Algorithm 1. 4.3 Generating Itineraries Through Sampling In a real-world scenario, a user may want to impose some constraints on the generated alternative itineraries, such as setting a ﬁxed budget or time limit, or specifying must-see POIs, etc. It is not possible to support such constraints in our proposed LSTM based trip generation technique described in Section 4.2.2. To overcome such limitations, in this section, we propose an alternate sampling algorithm to generate an itinerary starting from p, passing through the prominent POI p, and ending at p. Our sampling based approach is as follows. We iteratively generate candidate itineraries. At iteration 0 of the sampling method, we start with an initial itinerary R= ( r= s, r= p, r= d). In the iteration process, at iteration j, suppose we have itinerary R= (r, r, ..., r) of length |I|. We generate a sample at iteration j + 1, i.e., R= (r, r, ..., r) of length |I|by modifying sample R. For modiﬁcation, we randomly select a POI at position t of the itinerary R, where 2 ≤ t ≤ |I|− 1. Then we perform one of the following four operations at t, namely at POI rof itinerary R: Insertion: We ﬁrst assign r= r. We then insert a POI between t and t + 1. We now deﬁne the following conditional probability distribution using the ITRNet: The above equation gives us the probability of a POI at a given position given both the partial sequence from the source POI to the POI before pat position t − 1 and the partial sequence starting after pfrom position t + 1 to the destination POI at position T . We can compute this for all POIs in Q, which can be denoted as an N dimensional vector P(x|p, p). We compute P(x|p, p) as follows: where, β =. Intuitively, we give more weights to the model that has seen a longer sub-route and thus have a greater contextual information. We obtain P(x|s, d) at position t + 1, where the newly inserted POI is located in the itinerary. We sample a POI from P(x|s, d) and assign the obtained sample as r. The rest of the itinerary remains unchanged. Deletion: We delete rat position t of the itinerary and keep the rest of the itinerary unchanged. Replacement: We obtain the conditional probability distribution P(x|p, p) as in Equation 5 using the ITRNet. We then take a sample from this distribution to obtain a POI pand get r= preplacing POI r. Swap and Replace: We randomly select a position t, between 2 to |I|− 1, and swap the position of POI rat position t and POI rat position t. If ris not a prominent POI, we also perform the Replacement operation (as described in the previous paragraph) at position t after the swap. To perform an operation at any iteration j, we choose any one of the operations with equal probability assigned to all allowed operations. If the selected POI ris the prominent POI, we do not perform the deletion or replacement operation on that POI. Also, to avoid loops, we omit inserting or putting through replacement a POI that is already present in Rexcept for POI r. At each iteration we check the following two conditions: lower than itinerary Rat iteration j, or no new itinerary has been accepted for previous two iterations. If both conditions are satisﬁed, we adopt itinerary Rfor generating itinerary at iteration j + 2. Otherwise we retain itinerary Rand use this to generate itinerary at iteration j + 2, meaning we reject the modiﬁcation operation performed at iteration j + 1. The sampling runs for J iterations. The itinerary generated and accepted with the minimum perplexity is returned as the desired itinerary. Note that if any user deﬁned constrains is given, we have to ﬁrst build an initial itinerary satisfying all the given constraints. Any such itinerary that satisﬁes all the conditions given will sufﬁce as the initial itinerary. 4.3.1 Satisfying User Constraints Our sampling algorithm makes it possible to generate alternative itineraries that can satisfy a variety of user constraints. Examples include: to another is given, users may want itineraries that they can visit within a ﬁxed budget. We may omit a candidate itinerary generated at an iteration if the itinerary exceed the budget. include one or more speciﬁc given POIs. In such cases, we keep those POIs in the initial sequence and treat them similar to the prominent POI, i.e., we don’t delete or replace those POIs. have opening and closing hours. Given a start time along with the source and destination POIs, the average staying time in a POI and average travel times between POIs, we can check whether all the constraints are met while generating itineraries in different iterations. We can also consider only those POIs during sampling in insertion or replacement that would satisfy the time constraints. Also users may want itineraries that they can travel within a ﬁxed time limit. This can be also satisﬁed, where we omit itineraries generated in an itinerary when the time budget is not satisﬁed. Note that the aforementioned constraints cannot be trivially satisﬁed in a traditional deep learning algorithm. Thus the itinerary generation technique of DeepAltTrip-Samp is effective in many practical scenarios for generating itineraries in a constraint setting. In this section, we present the experimental evaluations for DeepAltTrip to recommend k alternative itineraries for a given source and destination POI. In particular, depending upon the itinerary generation strategy we have two versions of DeepAltTrip: (i) DeepAltTrip-LSTM that uses LSTMs for generating an itinerary (Section 4.2.2), and (ii) DeepAltTripSamp that adopts a sampling based ﬂexible approach for generating an itinerary (Section 4.3). 5.1 Baselines We are the ﬁrst to learn alternative itineraries from historical routes. As there are no prior works in the literature that directly solves our problem, we adapt two state-of-the-art trip recommendation techniques that learn from historical routes, and modify them to recommend k alternative itineraries. Our two baselines are as follows. erate k alternative itineraries. We ﬁrst compute score ranks for POIs based on their features for a given query. Then a POI-to-POI transition matrix is computed from feature-to-feature transition probabilities. From the computed POI scores and transition probabilities, we use Viterbi algorithm to generate a route of a speciﬁc length for a given source and destination. We incorporate the diversiﬁed beam search measure given by [33] to maintain k paths at each step of the algorithm. attention-based LSTM to estimate the conditional probability (similar to our forward LSTM model). Again we run the diversiﬁed beam search [33] on top of this model and return the top k itineraries ending at the destination POI with the highest probability scores. We evaluate the effect of a number of parameters. Specifically, the no. of alternative itineraries recommended, k, is varied from 1 to 5 with a default value of 3. Also to ensure fair comparison, we ﬁx the length L of each itinerary (i.e., number of POIs in it including s and d) recommended by different algorithms. L is varied from 3 to 9 with the default value being 5. We use a 5-fold cross validation: one fold is kept for testing and the other four folds are used to train a model. The average performance metrics among all ﬁve folds are reported. 5.2 Datasets We use eight popular real-world datasets drawn from two different domains. As a ﬁrst group of datasets, we take geo-tagged Flickr traces of three touristic cities: Edinburgh, Toronto and Melbourne [1], [2]. In the second group of datasets, we consider trips of ﬁve different theme parks: California Adventure, Hollywood, Disneyland, Disney Epcot and Magic Kingdom [17]. Along with the trips involving different POIs, the datasets also contain location hlat, longi and the category of each POI. The trajectories given in these datasets are generated from user check-ins, with the visiting time between two consecutive POIs in a trajectory is no more than 8 hours. We ﬁlter out multiple occurrences of POIs (if any) from these trajectories to avoid loops. We also only consider trajectories having at least three POIs. Table 2 shows the details of each dataset including the number of POIs, number of routes having at least three POIs and the number of ground truth set of routes generated with unique (s, d) pairs. 5.3 Evaluation Metrics Given a query q(s, d, k), we use Sto denote the set of k recommended itineraries by an algorithm and Sto denote the ground truth routes which consists of all the historical routes that start at s and end at d. Next, we describe the metrics that we use to measure the quality of itineraries Sreturned by an algorithm. In particular, we measure the quality of our alternate itineraries by using traditional popularity and diversity metrics independently as well as by another metric that considers both popularity and diversity at the same time. 5.3.1 Popularity We we use the widely used F1 score and pairs-F1 score [1], [2] to measure the popularity pop(S) of a set of k recommended itineraries S. Suppose, route R = (r, r, r, ..., r) is a ground truth route where r= s and r= d and itinerary I = (i, i, ..., iI|) is a recommended itinerary. Also, let Qand Qbe the sets of POIs in the ground truth route and recommended itinerary respectively. The precision of the recommended itinerary |I| is calculated as:P = and the recall is calculated as R =. The F1 score is the harmonic mean of precision and recall, i.e. F 1 =. In contrast to F1, pairs-F1 score considers orders of POIs in the routes. Speciﬁcally, precision is the no. of ordered POI pairs present in both R and I divided by the total no. of ordered POI pairs in I. The recall is the total no. of ordered POI pairs present in both R and I divided by the total number of ordered POI pairs in R. The pairs-F1 score is the harmonic mean of this precision and recall. We compute F1 score (resp. pairs-F1 score) for each pair in S×Sand report the average value as the popularity of the recommended itinerary set S. The popularity scores indicate the average quality of the individual recommended itineraries with respect to the historical trips adopted by past users. Note that the F1 or pairs-F1 scores are always between 0 and 1. 5.3.2 Diversity We adapt the diversity metric used in [28], originally deﬁned to measure the diversity among POIs in a set. To measure the diversity of a set of itineraries Scontaining k itineraries, we ﬁrst measure a similarity value sim(I, I) for a pair of itineraries Iand I. We then deﬁne the diversity value of a recommended set of itineraries S= {I, I, · · · , I} of size k as div(S) =1k(k − 1)(1 − sim(I, I)) In Equation 6, we calculate the average diversity between all k(k − 1) pairs in the recommended itinerary set S. For each pair, the diversity value is the dissimilarity value between the two itineraries, i.e., 1 − sim(I, I). As long as the similarity measure sim(I, I) is between 0 to 1, the dissimilarity measure and thus div(S) will also remain between 0 to 1, with higher value indicating higher diversity between the recommended itineraries. In our experiments, we adopt the F1 score between a pair of itineraries as the similarity measurement, ignoring the source and destination POIs. Also observe that, the notion of popularity and diversity is somewhat conﬂicting. For example, suppose a model is to recommend 2 alternative itineraries. If the model recommends the most popular itinerary 2 times, it will achieve the maximum average popularity score, but the diversity score of the recommended itinerary set would be 0. If it attempts to diverse from this most popular itinerary, it would achieve the diversity score. But unless it can align with an alternatively popular itinerary, the popularity measure of this second recommended itinerary will be low and the average popularity score will drop. Thus to achieve higher popularity and diversity scores at the same time, a model must recommend quality alternative itineraries with respect to the historical trips. 5.3.3 Combination of Popularity and Diversity Since our goal is to recommend quality alternative itineraries that are both popular and diverse, we need a measure that combines the popularity and diversity of S. We employ the widely used weighted sum to deﬁne the combined metric as comb(S) = α × pop(S) + (1 − α) × div(S) where pop(S) is the average popularity score of the recommended itineraries which is computed using the F1 score as discussed earlier in Section 5.3.1. The parameter α ∈ [0, 1] speciﬁes the relative importance of popularity and diversity.For example, α < 0.1 gives very little importance to the popularity of the itineraries, and α > 0.9 provides very little importance to the diversity of the itineraries. Thus we consider 0.1 ≤ α ≤ 0.9 during our evaluation. To give equal importance to both popularity and diversity, we set α = 0.5 as a default value. It is important to note that our proposed approaches, both DeepAltTrip-LSTM and DeepAltTrip-Samp are agnostic to the above metrics, and our motivation is to learn popular alternative routes without any such explicit modeling of popularity and/or diversity. Yet, we show that that our proposed learning-based approaches outperform baselines signiﬁcantly w.r.t. these traditional metrics. 5.4 Hyperparameter Tuning We now describe the hyperparameter values used in DeepAltTrip-LSTM and DeepAltTrip-Samp.Recall that our algorithm ﬁrst obtains POI graph embeddings through two separate graph autoencoders. It then trains two LSTM models. Finally separate itineraries are generated through k different prominent POIs, through the use of either an LSTM based technique (DeepAltTrip-LSTM) or a sampling based technique (DeepAltTrip-Samp). Graph Autoencoders and ITRNet: For the graph autoencoder, the embedding dimensions Zand Zwere 12 and 24, respectively. The autoencoders were trained with learning rate of 0.05 and 0.01 respectively, using the Adam optimizer. The hidden layer size for both the forward and backward LSTM models was 32. The dimension of the MLP layer was 30. Here, the learning rate was set 0.001 for the whole model, using the Adam optimizer as before. Both the LSTM models were trained with a batch size of 32. DeepAltTrip-LSTM: To generate ﬁxed length itineraries containing L POIs, we ﬁrst generate the half itinerary as prescribed in the algorithm setting Lto L − 1, and then the other half itinerary is generated such that the length of the total itinerary is L. Also Lis set to the length of the longest itinerary found in the training dataset. DeepAltTrip-Samp: We start with an initial itinerary consisting of L POIs by placing the intermediate prominent POI at a random position between 2 to L − 1. We ignore the insert and delete operations here as those operations would change the length. Replacement or Swap and Replace operations are performed each with probability 0.5. For prominent POI, we do not use replace operation and only apply Swap and Replace operation with probability 0.5. The sampling algorithm is run for 5(L−2) iterations in total. This ensures that when the search space is larger (i.e., larger L), the algorithm runs more iterations to achieve good quality. 5.5 Performance Comparison We now discuss performance in terms of the evaluation metrics considered. We ﬁrst consider the average popularity and diversity of the recommended itineraries independently, after that we consider the combined score to assess the performance of the system to return multiple alternative itineraries. Next we evaluate the effect on performance if we vary the length of the recommended itineraries and also if we vary the no. of itineraries to be recommended. We also compare the running times of the variations of DeepAltTrip and also compare them with the baselines. 5.5.1 Considering Popularity and Diversity Independently Table 3 shows the popularity (using both F1 score and pairsF1 score) and the diversity of the itineraries recommended by each approach. We see that the average F1 and pairsF1 scores of both of our approaches are similar to those of the competitors which are the state-of-the-art for returning most popular itineraries. On the other hand, the average diversity of the recommended itineraries provided by our approaches far exceed those of the competitors in all datasets. For example in the Edinburgh dataset, DeepAltTrip-LSTM and DeepAltTrip-Samp provide 19.13% and 12.60% higher average diversity, respectively, than the nearest competing baseline. This shows that our approaches provide much more diverse itineraries while keeping the popularity of the recommended itineraries on par with the other baselines. In other words, these baselines primarily focus on popularity, and the competitive F1 and pairs-F1 scores show that our approaches generate diverse itineraries without compromising on the popularity of the recommended itineraries, thus providing quality alternative itineraries. 5.5.2 Considering Combined Popularity and Diversity Score We vary α in the combined metric from 0.1 to 0.9 and show the results for each value in Table 5. Due to space constraints, we only present the results for two datasets, one from each group. Results on the other datasets show similar trends. Again the length of the recommended itineraries is set to 3 and the no. of itineraries recommended is set to 5. The scores of the combined metric is shown in Table 5. We observe that both variants of DeepAltTrip outperform the competitors even when α is set to 0.9, i.e., the popularity is given a much higher importance than diversity. When both are given equal importance i.e., α = 0.5, we see that in the Epcot dataset DeepAltTrip-LSTM and DeepAltTrip-Samp outperform the nearest competing baseline by 29.24% and 25.34%, respectively. 5.5.3 Effect of Varying Length of Recommended Itineraries We vary the length L of the recommended itineraries as 3, 5, 7, and 9. Table 4 shows the results. We show the results for the Edinburgh and Epcot datasets (other datasets also follow similar trend). Note that, for all values of L, the average F1 and pairs-F1 score remain similar to those of the competitors that primarily focus on providing popular itineraries. However, the diversity of the recommended itineraries by DeepAltTrip-LSTM and DeepAltTrip-Samp are signiﬁcantly higher than these competitors. We observe that, as the value of L increases, both DeepAltTrip-LSTM and DeepAltTrip-Samp outperform the nearest competing baseline by a greater margin. For example, for the Edinburgh dataset, DeepAltTrip-LSTM provides 19.13% increase in diversity and 10.33% increase in the combined score for L = 5, whereas it provides a 136% increase in diversity and a 44.38% increase in the combined score for L = 9. Similarly, for DeepAltTrip-Samp in the Edinburgh dataset, we see a 12.60% increase in diversity and 6.72% increase in the combined score for L = 5, whereas a 107% increase in diversity and 34.55% increase in the combined score for L = 9. This is primarily because the average diversity provided by the baselines signiﬁcantly drops for larger L. Note that, for the case when itinerary length is 3 (including s and d), diversity for each approach is maximum (i.e., 1) which is because the only intermediate POI in each itinerary is different from the other recommended itineraries. Here we set the length of itineraries recommended, L to 5. Again we show the results in two datasets for space constraints, taking one each from the two different domains. Other datasets show similar trends. The results are shown in Table 6. Our proposed approaches consistently achieve higher diversity even for larger k. The average F1 score of the recommended itineraries slightly drop for all approaches, however, our approaches are comparable to the baselines. Consequently, we see that both DeepAltTrip-LSTM and DeepAltTrip-Samp provide signiﬁcantly higher combined scores. For example, in the Edinburgh dataset, DeepAltTrip-LSTM provides 11.74% , 10.32%, 10.69% and 11.72% higher combined score with α = 0.5 for k = 2, 3, 4 and 5, respectively. Also DeepAltTrip-Samp provides 9.53%, 6.72%, 7.57% and 8.42% higher combined scores for k = 2, 3, 4 and 5, respectively, in the same dataset. 5.6 Running Time Comparison We run all the algorithms on the same machine equipped with Intel core-i7 8565U CPU, 16GB RAM. We record the average time per query (in seconds) for ﬁve folds of the dataset, and report the average time per query taken across the ﬁve folds. We vary the length of recommended itineraries, L as 3,5,7 and 9 and keep the no of recommended itineraries k as 3. As the Melbourne dataset has the maximum no. of POIs and Disneyland dataset has maximum no. trips, we show the results for these two datasets to depict the scalability of the algorithms. The results are shown in Table 7. TABLE 7: Query Execution Time (Seconds) We observe that DeepAltTrip-LSTM and NASR+DBS have similar execution times in both datasets; whereas DeepAltTrip-Samp takes more time than the other approaches. We also see that the execution time increases with the increase of L. However as trip recommendation systems generally do not recommend excessively long routes to users [12], this increasing trend of query execution time is quite acceptable. We observe that although the Melbourne dataset have almost three times more POIs than the Disneyland dataset, the average execution time per query remains similar for NASR+DBS, DeepAltTrip-LSTM and DeepAltTripSamp. Hence, the running times of these three algorithms are not signiﬁcantly inﬂuenced by the no. of POIs; whereas the execution time of Markov+DBS increases substantially as the no. of POIs increases. This paper proposed two deep-learning-based approaches that learns to recommend top-k alternative itineraries for a given source and destination. We ﬁrst developed Itinerary Net (ITRNet) that estimates the likelihood of POIs on an itinerary by using graph autoencoders and two (forward and backward) LSTMs. Based on the ITRNet, we have developed two variants, DeepAltTrip-LSTM and DeepAltTripSamp, to recommend k alternative itineraries using historical trips without requiring any explicit popularity or diversity modeling. Our DeepAltTrip-Samp solution can also trivially incorporate various user deﬁned constraints. Extensive experiments using real-world datasets show that the DeepAltTrip-LSTM and DeepAltTrip-Samp outperform the best performing baselines by up to 29.24% and 25.34%, respectively, for the default settings w.r.t. the combined popularity and diversity measure. In the future, we plan to incorporate user personalization leveraging information of the historical routes visited by the querying user.