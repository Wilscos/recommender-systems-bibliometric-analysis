 at www.springerlink.com. DoI: 10.1007/978-3-030-92518-5 International Institute of Information Technology Bangalore, India Abstract. In a typical ride-hailing service, the service provider (RS) matches a customer (RC) with the closest vehicle (RV) registered to this service. Ride-hailing services have gained tremendous popularity over the past years, and several works have been proposed to ensure privacy of riders and drivers during ride-matching. TRACE is an eﬃcient privacypreserving ride-hailing service proposed by Wang et al. (IEEE Trans. Vehicular Technology 2018). TRACE uses masking along with other cryptographic techniques to ensure eﬃcient and accurate ride-matching. RS computes a (secret) spatial division of a region into quadrants. The RS uses masked location information to match RCs and RVs within a quadrant without obtaining their exact locations, thus ensuring privacy. Additionally, an RC only gets to know location of the closest RV ﬁnally matched to it, and not of other responding RVs in the region. In this work, we disprove the privacy claims in TRACE by showing the following: a) RCs and RVs can identify the secret spatial division maintained by RS (this reveals information about the density of RVs in the region and other potential trade secrets), and b) the RS can identify exact locations of RCs and RVs (this violates location privacy). Prior to exchanging encrypted messages in the TRACE protocol, each entity masks the plaintext message with a secret unknown to others. Our attack allows other entities to recover this plaintext from the masked value by exploiting shared randomness used across diﬀerent messages, that eventually leads to a system of linear equations in the unknown plaintexts. This holds even when all the participating entities are honest-but-curious. We implement our attack and demonstrate its eﬃciency and high success rate. For the security parameters recommended for TRACE, an RV can recover the spatial division in less than a minute, and the RS can recover the location of an RV in less than a second on a commodity laptop. Keywords: Location Privacy · Privacy-Preserving Protocols · RideHailing Services · Cryptanalysis · Random Masking © Springer Nature Switzerland AG 2021. The ﬁnal published version is available Ride-hailing services such as Uber and Lyft have become a popular choice of transportation in the past decade [9]. By oﬀering convenience and reliability to its customers, these services are well suited for intra-city commutes. A ridehailing service usually consists of three entities: the ride-hailing server (RS), riders or customers (RCs) and drivers or vehicles (RVs). The RS is primarily responsible for hosting the ride-hailing service publicly. Drivers can register to this service and become identiﬁed as certiﬁed RVs. A customer who wishes to make use of this service can sign up as an RC and request for a ride. Depending on the pick-up and destination locations, the RS smartly forwards this ride request from RC to suitable RVs in the region. A list of nearby available RVs is revealed to the RC along with their reputations, who then makes a suitable choice. consequences. A pick-up location could correspond to the residential address of an RC, which can be used for stalking/kidnapping. There have also been instances when RVs registered to a particular ride-hailing service have been targeted by regular taxi drivers or targeted for theft [14,4]. Preserving privacy of sensitive users’ locations has become a primary concern in ride-hailing services. Generally, the RS is assumed to be honest-but-curious. This means that RS tries to learn as much information as possible without maliciously deviating from the ride-hailing protocol. Such a model is reasonable to assume since the RS wishes to preserve its reputation among the public. But it is still dangerous for the RS to learn locations of RCs and RVs, in case the RS later turns malicious or becomes a victim of cyberattacks [3,8]. location privacy of RCs and RVs in the context of ride-hailing services. Section 5 contains an overview of recent papers in this area. These works use cryptographic primitives to hide sensitive location information from the RS, while trying to ensure eﬃciency and ride-matching accuracy. TRACE is a privacy-preserving solution to ride-hailing services. Here, the RS ﬁrst spatially divides each city into quadrants. RCs and RVs mask their sensitive location information using randomness and then forward it to RS. The RS then identiﬁes the quadrant in which RCs and RVs lie, without ﬁnding out their exact locations. To ensure eﬃciency and accuracy, the ride request from an RC is forwarded only to RVs that are in the same quadrant as RC. The RC then makes a choice among RVs that lie in its vicinity to ﬁnalize ride establishment. Since the RS knows the distribution of RVs in diﬀerent quadrants, it can periodically change its spatial division of the city to optimize bandwidth usage, reduce waiting time and improve accuracy. protocol from learning the underlying message. At a high level, a large prime p is chosen and the plaintext is multiplied with a random integer in Z messages are encrypted using shared keys to prevent external eavesdroppers from However, revealing locations of RCs/RVs to other entities can have severe In the past few years, there have been many works that focus on ensuring In this paper, we focus on TRACE [16], proposed by Wang et. al. in 2018. TRACE uses masking with random secrets to prevent other entities of the gaining any useful information. Since TRACE uses lightweight cryptographic techniques and simple modular arithmetic, it is eﬃcient in practice. The security guarantees for TRACE state that RS cannot learn about the exact locations of RCs and RVs apart from the quadrant they are in. Additionally, RCs and RVs cannot learn about the secret spatial division maintained by RS, since this could reveal the density of drivers across the city, among other proprietary information and trade secrets of RS. We propose an attack on TRACE and disprove the above security claims by showing that the RS can indeed retrieve the exact locations of all RCs and RVs. Secondly, we show that RCs and RVs can learn the secret spatial division information maintained by RS. These attacks constitute a total break of the privacy objectives of TRACE. The underlying idea behind our attack is to eliminate the (unknown) randomness shared across diﬀerent messages when other entities mask their location values. This allows one to eﬃciently obtain an overdetermined system of linear (modular) equations in the unknown plaintext locations. We stress that this attack is purely algebraic, and does not make any geometric assumptions about the region. Our attack is eﬃcient (runs in time quadratic in the security parameters) and holds even when all entities are honest-but-curious. For instance, with the recommended security parameters from [16], an RV can recover the quadtree maintained by RS in under a minute (see Table 2) and the RS can recover the exact location of an RV in under a second (see Table 3). steps of the TRACE protocol from [16]. The ﬁrst attack in Section 3.1 describes how RCs and RVs can recover the secret quadtree maintained by RS. The second attack in Section 3.2 describes how the RS can recover exact locations of RCs and RVs. We brieﬂy discuss a modiﬁcation to the TRACE protocol that prevents only the ﬁrst attack, and argue that the second attack (which is more severe than the ﬁrst) is hard to thwart. Algorithms 1 and 2 summarize the above two attacks. Section 4 provides details about our experimental setup and evaluates the eﬃciency and success rate of our attack in practice (refer Tables 2 and 3). Section 5 gives an overview of recent works in the area of privacy-preserving ride-hailing services. We conclude our paper and provide remarks about future work in Section 6. This section contains a high level overview of the TRACE protocol [16]. Details that are not directly relevant to our attack will be omitted. For more information the reader is referred to the original paper. The rest of our paper is organized as follows. In Section 2, we describe relevant A quadtree {N partition of a 2-D space into quadrants and subquadrants. Each node N tree is associated with four (x, y) coordinates denoting corners of the quadrant represented by that node. Every non-leaf node in the quadtree has four children denoting the division of that quadrant into four subquadrants. An example is presented in Figure 1. easily check if P lies within the quadrant by doing the following [16, Section III]. For each j compute where j otherwise it does not. Given a quadtree, this idea can be extended to ﬁnd the quadrant/node of the tree in which P lies. Starting at the root, among its four children, ﬁnd that quadrant/node in which P lies; then recurse on its children until a leaf is encountered. System Design. The three primary entities in the TRACE protocol are the ride-hailing server/service provider (RS), the customer/rider (RC) and the vehicle/driver (RV). All of the aforementioned entities are assumed to be honestbut-curious. This means that they wish to learn as much information as they can about the other entities without violating any protocol steps. RVs. As part of the protocol, RS maintains a spatial division of the city into quadrants and uses it to identify regions in which RCs and RVs lie. It does so in such a way that RCs and RVs do not learn any information about the spatial division, while RS does not learn the exact locations of RCs and RVs. The RC can choose a pick-up point and send a ride-hailing request to RS, who then forwards it to the RVs that lie in close vicinity of RC. RVs submit their Given a point P = (x, y) and a quadrant {(x, y)} with j = 1, . . . , 4, we can = (j mod 4) + 1. If all S≥ 0, then P lies within the quadrant, RS is mainly responsible for forwarding requests/responses between RCs and masked location information to RS at regular intervals, allowing the RS to have an idea of distribution of RVs in the city. Depending on the density of RVs, RS can periodically optimize its space division to improve ride-matching accuracy. TRACE. All entities are assumed to be honest-but-curious, that is, they follow the protocol speciﬁcation but may infer additional data from the observed transcripts. RS does not collude with RCs and RVs (to try and obtain information about customers), since it has an incentive to maintain high reputation. and RVs is not revealed to other entities. The spatial division maintained by RS should also be kept secret, as this could reveal information about density of drivers in a city and other proprietary information/trade secrets of RS. The authors of TRACE claim that the following security requirements are satisﬁed during the protocol execution. Claim 1 RS creates a quadtree N containing information about spatial divison of the city into quadrants, and masks it with a randomly chosen secret to compute EN. Given EN , RCs and RVs do not learn anything about N. Claim 2 RS can only learn the quadrants in which RCs lie. RS does not obtain any other information about the exact pick-up locations of RCs. Claim 3 RS can only learn the quadrants in which RVs lie. RS does not obtain any other information about the exact locations of RVs. This section describes the execution of the TRACE protocol. Figure 2 gives a summarized view of the messages exchanged between diﬀerent entities. RS acts as a central entity for forwarding messages between RCs and RVs. It establishes shared keys with RCs and RVs through the Diﬃe-Hellman key exchange. All messages exchanged between RS and RCs, RVs are encrypted using a symmetric encryption scheme. The authentication of entities is ensured by signing these messages using the BLS signature scheme [1]. The notations used in the TRACE protocol and their descriptions are provided in Table 1. and (·) ple, the group and its generator used in the signature scheme, public key of RS, choice of symmetric encryption). RCs and RVs also establish their public keys. RS announces security parameters k they specify the size of diﬀerent randomness used when masking location information. Step 3 elaborates on the constraint that should exist among these four parameters to ensure correctness of the protocol. respectively) and a random secret s ∈ Z Threat Model. We assume the same threat model that is considered in Security Goals. It is essential to ensure that location information of RCs For convenience, the remainder of this paper shall refer to subscripts (·) as simply (·)and (·), respectively. Step 0. RS publishes details about diﬀerent system parameters (for exam- RS chooses two large public primes p and α (of size kbits and kbits, represented by a quadtree with m nodes. The i-th quadrant N j = 1, . . . , 4. RS wishes to learn the quadrant in which each RV lies without learning its exact location. To do this, RS sends a masked version of N Concretely, RS chooses 24 random values a in the anticlockwise direction, i.e. j k, k, k, kSecurity parameters of TRACE α, pLarge primes chosen by RC (x, y) Coordinates of j-th vertex in the i-th quadtree node N s, aRandom values used by RS when masking N SSquare with (x, y) at its center s, dRandom values used by RC when masking (x, y) Table 1. Description of the notations used in the TRACE protocol. Step 1. RS divides the two-dimensional space into squares or rectangles bits each. For every vertex Nof N, let Nbe the vertex adjacent to it computing The values α, p are public, whereas s, x masked coordinate is where k denotes concatenation. Next, RS computes the masked quadrant for i = 1, . . . , m, to get the masked quadtree It then encrypts EN and forwards it to RV. ness to mask its location (x fresh random number r That is, RV encrypts A and forwards it to RS. the following computations to identify the quadrant/node N which RV lies. Step 2. RV decrypts this message and uses EN along with its own random- A= r· α(x· EN+ y· EN+ EN) mod p , A= r· α(x· EN+ y· EN+ EN) mod p , RV chooses a random permutation π(·) to reorder the j-indices for each A. Step 3. RS obtains A that contains the masked location of each RV, and does Similarly, Next, RS computes the diﬀerence whether RV lies in N the method described in Section 2.1, RS can query the quadtree to identify the exact quadrant where RV lies. obtaining B respective of whether RV was inside the quadrant N modulus it is suﬃcient if the following is always true during the computation of Let h·i denote the bit length of a non-negative integer. Recall that hpi = k are chosen such that Compare this to Equation (1). Since ris always positive, RS can identify Note that it was necessary to remove the modulus with respect to p when (a similar condition exists for B). i = k, hri = k. To ensure the above conditions hold, the parameters Moreover, the size of location coordinates are assumed to be negligible compared to these security parameters. In [16], the above values are set as k 160, k with respect to the quadtree and send it to RS. Suppose the pick-up point of RC is (x with this pickup point at its center. Let the vertices of this square be {(x tion (x computation here; after receiving EN from RS, it computes a masking for each of the four vertices of S bits, a secret s RC encrypts C, D, E and sends it to RS. RC to RVs that are “nearby” to it. RS decrypts the message from RC to get C, D, E. Similar to Step 3, for each of C in which the vertex represented by C the quadrants in which the corners of square S RV lies. RS encrypts D, E and sends it to those RVs that lie in CS RVs as SRVs). about its own location (x of k SRV encrypts and sends I, F to RC via RS. = 75, k= 75. Step 4. RC receives EN from RS. Now the RC tries to mask its location , y), (x, y), (x, y)}. Recall that in Step 2, each RV masked its loca, y) with respect to EN and computed A. RC also does an equivalent Next, RC chooses a public prime pof size kbits, a public prime αof k Step 5. The goal here is to convey the masked location information from enclosing S. From Step 3, RS also knows the quadrants in which each Step 6. SRV receives D, E from RS and tries to add in masked information bits each and computes locations) to check if that SRV is within distance R. When K ≤ 0, the SRV is within the circle query range C RC. Call such SRVs as CRVs. to p With the relationship imposed on the security parameters (Equation (2) in Step 3), the following condition holds and the modulus is removed. 2) to create C oﬀ point usually lies very close to the RC’s pick-up point from Step 4). Similar to Step 3, RS uses C lies. RS chooses a random location AT P in this subregion and forwards it to CRVs. Each CRV inspects ATP to make a decision on whether to accept this ride-hailing request from RC. The CRVs who decide to accept send an “Accept Response” to RS. RS forwards the list of ready and available CRVs to RC. RC chooses a suitable CRV from this list, and this CRV is informed about the same by RS. Later, the RC and the chosen CRV proceed with ride establishment by negotiating a shared session key and by exchanging information such as location, phone number, reputation, etc. This section presents two attacks which (with high empirical probability) disprove the following privacy claims made about TRACE. First, in Section 3.1, we show that RCs and RVs can obtain the secret spatial division (quadtree) Step 7. RC uses I, F (that contain masked information of RC’s and SRVs’ J=J − (J mod α)α= r(x· x+ y· y) , Once again (similar to Step 3) we need to eliminate the modulus with respect (otherwise K would always be positive even if the SRV had distance > R). Step 8. RC masks its take-oﬀ point (x, y) using EN (similar to Step information maintained by RS (violation of Claim 1). We also discuss a modiﬁcation to the TRACE protocol, as a countermeasure for this attack. Secondly, in Section 3.2, we show how the RS can identify exact locations of all RCs and RVs (violation of Claims 2, 3). We also brieﬂy argue why this attack is not straightforward to thwart. In both attacks, the entities recover location coordinates modulo prime p. This is same as recovering the actual integer values since p is a very large prime and the coordinate values are negligibly small compared to p. as and when needed. In Section 4, we shall experimentally evaluate the success probability of our attacks. After an RV receives the masked quadtree EN computed by RS (Step 2), we show how it can recover all underlying vertices x This same principle allows an RC to obtain information about the quadtree as well (recall that each RC receives EN from RS in Step 4). is masked by the RS using random values s, α, a an RV receives EN single EN equation for each EN involved in EN j = 1, . . . , 4; h = 1, . . . , 6). A key observation is that if one considers EN with a diﬀerent EN number of unknowns involved is 1+24+8+8 = 41 (s, a additional EN This would allow RV to solve this system of modular equations and obtain the secrets s along with quadrant vertices of N vertices of quadrants N task is to eliminate the unknown randomness a This can be done by subtracting EN the following equations. Steps from the TRACE protocol described in Section 2.3 will be referred Intuition. Intuitively, our attack works as follows. Each quadtree node N , the number of equations involved is 4 × 6 = 24 (since there is one , y, x, y, where j = 1, . . . , 4; h = 1, . . . , 6). That is, considering an Formal attack. Without loss of generality, we show how an RV can recover Here j 16 variables x equations in these variables by eliminating s, α as follows. = (j mod 4)+1. The parameters s, α are unknown to RV along with the Compare (3) × y+ (6) × xand (7): Compare (3) × y+ (6) × xand (7): Compare (4) × x+ (5) × yand (8): Compare (4) × x+ (5) × yand (8): Compare (3) and (4): Similarly, compare (4) and (5), and (5) and (6): are 28 linear (modular) equations in the 16 unknowns (x j = 1, . . . , 4. This can be treated as a linear system of equations with elements from the ﬁeld Z Elimination can be applied to ﬁnd solutions for X in Z Existence of a unique solution Suppose we represent Equations (9)—(15) using matrix notation as P X = Q, where dim(P ) = 28 × 16, dim(X) = 16 × 1, dim(Q) = 28 × 1, and vector X represents the 16 unknown quadrant vertices of solutions for X from this system. number of unknowns. Previously, considering only N and 8 × 2 = 16 unknowns. If we instead consider N pairwise combinations, we end up with 28 × 3 = 84 equations and 8 × 3 = 24 unknowns (which is slightly better). But we observed that in some cases, the resulting 84 × 24 matrix P had rank 23 < 24. Next, considering N and taking 8 × 4 = 32 unknowns. We observed (from experiments described in Section 4) that the corresponding 168 × 32 matrix P always had rank 32, and an RV can therefore solve this system to get the unique values (in Z for N be redundant since rank already equals the number of unknowns. (9)—(15) (for vertices of N known vertices of N 28 × 8, dim(X manner, take all system that considers all the above systems simultaneously. Here 0 denotes the zero matrix of dimension 28×8, dim(P ) = 168×32, dim(X) = 32 × 1, dim(Q) = 168 × 1 and rank(P) is experimentally observed to be 32. The Consider Equations (9)—(15) for all j = 1, . . . , 4; j= (j mod 4)+1. There , N. We observed that rank(P ) ≤ 13 < 16, and the RV cannot obtain unique Hence we propose a modiﬁcation to our attack such that rank(P ) equals the , . . . , N. One can proceed further and consider more N, but that would We now formalize the above idea. Let the linear system deﬁned by Equations Here P, Xand P, Xare submatrices corresponding to un- RV can solve this system to obtain unique solutions for X (i.e. quadrant vertices of N rants N distinct N other quadrants as well, until all of them are recovered. We summarize the attack in Algorithm 1. The same idea also allows an RC to recover the quadtree, when it receives EN from RS. sumptions about geometry of the region. The same attack would still work even if quadrants in the spatial division were not restricted to rectangles/squares. dim(P ) = 168×32, dim(X) = 32×1, dim(Q) = 168×1, and all operations are in the ﬁeld Z solve such a system dm/4e times to recover vertices of all m quadrants. The total asymptotic complexity of this attack is O(k practice, and Table 2 shows the average time taken to recover quadrant vertices for varying tree sizes and security parameters. uses the same set of 24 random values a out all EN tion 2.3). However, upon careful observation, one can see that the correctness of the TRACE protocol would still hold if diﬀerent set of values of a were used for each EN TRACE protocol, these random values are involved only when computing B Input : Size of quadtree m, masked quadtree EN = (EN, . . . , EN) Output: Underlying quadrant vertices N = (N, . . . , N) Procedure Recover Quadtree(m, EN ) : while size(EN) > 0 do Pick four random entries EN, EN, EN, ENand delete them from for each of thepairwise combinations (i, i) from a, b, c, d do end Using the above matrices, deﬁne the system P X = Q similar to (17) Solve this system to obtain quadrant vertices corresponding to end Output: (N, . . . , N) , . . . , N) in Z. Note that there is no restriction here to use equations for the ﬁrst four quad, . . . , N. The RV can consider equations corresponding to any four We remark that this attack is purely algebraic and does not make any as- Complexity. The linear system of equations represented by P X = Q, where , can be solved in time O((log p)) = O(k) [2]. We need to repeatedly Remark. The aforementioned attack mainly relies on the fact that TRACE , i = 1, . . . , m; j = 1, . . . , 4; h = 1, . . . , 6 and mask ENwith a. In the and B out when computing B each time when computing EN and RVs from obtaining the secret quadtree because, EN randomness each time and no information can be obtained about (x given the EN to the following lemma. Lemma 1. The above modiﬁcation to TRACE provides information-theoretic security against any passive adversary who wishes to obtain additional information about the quadtree maintained by RS. the RS in obtaining locations of RCs and RVs. We will also later see that a similar countermeasure does not exist for the latter attack. Trying to use fresh randomness there will violate the correctness of the protocol. RS ﬁnds location of RVs. In Step 3, RS receives A π used on the four A the RS can enumerate all of them to try and ﬁnd π. ρ (among the set of all permutations on four elements), RS permutes the four components of A when ρ = π eliminate r In this way, RS can obtain four linear equations for j = 1, . . . , 4, in the two unknowns x (if a solution does not exist, move to the next choice of ρ). The remaining two equations can be used to check if the values of x consistent. If so, then with high probability RS can infer that ρ = π solution to set S (Step 3). Correctness still holds since these values cancel each other Therefore, one can modify the TRACE protocol by using a new random a However, as we shall see in Section 3.2, this modiﬁcation does not prevent , i = 1, . . . , m, from each RV, that contains masked information about , y). RS knows ENbut does not know rand the random permutation For each i, RS initializes an empty set S. For each choice of permutation corresponds to the original value AkAkAkAcomputed by RV only Algorithm 2: RS recovers location of an RV choice for ρ. Note that S this solution satisﬁes the consistency checks when ρ = π be possible that a false positive also passes these consistency checks for a diﬀerent ρ and is added to S A’s received by RS (in general 30 ≤ m ≤ 100 [16, Section VI]), and the original positive appears in every S common element present in all S would be the required location of RV . Once again, there are no assumptions made regarding geometry of the spatial region. We summarize the attack in Algorithm 2. permutations. In each choice of permutation, RS solves a system of equations in two variables (with all elements being in Z other equations to ﬁnally obtain the set S later computes the intersection of all S Input : (A, . . . , A) representing masked information about an RV’s Output: RV’s location (x, y) Procedure Recover Location(A, . . . , A) : for i = 1, . . . , m do P = set of all permutations on 4 elements for ρ ∈ P do end /∗ With high probability, we have | ∩S| = 1 ∗/ {(x, y)} = ∩S end Output: (x, y) The above procedure is discussed only for one value of i. There are m such , yis present in each S. Moreover, it is highly unlikely that the same false Complexity. For each i = 1, . . . , m, RS enumerates over all 24 possible these operations can be done in time O(k taken to recover (x Recall that RC chooses a square S center. Each C similar to how RV masked its location as A (refer to Step 2). Since we just saw an attack where RS can recover the original underlying location when given such a masking, RS can obtain the 4 vertices corresponding to S this square directly gives the pick-up location of RC. RC, which is a masking of RC’s take-oﬀ location using EN similar to what we have seen in Step 2. Using the same attack as for RV, RS can directly recover RCs location from C are quite close. crypted quadtree term EN to apply the same argument here, then in Step 2 of the TRACE protocol, A and A 3 of the TRACE protocol, this would mean B is masked with r r, and one cannot infer whether the RV lies inside the quadrant N checking the sign of B the TRACE protocol, and we believe that other countermeasures for this attack are not straightforward to come up with. In this section, we discuss the experimental setup and other implementation aspects of the attacks mented using SageMath [13] and run on an Intel Core i5-8250U CPU @ 1.60 GHz with 8 GB RAM running Ubuntu 20.04 LTS. The TRACE paper [16] states that setting (k should be suﬃcient to ensure that Claims 1, 2, 3 hold. We also initialize these security parameters with the same values. In addition, we demonstrate the robustness of our attack by performing another set of experiments with larger values (2048, 1000, 400, 400) satisfying Equation (2). Note that our attack is clearly independent of the security of encryption schemes/digital signatures used in TRACE. attack/tree/trace-attack. RS ﬁnds location of RCs. In Step 5, RS receives CkCkCkCfrom RC. RS can also ﬁnd the take-oﬀ location of RC. In Step 8, RS receives Cfrom Remark. In Section 3.1 we saw that using fresh randomness for each enhave to be masked with diﬀerent (and fresh) randomness, say rand , respectively (currently, they are both masked by the same r). But in Step The implementation can be accessed at https://github.com/deepakkavoor/rhsence to the dataset that was used to create spatial divisions. So, we simulate the creation of an arbitrary quadtree by ﬁrst choosing an outermost rectangular quadrant, followed by picking a random center and dividing it into four subquadrants. We repeat this for the smaller quadrants until the number of nodes in the tree is m. The TRACE implementation in [16] varies m between 28 and 84; we set m = 50 and m = 100 in our experiments. The attack indeed works for any value of m (recall m ≥ 4) and its success probability increases with m. cation coordinates are negligible compared to the security parameters k the vertices of the outermost quadrant are randomly chosen in the range [0, 2 1] (for (k (2048, 1000, 400, 400)). RS computes the encrypted quadtree EN and sends it to an RV as described in Section 2.3. Next, RV carries out the attack described in Section 3.1. We perform 20 iterations of this attack, and in each iteration, the RS generates a fresh random quadtree (as described in Section 4.1) and computes EN accordingly. We observed that in all iterations, RV was able to recover the exact values of all quadrant vertices every time. We repeat the same for diﬀerent choices of m and security parameters, and tabulate the average time taken to recover the quadtree in Table 2. Since the same attack allows an RC to recover the quadtree, similar experimental statistics can be expected in this case. Table 2. Time taken (in seconds) for an RV to recover quadtree, averaged over 30 iterations. The location (x rant. We simulate the exchange of messages between RS and this particular RV, following the steps of TRACE protocol (Section 2.3). Next, RS carries out the attack described in Section 3.2. We perform 30 iterations of the attack with freshly generated (random) values for quadtree and (x The implementation of TRACE protocol from [16] does not give any refer- Integer modular arithmetic is used in all computations. Since the sizes of lo- , k, k, k) = (512, 160, 75, 75)) and in [0, 2− 1] (for (k, k, k, k) = Table 3. Time taken (in seconds) for RS to recover an RV’s location, averaged over 30 iterations. We observed that in all iterations, RS was able to recover the exact location of the RV. That is, | ∩ as the RV’s location in all iterations (refer Algorithm 2). We repeat the same for diﬀerent choices of m and security parameters, and tabulate the average time taken to recover RV’s location in Table 3. RV. Since we assume the distribution of RC’s location to be random as well, the same statistics also hold true when RS recovers the location of an RC. We brieﬂy mention the prior works in privacy-preserving ride-hailing services. Since these works use fundamentally diﬀerent ideas (such as homomorphic encryption, garbled circuits) compared to TRACE (which relies on random masking), our attack does not directly apply to these works. solution towards privacy in ride-hailing systems. The locations and identities of riders are hidden using cloaked regions and anonymous credentials. They use eﬃcient cryptographic primitives to ensure privacy of sensitive information. ORide by Pham et al. [10] oﬀers accountability guarantees and secure payments along with privacy of riders and drivers. They use homomorphic encryption to compute the Euclidean distance and identify the closest driver in a zone. [5] proposes a modiﬁcation to ORide to ensure location privacy of responding drivers in the region with respect to a rider. services. They analyze APIs in non-privacy preserving apps provided to drivers by Uber and Lyft. non-colluding servers, one of them being the RS and the other a third-party Crypto Provider (CP). They use road network embedding in a higher dimension to approximate shortest distance over road networks. The homomorphically computed (approximate) distances are compared using a garbled circuit. Their scheme provides higher ride-matching accuracy than ORide while being computationally eﬃcient. lpRide by Yu et al. [19] improves upon pRide by eliminating the need for a second Crypto Provider. They use a modiﬁed version of Paillier The attack to recover an RC’s location is exactly the same as that for an PrivateRide by Pham et al. [11] is the ﬁrst work that provides a practical Zhao et al. [20] conduct a study on leakage of sensitive data in ride-hailing pRide by Luo et al. [7] proposes a privacy-preserving solution involving two cryptosystem for encrypting locations of riders and drivers. However, [15] proposed an attack on the modiﬁed Paillier scheme used in lpRide, allowing the service provider to recover locations of all riders and drivers in the region. act shortest road distance using road network hypercube embedding. They use somewhat homomorphic encryption over packet ciphertexts to achieve high ridematching accuracy and eﬃciency, reporting signiﬁcant improvements over ORide and pRide. Xie et. al. [17] improve upon pRide by combining the idea of road network embedding with cryptographic constructs such as Property-preserving Hash. They eliminate the need for a trusted third-party server to compute shortest distances. SP) in 2013, which allows two parties P−→ b , respectively) to jointly compute the scalar product formation about P by the output itself), for i ∈ {0, 1}. Their protocol was claimed to achieve information-theoretic security using random masking, and does not make use of any computational assumptions. However, in 2019, [12] proposed an attack on the PP-SP protocol of Lu et al. and showed that it is impossible to construct a PP-SP protocol without the use of computational hardness assumptions. These attacks are based on constructing distinguishers that leak additional information about the other party’s secrets than what the output should reveal. While the TRACE protocol is motivated by the designs of the PP-SP protocols of Lu et al., we would like to stress that the application context, i.e., privacy-preserving ride-hailing services, is diﬀerent in our setting, and hence the privacy requirements diﬀer too. The main goal of our attacks on the TRACE protocol is the complete recovery of secret locations rather than just distinguishing them from uniform random values, and hence the attack techniques are also diﬀerent. Note that the anonymity of users’ locations is the main requirement for a PP-RHS, and not just indistinguishability from uniform random values. Hence, the attack in [12] does not necessarily imply our results, though it certainly provides the motivation for a deeper investigation such as our work. RHS cannot be constructed without computational hardness assumptions. For instance, in Section 3.1, we showed that our modiﬁcation to the TRACE protocol, where fresh random values are used for each invocation, prevents RCs and RVs from obtaining the secret quadtree (this is based on an information-theoretic argument similar to that of a one-time pad). Hence, impossibility results for the PP-SP setting do not necessarily translate to the PP-RHS setting. In this work we proposed an attack on the privacy-preserving ride-hailing service TRACE. We disproved several privacy claims about TRACE in an honest-butcurious setting. We showed how riders (RCs) and drivers (RVs) can recover the EPRide by Yu et al. [18] uses an eﬃcient approach to compute the ex- Lu et al. [6] proposed a protocol for Privacy-Preserving Scalar Product (PP-−→ Also, the impossibility result of [12] does not necessarily imply that a PPsecret spatial division information maintained by the ride-hailing server (RS). We also showed how the RS can recover the exact locations of RCs and RVs. We implemented our attack and evaluated the success probability for diﬀerent security parameters. In the future, it would be interesting to propose a modiﬁed protocol for TRACE in which all the aforementioned privacy claims hold. Acknowledgements. This work was partially funded by the Infosys Foundation Career Development Chair Professorship grant for Srinivas Vivek.