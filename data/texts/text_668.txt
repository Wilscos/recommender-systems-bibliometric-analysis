<title>Monitoring Hybrid Process Speciﬁcations with Conﬂict Management: The Automata-theoretic Approach</title> <title>arXiv:2111.13136v1  [cs.AI]  25 Nov 2021</title> <title>1 Introduction</title> A key functionality of any process-aware information system is monitoring [9]. Monitoring concerns the ability to verify at runtime whether an ongoing process execution confo rms to the corresponding process model. This runtime form of conformance checking allows to detect, and therefo re handle, deviatio ns app earing in ongoing process instances. However, in several scenarios, diﬀerent process speciﬁcations must be valid during the process execution and the monitoring system should take into consideration all of them and their interplay. One such scenario would be the treatment of a patient having co-morbid conditions. In this case, the standard treatment procedures for each condition can be speciﬁed using procedural models , while additional knowledge, such as harmful drug interactio ns, can be speciﬁe d using declarative constraints [2]. Note that, the interplay o f proc ess speciﬁcations can generate conﬂicts during the process execution [2,18]. For example, by making a decision that, based on a procedural model, will lead to administering a drug that the patient is allergic to. To be able to take informed decisions in these situations, experts responsible for the exe cution of such process(es) need to be promptly alerted about the presence of conﬂicts. In this paper, we present a monitoring approach with respect to multiple pr ocess speciﬁcations, each of which may also include conditions o n the data pers pective. In particular, we use data Petri nets (DPNs) [13] for procedural models and Linear Temporal Logic over ﬁnite traces (LTL ) [7] for declarative models (additionally supporting the LTL based modeling language MP-Declare [17,3]). This allows us to capture sophisticated for ms of scoping and interaction among the diﬀerent process speciﬁcations (that is, the diﬀerent elicited DPNs and declarative constra ints), going beyond what is captured so far in the literature, and providing a full logic-based characterization of the so-resulting hybrid processes [2,18,19]. These models diﬀer from loosely coupled hybrid models [1], in that the diﬀer ent process speciﬁca tions all interact with each other at the same level o f abstraction. Of particular importance, in our mo nitoring approach, is the early detection of conﬂicts among process speciﬁcations, arising when the process is in a state where at least one speciﬁcation will eventually be violated. This aspect has been considered before with a purely declarative approach [11,12,14] but never applied to a hybrid setting. In our context, there are three main novel challenges that need to be addressed. First and fore most, we need to tackle the inﬁnity induced by the presence of data, which in general leads to undecidability of monitoring. In our spe ciﬁc setting, we show that we can recast data abstraction techniques studied for veriﬁcation of DPNs [4,5] so as to produce ﬁnitely representable monitors based on ﬁnite-state automata. Second, we need to homoge ne ously construct monitors for constraints and DPNs, and deﬁne how to combine them into a unique, global monitor for conﬂict detectio n; we do so by recasting the standard notion of automata product, producing a global monitor that conceptually captures a hybrid model where DPNs and constraints are all simultaneously applied (i.e. all DPNs are executed concurrently, while checking the validity of constraints). Third, we need to handle situations where the global monitor returns a permanent violation (due to the explicit violation of a process speciﬁcation, or the presence of a conﬂict), but distinguishing among diﬀer ent continuations is still relevant as they may lead to violate diﬀerent process speciﬁcations. Assuming a violation cost is given for each speciﬁcation, we show how to augment our monitors with the ability of returning the best-possible next events, that is, those keeping the overall violatio n cost at the minimum possible. The remainder of this pape r is structure d as follows. Section 2 provides an example monitoring scenario. Section 3 and Section 4 introduce the necessary preliminaries and the monitoring approach re spe ctively. Section 5 concludes the paper. <title>2 Example Scenario</title> Consider the following real-life scenario, where a patient w ith co-morbidities is simultaneously treated with diﬀerent guidelines: a guideline for peptic ulcer (PU) and a guideline for venous thromboembolism (VT). More spec iﬁcally, we are considering two tiny, yet relevant fragments of the guideline models presented in [18]. The two fragments a re represented in Fig. 1 using DPNs (recalled in Section 3). When PU starts, the helicobacter pylori test is executed. Based on the test result, diﬀerent therapies are chosen: amoxicillin administration in case of positive test, gas tric acidity reduction otherwise. Afterwards, the peptic ulcer is evaluated to estimate the e ﬀects of the therapy. VT requires an immediate intervention, chosen among three diﬀerent possibilities based on the situation of the speciﬁc patient at hand. Mechanical intervention uses dev ic es that prevent the proximal propagation or embolization of the thrombus into the pulmonary circulation, or involves the removal of the thrombus. The other two possibilities are an antic oagulant therapy based o n warfarin, or a thrombolytic therapy. The interaction between amoxicillin therapy (in the PU procedure) and warfarin therapy (in the VT pr ocedure) is us ually avoided in medical practice, sinc e amoxicillin increases the anticoagulant eﬀect of warfarin, raising the risk of bleedings. Therefore, in cases where the PU and VT procedures are performed simultaneously, the medical practice suggests specifying that amoxicillin therapy and warfarin therapy canno t coexist (declarative constraint C). Such a constraint C is an example of background medical knowledge rule [2]. Based on these speciﬁcations, if helicobacter pylori is tested positive and anticoaugulant is chosen to deal with venous thromboembolism, then there is a conﬂict betwe en C a nd the two guidelines. In this outlier, but p ossible situation there would be three alternatives: 1. Violating PU (by skipping the amoxicillin therapy); 2. Violating VT (by using an alternative anticoagulant); 3. Violating C (giving priority to the two guidelines). Informing medical experts about the presence of a conﬂict is crucial to help them in assessing the current situation, ponder the implications of one choice over the others, and ﬁnally make an informed decision. One can go beyond mere information, by also presenting the violation severity of the diﬀerent alternatives. This can be done by assigning violation costs to the process speciﬁcations (in our case, PU, VT, and C). In this case, we can assume that skipping the amoxicillin therapy is rather costly, given the lack o f viable alternatives for treating peptic ulcer in case of helic obacter pylori. Instead, violating the VT procedure has a lower cost, given the existence of other anticoagulants (e.g., heparin) that may be less eﬀective but do not interact strongly with amoxicillin. Additionally, constraint C comes with the highest violation cost as complications s uch as serious bleeding should deﬁnitely be avoided. In our approach, we can also deal with more so phis ticated (meta-)constraints [6] that impose conditions on the process execution depe nding on the truth value of other constraints. Within our example scenario, we can for example specify a meta-constraint dictacting that if co nstraint C gets violated, then at least we expect that warfarin therapy is exe cuted after amoxicillin therapy, to re duce the risk o f a har mful interaction of warfarin and amoxicillin. <title>3 Process Components</title> In this section, we deﬁne the models used to specify declarative and procedural data-aware process components, by relying on Multi Perspective-Declare (MPDeclare) [3,14,10]) and data Petri nets (DPNs [13,4]). We start by ﬁxing some preliminary notions related to events and traces. An event signature is a tuple hn, Ai, where: n is the activity name and A = {a , . . . , a } is the set o f event attribute (n ames). We assume a ﬁnite set E of event signatures, each having a distinct name (thus we can simply refer to an n we denote the set event signature hn, Ai using its name n). By N A the set of a ll attribute names of all event names from E and by A occurring in E. Each event comes with a name matching one of the names in N , and provides actual values for the attributes of the corresponding signatur e . In the context of this paper, attributes range over reals equipped with comparison predicates (simpler type s such as strings with equality and booleans can be s eamlessly encoded). Deﬁnition 1 (Event). An event of event signature hn, Ai is a pair e = hn, νi where ν : A 7→ R is a total function assigning a real value to each attribute in A. As usual, sequences of events form (process) traces . Deﬁnition 2. A trace over a set E of event signatures is a ﬁnite sequence σ = · · · e , where each e is an event of some signature in E. To represe nt declarative process components, we resort to a multi-perspective variant of the well-known Declare language [1 7]. A Declare model describes constraints that must be satisﬁed throughout the process exe cution. Constraints, in turn, are based on templates. Templates are patterns that deﬁne parameterized classes of pro perties, and constraints are their concrete instantiatio ns. The template se mantic s is formalized using Linear Temporal Logic over ﬁnite tra ces (LTL ) [15]. In this work, we cons ide r temporal constraints enriched with boolean combinations of attribute-to-constant comparisons. The resulting language closely resembles that of variable-to-constant conditions in [4], thus providing a good basis for combining declarative constraints with procedural models ex pressed with DPNs. Deﬁnition 3. A condition ϕ over a set E of event signatures is an expression of the form: ϕ := x | a ⊙ c | ¬ϕ | ϕ ∧ ϕ, where: x ∈ N ; a ∈ A ; ⊙ ∈ {<, =, >}; c ∈ R. Conditions of the form a ⊙ c and x are c alled atomic. We deﬁne the usual = ¬ϕ ∨ ϕ ; a ≤ c = ¬(a > c); = ¬(¬ϕ ∧ ¬ϕ ); ϕ → ϕ abbreviations: ϕ ∨ ϕ a ≥ c = ¬(a < c); and a 6= c = ¬(a = c). In addition, we denote by L the language of conditions over E. Conditions of L are interpreted ove r events as follows. Deﬁnition 4. We inductively deﬁne when a condition ϕ is satisﬁed by an event e = hn, νi, written e |= ϕ, as follows: We are now ready to deﬁne LMP-Declare constra ints, that is, MP-Declare constraints with local conditions. T he ir syntactic and semantic deﬁnition basically c orresponds to that of LTL formulae with conditions as atomic formulae, interpreted over traces of the form given in Deﬁnition 2. Deﬁnition 5. An LMP-Declare constraint is an expression of the form: where ϕ is a condition from L (cf. Deﬁnition 3). As in standard LTL , X denotes the strong next oper ator (which requires the existence of a next state where the inner formula holds), while U stands for strong until (which requires the right-hand formula to eventually hold, forcing the left-hand formula to hold in all intermediate states). Deﬁnition 6. We inductively deﬁne when an LMP-Declare constraint Φ is satisﬁed by a trace σ at position 1 ≤ i ≤ |σ|, writt en σ, i |= Φ, as follows: – σ, i |= ⊤; – σ, i |= ϕ iﬀ σ(i) |= ϕ according to Deﬁnition 4; = ¬Φ ∨Φ = ¬(¬Φ ∧¬Φ ); Φ → Φ We deﬁne the usual abbreviations: Φ ∨Φ F Φ = trueU Φ (eventually); and G Φ = ¬F ¬Φ (globally). captures that whenever event a occurs then b cannot later occur with its attribute z carrying a value greater than 10. We deﬁne data Petri nets (DPNs) by adjusting [13,4] to our needs. In particular, our deﬁnition needs to acco mmodate the fact that a monitored trace will be matched against multiple process co mpone nts (which will be the focus of Section 4). Let E be a ﬁnite set of event signatures. The language G of guards γ over E is deﬁned as follows: Observe that G is the sub-langua ge o f conditions over E, i.e., L , with formulas γ not mentioning e vent names. We can then specialize the notion of satisfaction to guar ds, by considering only the a ssignment to the event attributes. Namely, given an assignment α : A → R and an atomic condition a ⊙ c, we have that α |= a ⊙ c iﬀ α(a) ⊙ c. Boolean combinations of atomic conditions are deﬁned as usual. Given a condition γ, we denote by Var(γ) the set of attributes mentioned therein. We respectively call Var (t) and Var (t) the sets of t’s read and write variables, as a shortcut notation for Var(r(t)) and Var(w(t)). Given a pla c e or a transition x ∈ P ∪ T of D, the preset and the postset of x are, respectively, the sets x = {y | F (y, x) > 0} a nd x := {y | F (x, y) > 0}. Example 2. Figure 1 shows two DPNs encoding the two clinical guideline fragments discuss ed in Section 2. The two ﬁgures employ string co nstants, which can be easily encoded into dedicated r eal numbers to ﬁt our formal deﬁnition. We turn to the DPN execution semantics. A state of a DPN D = (P, T, F, l, V, r, w) over E is a pair (M, α), where: – M : P → N is a total marking function, assigning a number M (p) of tokens to every place p ∈ P ; – α : V → R is a total variable valuation (function) assigning a real value to every variable in V . Every state, together with a (varia ble) valuation β inducing an upda te over (some of) the net variables, yields a set of enabled transitions, which can be ﬁred to progre ss the net. This requires to augment the usual notions o f enablement/ﬁring by cons idering als o the read and write guards. Deﬁnition 8. Consider a DPN D = (P, T, F, l, V, r, w). Transition t ∈ T is enabled in state (M, α) under part ial valuation β : V 9 R, denoted (M, α)[t, βi, iﬀ: – β is deﬁned on all variables v ∈ Var (t) ∪ Var (t); – for every v ∈ Var (t), we have that β(v) = α(v), i.e., β matches α on t’s read variables and; – β |= r(t) and β |= w(t), i.e., β satisﬁes the read and write guards of t; and – for every p ∈ t, it is the case that M (p) ≥ F (p, t). Given a transition t enabled in state (M, α) under β, a state (M , α ) is the result of ﬁring t in (M, α), written (M, α)[t, βi(M , α ), iﬀ: – for every p ∈ P , we have M (p) = M (p) − F(p, t) + F (t, p); and – for every v ∈ Var (t), we have α (v) = β(v). – for every v ∈ V \ Var (t), we have α (v) = α(v). We refer to the expression (M, α)[t, βi(M , α ) as transition ﬁring. State (M , α is reachable fro m (M, α), if there exists a sequence of transition ﬁrings from (M, α) to (M , α ). In this paper, we deal only with DPNs that are safe (i.e., 1-bounded) and well-formed (over their respective set of event signatures E). The former means that for eve ry state (M , α ) re achable from a state (M, α), if M(p) ≤ 1 then (p) ≤ 1. This is done for convenience (our approach seamlessly works for k-bounded nets). The latter means that transitions and event s ignatures are compatible, in the following sense: (i) for every (visible) transition t ∈ T with l(t) = n for some event signature hn, Ai ∈ E, we have that the write guard uses, as var iables, precisely those matching with attributes in A, that is, Var (t) = A; (ii) fo r every (silent) transition t ∈ T with l(t) = τ, net variables are left untouched, that is, w(t) ≡ ⊤. The ﬁrst requirement captures the intuition that the payload of an event is us e d to update the net variables, provided that the corres ponding write guard is satisﬁe d. The second requirement indicates that variables are o nly manipulated when a visible transition, triggered by an event, ﬁres. To deﬁne runs, we ﬁx a D PN with initial state and ﬁnal marking (DPNIF) as a pair D = (D, (M , α ), M ), where D is a DPN, (M , α ) a state of D (ca lled initial st at e), and M a marking of D (called ﬁnal marking). A run of D is a sequence of transition ﬁrings of D that starts from (M , α ) and ﬁnally leads to a state (M, α) with M = M We are now ready to deﬁne when a trace (in the sense of Def. 2) complies with a DPNIF. This captures that the events contained in the trace can be turned into a corresponding run, possibly inserting τ-transitions, while keeping the rela tive order of events and their correspondence to elements in the run. To do so, we need a preliminary notion. Given two sequences σ and σ such that | σ | ≥ |σ |, an or der-preserving injection ι from σ to σ is a total injective function from the elements of σ to those of σ , such that for every two elements , e in σ where e comes later than e in the σ , we have that ι(e ) comes later than ι(e ) in σ . This notion allow us to eas ily map traces into (possibly longer) runs of a DPNIF. Deﬁnition 9. A trace σ = e · · · e , complies with a DPNIF D with labeling function l if there exist a run ρ of D and an order-preserving injection ι from σ to ρ such that: – every e = hn, νi in σ is mapped by ι onto a corresponding transition ﬁring in ρ, that is, given ι(e) = [t, βi, we have that l(t) = n and β corresponds to ν for the written variables Var (t); – every element [t, βi in ρ that does not correspond to any element from σ via ι is so that l(t) = τ. <title>4 Monitoring Approach</title> In this section we provide our main technical contribution: the construction of monitors for hybrid proc esses. In our context, a hybrid process H over a set E of event signatures is simply a set of process components, where each process component is either a LMP-Declare co nstraint over E, or a DPNIF over E. Monitoring a trace against H basically amounts to running this trace concurrently over all the DPNIFs o f H, simultaneously checking whether all constraints in H are satisﬁed. When the tr ace is completed, it is additionally checked that the trace is indeed a c cepted by the DPNIFs. One important c lariﬁcation is needed when characterizing the concurrent execution over multiple DPNIFs. In fact, such components may come fr om diﬀerent sources, not necessarily employing all the event signatures from E. In this light, it would be counterintuitive to set that a DPNIF rejects an event because its signature is no t at all used therein. We ﬁx this by assuming that whenever such a situation happens, the DPNIF simply ignores the currently processed event. Given this basis, the co nstruction of monitors for such hybrid processes goes through multiple conceptual and algorithmic steps, de tailed next. The ﬁrst challenge that one has to overcome is related to reasoning with data conditions, that is, checking whether a condition is satisﬁed by an assignment, and checking whether a condition is satisﬁable (both operations will be instrumental when constructing automata). The main issue is that, due to the presence of data, there are inﬁnitely many distinct assignments from variables/ attributes to values, in turn inducing inﬁnitely ma ny states to co nsider in the DPNs (even when the net is bounded). To tame this inﬁnity, we build on the faithful abstraction techniques studied in [4], recasting them in our more complex setting. The idea is to avoid referring to single re al values, and instead predicate over intervals, in turn showing that we only have a ﬁxed number of intervals to consider, which in turn leads us to pro positional reasoning. This is obtained by observing that data co nditio ns can distinguish between only those co nstants that are explicitly mentioned therein; hence, we simply fetch constants used in the process components (i.e., some atomic condition, guard or initial DP N assignment) to delimit the intervals to consider. Technically, let C = {c , . . . , c } be a ﬁnite set of values fr om R assuming, without loss of generality, that c < c , for i ∈ {1, . . . , m−1}. We then partition R into P = {(−∞, c ), (c , ∞)} ∪ {(c , c ) | i = 1, . . . , m} ∪ {(c , c ) | i ∈ {1, . . . , m − 1}}. Notice that P is ﬁnite, with a size that is linear in m. This is crucial for our techniques: we can see P as a set of intervals over the reals or simply as a ﬁxed set of propositions, depending on our needs . Each interval in the partition is an equivalence region for the satisfaction of the atomic conditions a ⊙ c in L , in the following sense: given two va luations α and α deﬁned over a, such that α(a) and α (a) are from the same region R ∈ P , then α |= v ⊙ c if and only if α |= v ⊙ c. We exploit this as follows. We ﬁx a ﬁnite set V of variables (referring to attributes) and lift an assignment α : V → R into a corresponding r e gion assignment ˜α : V → P so that, for e very a ∈ V , ˜α(a) returns the unique interval to which α(a) belongs. Given the observation above, we can then use ˜α to check whether a condition holds over α or not as follows: α(a) s atisﬁes condition a > c with c ∈ C if and only if ˜α(a) returns a region (c , c ) with c > c (the same rea soning is similarly done for other comparison operators). This carries over more complex conditions used in LMP-Declare and DPNs, as they simply consist of boo lean combinations of atomic conditions. The key observation here is that doing this check amounts to propos itional reasoning, and so does checking satisﬁability of conditions: in fact, since both V and P are ﬁnite, there are only ﬁnitely many region assignments that can be deﬁned from V to P Given the process components of interest, we ﬁx V to the set A of all the attributes in the event signature E of the system under study (this contains all variables used in its proces s components), and C to the set of all constants used in the initial states of the DPNs, or mentioned in some condition of a process component. We then c onsistently apply the lifting strategy from assignments to region assignments, when it comes to traces and DPN states. In the remainder, we assume that V and C are ﬁxed as described above. As a unifying device to captur e the execution semantics of process comp onents, we introduce a symbolic automaton whose tr ansitions are decorated with data conditions. Deﬁnition 10. A guarded ﬁnite-state automaton (GFA) over set E of event signatures is a tuple A = hQ, q , →, F i, where: (i) Q is a ﬁnite set of states; (ii) q ∈ Q is the initial state; (iii) −→ ⊆ Q × L × Q is the labeled transition function; and (iv) F ⊆ Q is the set of ﬁnal states. For notational convenience, we write q −→ q for hq, ϕ, q i ∈ −→, and call ϕ (transition) guard. −→ · · · GFA-runs of A consist of ﬁnite sequence s of the form q −→ q , where ∈ F . The set of runs accepted by A is denoted as L . A trace σ = e · · · e −→ · · · over E is accepted by A if there exists a GFA-run q −→ q such that for i ∈ {1, . . . , m}, we have e |= ϕ . In general, an event e can satisfy the g uards of many transitions outgoing from a state q, as guards are not required to be mutua lly exclusive. Thus, a trace may correspond to many GFA-runs. In this sense, GFAs are, in general, nondeterministic. It is key to observe that GFAs can behave like standard ﬁnite-state automata. In fact, by setting C to a ﬁnite set of constants including all those mentioned in the auto mata guards, we can apply the interval abstraction from Section 4.1 to handle automata operations. In particular, in place of considering the inﬁnitely many events over E, we c an work over the ﬁnitely many abstract events deﬁned using region assignments ove r P . For example, we can check whether a trace σ = hn , ν i · · · hn , ν i is accepted by A by checking whether the abstract trace hn , ˜ν i · · · hn , ˜ν i does so. Notice that, to construct this abstract trace, it suﬃces to represent each event hn, νi in σ using equivalence regions from P such that every ν(a) = c is substituted either with region [ c, c], if [c, c] ∈ P to or with region (c , c ) s.t. c ∈ (c , c ). For ease of reference, we s hall use σ represent the abstract trace. Thanks to this, we can construct GFAs using standard automata techniques (e.g., for LTL , as discussed below), and also directly apply standard algorithms, coupled with our interval abstraction, to minimize and determinize GFAs. From LMP-Declare constraints to GFAs. The tra nslation of an LTL formula into a corresponding ﬁnite-state automaton [7,6] has been largely employed in the literature to build execution engines and monitors for Declar e. In the cas e of Declare, atomic formulae are simply names of activities, and consequently automata come with transitions labele d by pr op ositions that refer to such names. In the case of LMP-Declare, atomic formulae a re more complex conditions from L . Thanks to interval abstraction, this is however not an issue: we simply apply the standard ﬁnite-state automata construction for a Declare constraint [6], with the only diﬀerence that transitions are labeled by those conditions from mentioned within the constraint. We only keep those transitions whose label is a satisﬁable condition, which as discussed in Section 4.1 can be checked with propositiona l reasoning. A ﬁnal, important observation is that the so-constructed GFA is kept complete (that is, untrimmed), so that each of its states can process every event from E. From DPNIFs to GFAs. We show that a DPNIF D = (D, (M , α ), M ) can be encoded into a corresponding GFA that accepts all and only those traces that comply with D. For space reasons, we concentrate here on the most important aspects. The main issue is that the set S of DPN states that are reachable from the initial marking (M , α ) is in ge ne ral inﬁnite eve n when the net is bounded (i.e., has boundedly many markings). This is due to the existence of inﬁnitely many va luations for the net variables . To tame this inﬁnity, we consider again the partition P deﬁned above; this induce s a partitio n of S into equiva lence classes, according to the intervals assigned to the variables of D. Technically, given two assignments α, α we say that α is equivalent to α , written α ∼ α iﬀ for every v ∈ V there exists a region R ∈ P s.t. α(v), α (v) ∈ R. Then, two states (M, α), (M , α ) ∈ S are said to be equivalent, written (M, α) ∼ (M , α iﬀ M = M and α ∼ α . Observe that, by what discusse d above, the assignments of two equivalent sta tes satisfy ex actly the same net guards. By [S] , we denote the quotient set of S induced by the equivalence relation ∼ over states deﬁned above. Based o n Section 4.1 we directly get that [S] is ﬁnite. We can then c onveniently represent each equivalence class of [S] by (M, ˜α), explic itly using the region assignment in place of the inﬁnitely many corresponding value-based ones. This provides the basis for the following encoding. Next we intr oduce an algorithm that, given a DPNIF D = (D, (M , α ), M ), constructs the GFA A corres ponding to it (that is, it represents all possible behaviors o f D). In the algorithm, we make use of the following functions: • enabled(M, ˜α) returns a set of transitions and region ass ignments {(t, β) | t ∈ T and (M, α)[t, βi, where β(v) ∈ β(v), α(v) ∈ ˜α(v), for v ∈ V }. Notice that β matches only the “allowed” regions. That is, for every t, we need to construct multiple β that account for all possible combinations of equivalence regions assigned to each variable in w(t) and r(t) such that β |= w(t) and β |= r(t). • guard(t, ˜α) returns a formula ψ as in Deﬁnition 3c. • fire(M, t, β) returns a pair (M, ˜α) as in Deﬁnition 3. It is easy to see that all the aforementioned functions are computable. For enabled there are always going to b e ﬁnitely many combinations of regions from satisfying the guards of t, where as formulas produced by guard can be constructed using a version of the respective procedure from Deﬁnition 11 that uses β instead of ˜α , and next states returned by fire can be generated via the usual new state generatio n procedure from Deﬁnition 8, proviso that it has to be invoked in the context of equivalence regions. The actual algorithm is similar to the classical one used for the reachability graph constr uction of a Petri net (see, e.g., [16]). It is important to notice that, in the proposed algorithm, silent transitions are treated as re gular ǫ-transitions (that is, we assume that L as well as −→ of the output automaton are suitably extended with τ). We discuss later on how such transitions can be eliminated from resulting GFAs. The following theorem outlines the main properties of the presented alg orithm. Theorem 1. Algorithm 1 eﬀectively computes a GFA A induced by a DPNIF D, is sound and terminates. However, Algorithm 1 is no t guaranteed to produce GFAs that are c omplete. To ensure the completeness of the algo rithm output, three additional modiﬁcations have to b e performed. (M1) Given that the so-obtained GFA A does not properly handle silent, τ-transitions (they are simply treated as normal ones by the algorithm), we need to c ompile them away from A , which is done by recasting the standard ǫ-move removal procedure for ﬁnite-state automata based on ǫclosures (se e, e.g., [8]) into our se tting. This procedure allows to collapse (sequences of) states corresponding to τ- transitions into those that are used for representing only behaviors of all possible traces complying to E. To collapse the afo rementioned sequences, each state q ∈ Q s.t. there are k runs −→ q −→ · · · −→ q , where every transition is labeled only with τ, q ϕ 6= τ and i = 1, . . . , k, has to be replaced with the set of all such q states by creating additional transitions to predecessors of q (if any) as well as q . Notice also that, while the ǫ-transition removal procedure produces deterministic automata, its counterpart working with GFAs may produce a n automaton that is non-deterministic. (M2) The output GFA has to be made “tolerant” to events whose signature is not at all used in the DPNIF, formalising the intuition described a t the beginning of Section 4. This is done by introducing additiona l loops in → (M, ˜α) −→ (M, ˜α) to → , where ψ is as in Deﬁnition 11 (see 3). This is only done when ψ is actually satisﬁable. – The second one addresses write-rela ted issues arising w hen the event to be pr ocessed carries values that violate all the write guards of candidate transitions. We handle this as follows: for every (M, ˜α) ∈ Q and every t ∈ T s.t. w(t) 6≡ ⊤, add (M, ˜α) −→ (M, ˜α) to → , where, for t ∈ T and every p ∈ t s.t. M (p) ≥ F (p, t), a = l(t) and ψ is constructed as in Deﬁnition 11 (bullet 3, with the only diﬀerence that all ϕ are computed for a combination of equivalence regions from P , each of which is composed into (partial) variable region valuation β : V → P s.t. β 6|= v ⊙ c, for every atomic condition v ⊙ c in w(t). This is only done if ψ is actually satisﬁable. This step can be also optimised by putting all such ψ in one DNF formula, which in turn reduces the number of transitions in the GFA. Propositi on 1. Let A be a GFA induced by a DPNIF D. A pplication of modiﬁcations (M1), (M2) and (M3) to A produces a new GFA A that is complete. Now, whenever we get a complete GFA for a DPNIF, we can use the former to check whether a log trace is compliant with the net (as by Deﬁnition 9). Theorem 2. A trace σ = e · · · e is compliant with a DPNIF D = is accepted by the GFA A induced (D, (M , α ), M ) iﬀ abstract trace σ by D. Given a hybrid process H = {h , . . . , h } with n components, we now know how to compute a GFA for each of its components. Let A be the GFA obtained as described in Section 4.2, depending on whether h is a LMP-Declare constraint or DPNIF, and in a dditio n minimized and determinized. This means that, being complete, it will have a single trap s tate capturing all those traces that permanently violate the process component. hq , . . . , q i; (iii) −→ is s.t. hq , . . . , q −→ hq , . . . , q i iﬀ ϕ = ϕ ∧ · · · ∧ ϕ −→ and ϕ is satisﬁable by ex actly one event; (iv) F = F × · · · × F with q Observe that the deﬁnition requires checking whether guards of A are satisﬁable by some event (otherwise the labeled transition could not be triggered by any event and should be omitted). The v labeling functions from above induce a labeling on the states q = hq , . . . , q i ∈ Q of the product a utomaton, which tells us whe ther a ll cons traints and nets nets from Φ are overall temporarily/p ermanently violated/satisﬁed. Spec iﬁc ally, we deﬁne the labeling v : Q 7→ {T S, T V, P S, P V } s.t.: (i) v(q) = P V iﬀ v (q ) = P V , for some i ∈ 1, . . . , n; ( ii) v(q) = P S iﬀ v (q ) = P S, for all i ∈ 1, . . . , n; (iii) v(q) = T S iﬀ v (q ) = T S, for all i ∈ 1, . . . , n; (iv) v(q) = T V , otherwise. It is crucial to notice that, diﬀerently from local GFAs, the global GFA A is not minimized. This allows the monitor to distinguish among states of pe rmanent violations arising from diﬀerent combinations of permanently violated components, in turn allowing for ﬁne-grained feedback o n what are the “best” events that could be processe d next. To substantiate this, we pair a hy brid process H with a violation cost fu nction that, for each of its components, returns a natural number indicating the cost incur red for violating that component. A is aug mented as follows. Each state q ∈ Q of A is associated with two cost indicators: cost(q ), cost (q) = cost (q) = ˆq = argmin {cost (q)}. If, for some i, ˆq = q , then ˆq is the best achievable state and no event c an further improve the cost. Other wise, take a successor q of ˆq s.t. cost (q ) = cost (ˆq). Notice that by the deﬁnition of cost , one such q necessarily exists, otherwise ˆq would have a diﬀerent cost cost (ˆq). The best events are then the events e s.t.: Notice that, to process the trace in the global GFA A, and to detect the best events, we again move back and forth from traces/ events and their abstract representation based on intervals, as discussed in Section 4.1. In particular, notice that there may be inﬁnitely many diﬀerent best events, obtained by diﬀerent groundings of the attr ibutes within the same intervals. <title>5 Conclusion</title> The ability to monitor the interplay of diﬀerent process models is useful in domains where process instanc e s tend to have high variability. An example of this is the medical domain where standard treatment procedures are described as clinical guidelines and multiple guidelines need to be often executed simultaneously, therefore giving rise to interplay and possible conﬂicts. Furthermore, because a clinical guideline cannot account for all possible preconditions that a patient may have, it is also necessary to employ declarative knowledge (allergies, prior conditions etc.) which further complicates the process execution. This paper pr oposes a monitoring approach that can take into consideration the interplay of multiple process speciﬁcations (both pro c edural and declarative). Additionally, the approach includes a recommendation component which helps either to avoid vio lations or (if avoiding the violations is not pos sible) to minimize the total cost of the violations. The propose d approach is limited in that it can only provide recommendatio ns on the immediate next events, however in the future we plan to extend the appr oach to provide recommendations as full continuations of the trace and to explore diﬀerent possible execution semantics for concurrent execution of multiple process models. Acknowledgements. The work of A. Alman was supported by the Estonian Research Council (project PRG1226) and ERDF via the IT Academy Program. <title>References</title>