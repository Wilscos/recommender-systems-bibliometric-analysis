<title>A Review of SHACL: From Data Validation to Schema Reasoning for RDF Graphs</title> <title>1 Introduction</title> <title>arXiv:2112.01441v1  [cs.AI]  2 Dec 2021</title> interoperability. A set of constraints can also be interpreted as a “schema” , functioning as one of the primary descriptors of a graph dataset, thus enhancing its understandability and usability. A set of shacl shapes is called a shapes graph, but we refer to it as a shacl document in order not to confuse it with the gra phs that it is used to validate. In this article we present a review of shacl, which is composed of three main parts. In the ﬁrst part, in Sections 2 and 3, we review the shacl speciﬁcation. This part focuses on how shapes are deﬁned, and how they ar e used for the purp ose of validation. We highlight the main peculiarities of this language, a nd discuss how shacl validation can be expressed either in terms of sparql queries, to facilitate its implementation, or in ter ms of assignments [13], to make it amenable to theoretical study. The syntax of shacl is outside the scope of this review, and for the precise deta ils on how to encode particular constraints we refer the reader to the shacl speciﬁcation [23]. We also do not discuss the process that lead to the development of shacl, but it s hould be noted that this sp eciﬁcation was built on top of a number of previous constraint languages, the most inﬂuential of which is Shape Expressions (ShEx) [48]. In the second part of our review, in Sections 5 to 8, we present the formal properties of this language. This mainly revolves around a discussio n of recursion. The sema ntics of recursion is not deﬁned in the shacl speciﬁcation, and thus has been the subject of signiﬁcant subsequent research [3]. The formal semantics of shacl is given as a translation into SCL [37], a ﬁrst order logic language that captures the entirety of the shacl speciﬁcation. Apart from validation, several standard dec ision problems are discussed, such as satisﬁability and containment, along with an ex isting study on the interaction of shacl with infere nce rules. We try to keep a consistent notation throughout this article and at times this notation might be diﬀerent from the one in the original a rticles. In Section 9, we review e xisting implementa tions of shacl validators and their integration with mainstream gr aph databases . We also review prominent additional tools to manage shacl documents, such as tools designed to automate or semi-auto mate the process of creating shacl documents by exploiting graph data, ontologies, or other co nstraint languages. These approaches provide solutions to the cold start problem, and alleviate reliance on expert knowledge, which a re typical problems of new technologies. We complement a discussion of these approaches with a review of prominent applications of shacl in several domains; in summary, the abundance of shacl r elated tools and applications highlights the remarkable level of maturity and ado ptio n reached by this relatively new language. <title>2 Preliminaries</title> Before discussing shacl, we brieﬂy introduce our notation for rdf g raphs [14]. With the term rdf graph (or just graph) we refer to a set of rdf triples (or just triples), where each triple <s, p, o> identiﬁes an edge with label p, called predicate, from a node s, called subject, to a node o, called object. Subjects, predicates and objects of rdf triples are collectively called rdf terms. The rdf terms that appea r as subject and objects in the triples of a graph are called the nodes of the graph. Graphs in this article are represented in Turtle syntax using common XML namespaces, such as sh, rdf and rdfs to refer to, respectively, the shacl, rdf, and rdfs [7] vocabularies. Queries over rdf graph will be expres sed as sparql [42 ] queries. In the rdf data model, subjects, predicates and objects are deﬁned over diﬀerent but ove rlapping do mains. Fo r example, while rdf terms of the iri type can occupy any position in a triple, rdf terms of the literal type (represe nting datatype values) can only appear in the object position. These diﬀerences are not central to the topics discussed in this review, and thus, fo r the sake of simplifying notation, we will a ssume that all elements of a triple are drawn from a single and inﬁnite domain of constants. This corresponds to the notio n of generalized rdf [14]. <title>3 Overview of shacl</title> The main application of shacl is data validation. Data validation in shacl requires two inputs: (1) an rdf graph G to be validated and (2) a shacl document M that deﬁnes the conditions against which G must be eva luated. The shacl speciﬁcation deﬁnes the output of the data validation process as a validation report, detailing all the violations that were found in G of the conditions set by M . If the violation report contains no violations, a graph G is valid w.r.t. shacl document M . The shacl validation pr ocess ca n be abstracted into the following decision problem. Given a graph G and a shacl document M , we denote with Validate(G, M) the decision problem of deciding whether G is valid w.r.t. shacl document M , that we call validating G aga ins t M. For example, the g raph on the left of Figure 1 r epresents a shacl document , that deﬁnes the condition that every employee must have an oﬃce number . Therefore, the valida tion re port for a graph and M would list all o f the instances of :Employee in the graph that do not have an oﬃce number. The validation report for M and the data gr aph G on the right of Figure 1 contains a violation on node rdf:Anne, since she does no t have an oﬃce number. Therefore G is not valid w.r.t. M Formally, a shacl document is a set of shapes. Validating a gra ph against a shacl document involves validating it against each shape. Shapes restrict the structure of a valid gra ph by focusing on certain nodes a nd examining whether they satisfy their constraints. The main components of a shape are a constraint d and a target deﬁnition t. Constraints can be evaluated on any rdf node to determine whether that node satisﬁes o r not the given constraints. A node that satisﬁes the constraint of a shap e it is said to conform to that shape, or notconform otherwise. If a shape has an empty constraint, all nodes trivially conform to the shape. Not all nodes of a graph must conform to all the shapes in the shacl document. The constraint deﬁnition of each shape deﬁnes which rdf nodes, called target nodes, must conform to that shape in order for the graph to be valid. A sha pe with an empty constraint deﬁnition does not have any target nodes. Through inter-shape referencing, as we will see below, additional nodes might be required to conform to cer tain shapes (or not, if negation is used) for the validation to succeed. Further irrelevant nodes within the graph do not play a role in validation of the shape, whether they conform to it or not. The shacl document M of our previous example, contains shape :EmployeeShape, whose constraint captures the property of “having an oﬃce number” , and whose targe t deﬁnition targets only the rdf nodes of type Employee. Nodes of the Client type do not generate vio lations by not having an o ﬃce number. Formally, a shape is a tuple hs, t, di deﬁned by three components: (1) the shape name s, which uniquely identiﬁes the shape; (2) the target deﬁnition t, and (3) the set of constraints which are used in conjunction, and hence hereafter referred to as the single constraint d. As demonstrated in Figure 1, a shacl document is itself an rdf graph. The graph representing a shacl document is called a shapes graph, while the graph being validated is called a data graph. This approach to serialisa tion is similar to how OWL ontologies are s e rialised, and it serves a similar purpose. Thanks to this approach, a shacl document does not require any dedicated infrastructure to be stored and shared. In fact, a shacl document can b e embedded directly into the very graph it validates , thus combining the shape graph and data gra ph into a single graph. Interestingly, with this s erialisation, a shapes graph, being an rdf graph, can be itself subject to validation. The shacl speciﬁcation, in fact, deﬁnes a shapes graph that can be used to validate shapes graphs. We will now look in more details at the two major co mponents of shapes, namely target deﬁnitions and constraints. A shacl target deﬁnition, within a constraint, is a set of target declarations. There are four types of target declarations deﬁned in shacl, each one taking an rdf term c as a parameter. Node Targets A node target declaration o n c targets that speciﬁc node. Class-based Targets If a shape has a class-based target on c, then all the nodes in the graph that are of type (rdf:type) c are target nodes for that shape. Subjects-of Targets If a shape has a subject-of target on c, then the target nodes for that shape are all the nodes in the gr aph that app ear as subjects in triples with c as the predicate. Objects-of Targets If a shape has a n object-of target on c, then the targ et nodes for that s hap e are all the nodes in the gra ph that appear as objects in triples with c as the predicate. The s hap e deﬁned in Figure 1 demonstrates an example of a class- based target ta rgeting cla ss :Employee. Similarly, to target a subject of a property, e.g ., :worksAt, the second line of the shap e deﬁnition would be substituted with: sh:targetSubjectOf :worksAt. Typically, a targe t declaration is used to select, among all the nodes in a graph, the ones to target for constraint validation. The node target declaration, however, behaves diﬀerently, as it targets a particular node regardless of whether this node occurs in the graph or not. An important implica tion of this is that empty g raphs are not trivially valid, since node targets ca n detect violations on nodes external to the graph. If a target deﬁnition of a shape is empty, then that shape will have no target no des. However, this does not mean that the constraint of that shape will not be evaluated on any nodes since, as mentioned, other shapes can refer to it and “pass it” a node to check for conformance. When a ta rget or another node is considered against a sha pe for conformity, we call it a focus node. Initially a shape focuses on its target nodes (these are the initial se t of focus nodes). Additional focus nodes are obtained by following shacl property paths, which we also refer to as just paths. shacl property paths are a subset of sparql property paths and, as the name suggests, deﬁne paths in the rdf graph. The simplest type of path, called pr e dicate path, corresponds to a single pro perty IRI c. This path identiﬁes all the nodes that are reachable in the rdf graph from the current focus node by following a single edge c. In other words, this path identiﬁes all the rdf nodes in the object position of triples that have c as the predicate and the curr e nt focus node as the subject. More complex paths can be constructed by inverting the direction of a path, by concatenating two diﬀerent paths one after the other, or by allowing the rep etition of a path for a minimum, maximum or arbitr ary number of times. Based on the use of property paths, shacl sp eciﬁcation distinguishes shapes into two types: node shapes and property shapes. Intuitively, the constraint of a node shap e is evaluated directly on the focus nodes of the shape. Instead, when using a property path, shap es must b e declared as a property shapes. These are characterised by a path, and their constraints are evaluated over all of the nodes that can be reached from the focus nodes following such path. For example, the constraint that every employee’s password must be at least 8 characters long can be represented by a property shape that targets employee nodes, and that has a rela tion such as :hasPassword as its path. In this way, the actual nodes that must satisfy the “at least 8 characters long” constraint are not the target nodes, but instead those that appear as objects in triples with an employee node as a subject, and :hasPassword as the predicate. The majority of the shacl r ecommendation is dedicated to deﬁning the diﬀerent types of constraint components that can be used in shacl constraints. The main type of co ns traint components are called core constraint componen ts. These are the components that shacl compliant systems typically support, and where most of the existing literature foc us es on. The other main type of components are the sparql-based constraint components, that are used to embed sparql queries into shacl cons traints. This signiﬁcantly increases the express ive power of such constraints. However, the inclusion of arbitrarily complex sparql queries can lead to performance issues, and can make such constraints harder to understand and use. It is also worth noting that, outside of the shacl recommendation, a number of additional shacl feature s are currently b eing designed, and some of them might be included in further versions of shacl. In the rest of this paper we will focus on core constraint components. In order to better unders tand shacl c ore constraint components, we propose a broad categorisation of these components into three main ca tegories, depending on how they are e valuated on the focus nodes. Notice that most constraint components can be used in both node shapes and property s hap es. Graph Structure Components. These components deﬁne cons traints that are evaluated at the level of triples of the graph, and focus on restrictions such as the minimum and maximum cardinality that the focus node must have for certain paths, or the rdf class that the focus node should be a type of. The shape deﬁned in Figure 1 demonstrates an example of a minimum cardinality constraint for predicate path :hasOfficeNumber. Two other salient constraints in this category are the property pair equality and disjointedness, that specify whether the two sets of nodes reachable from two diﬀerent paths must be equal or disjoint, respectively. Filter Components. These components deﬁne constraints that are evaluated at the level of nodes, and their evaluation is usually independent from the triples present in the graph. Filter constraints restrict the focus node (1) to be a particular rdf term, (2) to be of a particular type, such as IRI, blank node or literal, or (3) to b e a literal that satisﬁes certain properties, such as being of the integer datatype, or a string produced by a ce rtain regular expression. Logical Components. Logical components deﬁne the standard logical operators of conjunction, disjunction and negation over other constraints. While most core constraint components fall into one of these categories, the pair of constraints sh:lessThan and sh:lessThanOrEquals is a notable exception, as it is combines the properties of graph structure and ﬁlter components. T hese two constraints require all the nodes reachable by one path to be literals that are less than (resp. less than or equals) to the nodes reachable by a second path. It is worth noting that all constraints but one, namely sh:closed, are not aﬀected by triples w ith unknown predicates (i.e. predicates not occurring in the shacl doc ument). This means that if a graph is valid with respect to a set of those constraints, it would still remain valid if new triples with unknown predicates are added to the graph. Thus, given a non-empty graph G, valid w.r.t. a SHACL document M , graph G ∪ <s, p, o> is also valid w.r.t. M if (1) p does not oc cur in M and (2) M does not contain the sh:closed constraint component. Deﬁnition 1. A shape hs, t, di is recursive if s ∈ S ; else it is non-recursive. Deﬁnition 2. A shacl document M is recursive if it contains a recursive shape, and non-recursive otherwise. The se mantics of recur sive shacl documents are not deﬁned in the shacl speciﬁcation. In Section 4 we re view the oﬃcial semantics of non-recursive shacl documents, while in Section 5 we review the extended semantics for recursive shacl document that have been proposed in the literature. <title>4 shacl Validation</title> In this section we present the semantics of shacl data validation, that is, the Validate(G, M) decision problem, for any given g raph G and shacl document M. In Section 4.1 we review how validation is deﬁned in the shacl speciﬁcation, with the help o f sparql queries. While this query-ba sed description of shacl semantics can be easily translated into a concrete implementation, it does not lend itself well to theoretical investigation. In Sec tion 4.2 we will discuss an alternative approach to deﬁning shacl semantics that is instead amenable to a formal study. The validation of an rdf graph G against a shacl document M can be performed on a s hap e-by-shape basis. For each shap e hs, t, di, this process involves verifying the fact that every node n, targeted by target deﬁnition t, satisﬁes constraint d. Intuitively, graph G is valid w.r.t. M if and only if this fact is true for every shape in M . Given a graph G and a target deﬁnition t, the set of target nodes for t can be computed by evaluating a sparql query on G for each target declaration in t, and taking the union of the values returned by these queries. Table 1 details the corre sponding sparql quer y for each o f the four types of target declarations deﬁned in shacl. It should be noted that, by default, shacl does not enforce any particular entailment regime. If an entailment regime is b e ing adopted, then this should be taken into account when developing a shacl validator. Fo r example, if the rdfs entailment regime [7] is being considered, subclass inference should be accounted for when computing the set of entities of a g iven class. To accommodate for this entailment regime, the query for the node target in Table 1 could be updated to the following one. Once an rdf term has been identiﬁed as being in the target of a shape, evaluating whether it conforms to the shape can be done using sparql queries. In the shacl speciﬁcation, in fact, several core constraint components are deﬁned with re spe c t to sparql quer ies. Most notably, the semantics of shacl ﬁlter components is in direct dep e ndence to the semantics of sparql ﬁlter functions. For example, the sh:minLength c onstraint component restricts a focus node to having a string length equal or large r than a given number. Formally, a focus node n has a sh:minLength of j if and only if the following sparql query evaluates to true. Not all shacl constraints, however, c an be easily veriﬁed by a single sparql query. Evaluating whether a constraint that contains shape reference s is satisﬁed by a focus node, in fact, might invo lve e valuating whether other constraints are satisﬁed by other nodes which, in turn, might require even further constraint evaluations. For ex ample, in order to eva luate whether node rdf:Carl fro m the data graph in Figure 1 conforms to shape rdf:EmployeeShapeB from Figure 2, we would need to evaluate whether his oﬃce number, namely rdf term “17 1”, conforms to shape rdf:OfficeNumberShape. This is especially problematic in case of recursion, a s it could generate an inﬁnite ser ie s of constraint evaluations. For non-recurs ive shacl documents, Corman et al. [12] showed that it is always possible to check the validity of a graph using a single sparql query. For example, a graph can be checked against the shacl document of Figure 2 by evaluating the following sparql query. This query sele c ts all rdf nodes of type Employee that do not have an oﬃce number with at least three characters. Thus, any rdf term returned by this query is a node violating a shape of the shacl document. If this query evalua tes to an empty set, then the graph that it is evaluated o n is valid with respect to the shacl document. The sparql-based approach to shacl validation does not provide a concise and formal description of shacl semantics. Moreover, it does not provide us with a terminating procedure to check graphs in the face of shacl recursion. In this section we review the concept of shape assignments (or just assignments) [13], which can be used to address the above mentioned problems. As deﬁned in Table 1, a target declaration t is a unary query over a graph G. We denote with G |= t(n) that a node n is in the t arget of t with respect to a graph G. If t is empty, no node in any graph is in the target of t. The deﬁnition of whether a node conforms to a s hap e , as we previously discussed, does not only depend on the graph G, but it might also dep end, due to shape r e ferences, on whether other nodes conform to other shapes. Intuitively, the concept o f assignments [13] is used to keep track, for every rdf node, of all the shapes that it conforms to, and all of those that it does not. Given a document M and a graph G, we denote nodes(G, M) the set of nodes in G together w ith any extra ones referenced by the node target declarations in M . With shapes(M) we refer to all the s hap e names in a document M . Deﬁnition 3. Given a graph G, and a shacl document M , an assignment σ for G and M is a function mapping nodes in nodes(G, M), to subsets of shape s(M) ∪ {¬s|s ∈ shapes(M)}, such that for all nodes n and shape names s, σ(n) does not contain both s and ¬s. Expression JdK denotes the evaluation of constr aint d on a node n w.r.t. a graph G under an ass ignment σ, as deﬁned in [1 3]. If JdK is True (resp. False) we say that node n satisﬁes (resp. does not satisfy) constraint d w.r.t. G under σ. For any graph G and assig nment σ, fact s ∈ σ(n) (resp. ¬s ∈ σ(n)) denotes the fact that node n conforms (resp. does not conform) to s w.r.t. G under σ. Expression JdK evaluates to True, False o r Undeﬁned values of Kleene’s 3valued logic, and the truth value of any shape reference in d is computed using the assignment (it should be noted that the Undeﬁned va lue never occurs in no nrecursive shapes, but it is used to deﬁne possible e xtended semantics in the face of recursion). In other words, whenever a truth value in the evaluation of JdK depends on whether another node j conforms to a shape s , with constraints d this is not r e solved by evaluating Jd , but instead it is True if s ∈ σ(j), False if ¬s ∈ σ(j), or else Undeﬁne d. This, in turn, eliminates the problem o f a potentially inﬁnite series of constraint evaluations. The semantics of shacl validation can be deﬁned with respect to a particular type of assignments, called faithful [13]. Deﬁnition 4. For all graphs G, shacl documents M and assignments σ, assignment σ is faithful w.r.t. G and M , denoted with (G, σ) |= M , if the following two conditions hold for any shape hs, t, di in shapes(M) and node n in nodes(G, M) : (1) s ∈ σ(n) iﬀ JdK is True; and ¬s ∈ σ(n) iﬀ JdK is False; (2) if G |= t(n) then s ∈ σ(n). Condition (1) ensures that the facts denoted by the assignment are correct; while condition (2) e nsures that the assignment is compatible with the target deﬁnitions. Condition (2) is trivially satisﬁed for shacl documents where all target deﬁnitions are empty. Later we will want to discuss assignments where the ﬁrst property of Def. 4 holds, but not necessarily the se cond, in order to reason about the existence of alternative a ssignments that are correct (as in, they satisfy the ﬁrst par t of Def. 4) but that are not faithful. In fac t, these will be faithful assignments to a document that is “stripped empty” of target deﬁnitions. Le t M denote the shacl document obtained from substituting all target deﬁnitions in shacl document M with the empty set. The following lemma holds: The existence of a faithful assignment is a necessary and suﬃcient condition for validatio n for no n-recursive shacl documents [13]. As we will see later , this is also necessary condition for all the other extended semantics. Deﬁnition 5. A graph G is valid w.r.t. a non-recursive shacl document M if there ex ist s an assignment σ such that (G, σ) |= M . <title>5 shacl Recursion</title> The semantics of recur sion in shacl documents is left undeﬁned in the shacl sp eciﬁcation [23], and this gives rise to several p ossible interpretations. In this section we consider extended semantics of shacl that deﬁne how to va lidate graphs against recursive shacl documents. We focus on exis ting extended semantics that follow monotone reas oning. These can be characterised by two dimensions, namely the choice between partial and total assignments [13] and between brave and cautious validation [3], which we will subsequently deﬁne. Put together, these two dimensions deﬁne the four extended semantics of bravepartial, brave-total, cautious-partial and cautious-total. We will not go into the details of the less obvious dimension of stable-model semantics [3], which relates shacl to non-monotone reasoning in logic programs. As mentioned in the previous section, assignments can speci fy a truth value of True, False or Undeﬁned to whether a node c onforms to given shape. The tr uth value of Undeﬁned, which does not occ ur in non-recursive shacl documents, can instead play an important role in validating shacl under recursion. Intuitively, this happens during validation, when recursio n makes it impossible for a node n to either conform or not to conform to a s hap e s but, at the same time, validity does not depend on whether n conforms to shape s or not. Consider for example the following shacl document, containing a single shape hs , ∅, d i (with name :InconsistentS in this example). This shape is deﬁned as the negation of itself, that is, given a node n, a graph G and an assignment σ, fact Jd is tr ue iﬀ ¬s ∈ σ(n), and false iﬀ s ∈ σ(n). It is easy to see that any assignment that maps a node to either s or ¬s is not faithful, as it would violate condition (1) of Deﬁnition 4. However, a n assignment that maps eve ry node of a gra ph to the empty set would be faithful for tha t graph and document {s }. Intuitively, this means that nodes in the graph cannot conform nor not co nfo rm to shape s , but since this shape does not have any target node to validate, then the graph can still be valid. The fact of whether nodes conform or not conform to shape s can thus be left as “undeﬁned”. This type of validation, for recurs ive shacl documents, is called va lidation with partial assignments. More speciﬁcally, validation under brave-partial semantics simply extends the criterion of Def. 5 to recursive shacl documents. All other extended semantics are constructed by adding additional c onditions to brave-partial semantics. The term “ partial” should not be interpreted as the fact that it describes only “ part” of nodes of a graph, or tha t it describes the relationship of a node to only “part” of the shapes. Within a partial assignment, the co nfo rmance of every node to every shape is precisely speciﬁed by one of three tr uth values, and the term “partial” only indicates that one of these three truth values is Undeﬁned. Deﬁnition 6. A graph G is valid w.r.t. a shacl document M u nder bravepartial semantics if there exists an assignment σ such that (G, σ) |= M . In the shacl spe c iﬁcation, nodes either conform to, or not conform to a given shape, and the concept of an “undeﬁned” level of conformance is arguably alien to the speciﬁca tion. It is natural, therefore, to consider restricting the evaluation of a constraint to the True and False values of boolean logic. This is achieved by restricting assignments to be total. Deﬁnition 7. An assignment σ is total w.r.t. a graph G and a shacl document M if, for all nodes n in nodes(G, M) and shapes hs, t, di in M, either s ∈ σ(n) or ¬s ∈ σ(n). For any graph G and shacl document M we denote with A and A respectively, the set of assignments, and the set of total assignments for G and M. Trivially, A ⊆ A holds. Deﬁnition 8. A graph G is valid w.r.t. a shacl document M under brave-total semantics if there exists an assignment σ in A such that (G, σ) |= M. Since total assignments are a more speciﬁc type of assignments, if a graph G is valid w .r.t. a shacl document M under brave-total semantics, than it is also va lid w.r.t. M under brave-partial semantics. The reverse, instead, is only true for non-r e c ursive shacl documents. In fact, as shown in [13], if there exists a faithful assignment for a graph G and a non-recursive document M , then there exists also a total faithful assignment for G and M . Therefore, the deﬁnition of validity under brave-total semantics (Def. 8), for non-recursive shacl documents, coincides with the standard deﬁnition of validation (Def. 5). While total assignments can be seen as a more natural way of interpreting the shacl speciﬁcation, they are not without issues when recursive shacl doc uments are considered. Going back to our pr evious example, we can notice that there cannot exist a total faithful assignment for the shacl document containing shape :InconsistentS, for any non-empty graph. This is a trivial consequence of the fact that no node can conform to, nor not conform to, shape :InconsistentS. This, howe ver, is in contradiction with the shacl speciﬁcation, which implies that a shacl do c ument without target declarations in any of its shapes (such as the one in o ur example) s hould trivially valida te any graph. If there are no target declarations, in fact, there are no target nodes on which to verify the conformance of certain shapes, and thus no viola tions should be detected. The second and last dimension that we c onsider is the diﬀerence between brave and cautious validation. When a shacl document M is recursive, there might exist multiple assignments σ sa tisfying prope rty (1) of deﬁnition 4, that is, such that (G, σ) |= M . Intuitively, these can be s e en as equally “correct” assignments with respect to the c onstraints of the shapes, and brave va lidation only checks whether at least one of them is compatible with the target deﬁnitions of the shapes. Cautious validation, instead, represents a stronger form of validation, where all such assignments must be compatible with the target deﬁnitions. Deﬁnition 9. A graph G is valid w.r.t. a shacl document M under cautiouspartial (resp. cautious-total) semantics if it is (1) valid under brave-partial (resp. brave-total) semantics and (2) for all assignments σ in A (resp. ), it is true that if (G, σ) |= M holds then (G, σ) |= M also holds. To exemplify this distinction, consider the following shacl document M This document requir e s the daily special of a restaurant, node :DailySpecial, to be vegetaria n, that is, to conform to shape :VegDishShape. This shape is recursively deﬁned a s follows. Something is a vegetarian dish if it c ontains an ingredient, and all of its ingredients are vegetarian, that is, entities conforming to the :VegIngredientShape. A vegetarian ingredient, in turn, is an ingredient of at least one vegetarian dish. Consider now a graph G containing the following triple. Due to the recursive deﬁnition of :VegDishShape, there exis t two diﬀerent a ssignments σ and σ , which are both faithful for G and M . In σ , no node in G conforms to any shape, while σ diﬀers from σ in that node :DailySpecial conforms to :VegDishShape and node :Chicken conforms to :VegIngredientShape. Essentially, either both the dish and the ingredient from graph G are vegetarian, or neither is. Therefore, σ is faithful for G and M , while σ is not. The question of whether the daily special is a vegetarian dish or not can be approached with diﬀerent levels of “c aution”. Under brave validation, graph G is valid w.r.t. M , since it is possible that the daily special is vegetarian. Cautious validation, instead, takes the more conserva tive approach, and under its deﬁnition G is not va lid w.r.t. M , since it is also possible that the daily special is not vegetarian. When analy sing such recursive deﬁnitions, one might want to exclude “unfounded” assignments, that is, as signments that ass ign certain shapes to a node for no other reason than to allow the validation of a graph. This is achieved by the recursive semantics for shacl proposed in [3], which is based on the concept of stable models from Answer Set Programming. For each extended semantics, the deﬁnition of validity of a graph G with respect to a shacl document M , denoted by G |= M, is summarised in the following list. brave-partial there exists an assignment that is faithful w.r.t. G and M ; brave-total there exists an assignment that is total and faithful w.r.t. G and M; cautious-partial there exists an assignment that is faithful w.r.t. G and M , and every assignment that is faithful w.r.t. G and M is also faithful w.r.t. G and M. cautious-total there exists an assignment that is total and faithful w.r.t. G and M, and every assignment that is total and faithful w.r.t. G and M is also faithful w.r.t. G and M. <title>6 Formal languages for shacl</title> In this section we review the two main formal languages that have been proposed to model the semantics of shacl. We ﬁrst discuss a complete ﬁrst-order formalisation of shacl, which ca n be used to study a number of dec ision problems. We then present a s impliﬁed language that eﬀectively models shacl constraints for the purpose of validatio n. In order to formally study shacl, it is convenient to abs tract away from the syntax of its rdf and sparql re presentations. The SCL ﬁrst order la nguage [37,36] is currently the only complete formalisation of shacl into a formal logical system. The expressiveness of this language covers all of the shacl target declarations and all of the shacl core constraint components, including the ﬁlter components, which are less commonly studied. This language captures the semantics of whole shacl documents, and it can be used to study a number of related decision problems, including validation. The relation between shacl and SCL is given by translation τ [36], such that, given a shacl document M , the ﬁrst order sentence τ (M) is the translation of M into SCL. We identify the inverse translation with τ Before deﬁning SCL and its properties, we must deﬁne how rdf graphs and assignments are modelled in this logical framework. T he domain of discourse is assumed to be the set of rdf terms. Triples are modelled as binary relations, with atom R(s, o) corresponding to triple <s, R, o>. A minus sign identiﬁes the inverse role, i.e. R (s, o) = R(o, s). Binary relation name isA represents class memb ership triples <s, rdf:type, o> as isA(s, o). Assignments are modelled with a se t of monadic relations Σ, called shape relations. Each shacl shape s is associated with a unique sha pe relation Σ in SCL. Facts Σ(x) (resp. ¬Σ(x)) describe an assignment σ such that s ∈ σ(x) (resp. ¬s ∈ σ(x)). Since this logical framework adopts boolean logic, ∀x. Σ(x)∨¬Σ(x) holds, by the law of excluded middle. Thus shape relations deﬁne total a ssignments. Given a graph G and an assignment σ, we now deﬁne their respective translations G and σ into ﬁrst order structures. Deﬁnition 10. Given a graph G, fact p(s, o) is true in the ﬁrst order structure iﬀ <s, p, o> ∈ G. Deﬁnition 11. Given a total assignment σ, fact Σ (n) is true in the ﬁrst order structure σ iﬀ s ∈ σ(n). Deﬁnition 12. Given a graph G and a total assignment σ, the ﬁrst order structure I induced by G and σ is the disjoint union of structures G and σ . Given a ﬁrst order structure I: (1) the graph G induced by I is the graph that contains triple <s, p, o> iﬀ I |= p(s, o) and (2) the assignment σ induced by I is the assignment s uch that, for all nodes n and shape relations Σ , fact s ∈ σ(n) is true iﬀ I |= Σ (n) and ¬s ∈ σ(n) iﬀ I 6|= Σ (n). The existence of faithful assignments using SCL and its standard modeltheoretic semantics is presented in the following theorem [37]. Trivially, this also deﬁnes what condition, in SCL, corr e sponds to validation under the bravetotal extended semantics (Def. 8), which also deﬁnes validation for non-recursive shacl documents (Def. 5). Theorem 1. For any graph G, total assignment σ and shacl document M , it is true that (G, σ) |= M iﬀ I |= τ (M), where I is the ﬁrst order structure induced by G and σ. For any ﬁrst order structure I and SCL formula φ, it is true I |= φ iﬀ (G, σ) |= (φ), where G and σ are, respectively, the graph and assignment induced by I. Sentences in the SCL language follow the ϕ grammar in Deﬁnition 13. Deﬁnition 13. The SHACL ﬁrst order language (SCL, for short) is the set of ﬁrst order s entences built according to the following context-free grammar, where c is a constant from the domain of rdf terms, Σ is a shape relation, F is a ﬁlter relation, with shape relations disjoint from ﬁlter relations, R is a binary-relation name, indicates the transitive closure of the relation induced by π(x, y), the superscript ± refers to a relation or its inverse, and n ∈ N. | ∀x. Σ(x) ↔ ψ(x); | ¬∃y. π(x, y) ∧ R(x, y) [D] | ∀y. π(x, y) ↔ R(x, y) [E] | ∀y, z . π(x, y) ∧ R(x, z) → ς(y, z) [O] | ∃ y . π(x, y) ∧ ψ(y); [C] | ∃z . π(x, z)∧π(z, y) [S] | x =y ∨π(x, y) [Z] | π(x, y)∨π(x, y) [A] | (π(x, y)) ; [T] ς(x, y) := x < y | x ≤ y. Symbol ϕ corresponds to a shacl document. An SCL sentence could be empty (⊤), a conjunction of documents, a target axiom representing a target deﬁnition (a production of the 3rd, 4th and 5 th production rule) or a constraint axiom r epresenting a constraint (a pro duction of the last production rule). Target axioms take one of three forms, based on the type of target declarations. The translation of shacl target declaratio ns into SCL target axio ms is summarise d in Table 2. Letters in sq uare brackets are annotations for naming SCL components and thus are not part of the grammar. These letters are essentially ﬁrst-letter abbreviations of prominent shacl components (that together deﬁne fragments of SCL), and are also listed in Table 3. The non ter minal symbol ψ(x) corresp onds to the subgrammar of the shacl constraints components. Within this subg rammar, ⊤ identiﬁes an empty constraint, x = c a constant equivalence constraint and F a monadic ﬁlter relation (e.g. F (x), true iﬀ x is an IRI). Filters co mponents are captured by F (x) and the O component. The C component captures qualiﬁed value shape cardinality constraints. The E, D and O components capture the equality, disjointedness and order property pair components. The π(x, y) subgrammar models shacl property paths. Within this subgrammar S denotes sequence paths, A denotes alternate paths, Z denotes a zero-or-one path and T denotes a zero-or-more path. Translation τ results in a subset of SCL formulas, called well-formed deﬁned subsequently, and the inverse translation τ only takes well formed sentences as an input. An SCL formula φ is well-formed iﬀ for every shape relation Σ, formula φ contains exactly one constraint axiom with relation Σ on the left-hand side o f the implication. Intuitively, this condition ensures that every shape relation is “deﬁned” by a corresponding constraint axiom. The translation o f the document from Fig. 2, into a well-formed SCL sentence, via τ, is the following. Arguably, this logic notation might seem ea sier to read and understand than the SHACL syntax of Fig. 2. The la nguage deﬁned without any of these constructs is called the base language, denoted ∅. On top of the base la nguage diﬀerent syntactic fragments of SCL are deﬁned by considering diﬀere nt co mbinations of features allowed. We name these fragments by concatenating the letters that represent the features allowed, into a sing le name. For example, SA identiﬁes the fragment that only allows the base language, sequence paths and alternate paths. This means that in order to write an SCL document in SA, one can only use the production rules of Def. 13 that are not annotated with any feature (base language) or those identiﬁed by abbreviations S and A. The shacl speciﬁcation presents an unusual asymmetry in the fact that equality, disjointedness and order c omponents for ce one of their two path expressions to be an atomic relation. This can result in situations where the order constraints can be deﬁned in just one direction, since o nly the less-than and lessthan-or-equal prope rty pair constraints are deﬁned in shacl. The O fragment models a more natural order compar ison that includes the > and ≥ components. The fragment where the order relations in the ς(x, y) subgrammar cannot be inverted is denoted O’. When interpreting an SCL sentence, particular care should be paid to the semantics of ﬁlter relation. The interpretation of each ﬁlter relation, such as (x), is the subset of the domain of discour se on which the ﬁlter is true. This interpretation is constant across all models, and deﬁnes the se mantics of the ﬁlter. When cons idering the decision problem of validation, ﬁlter relations in SCL must be suitably deﬁned by interpreted relations (similarly to how the eq uality operator is). When cons idering additional decision problems, such as satisﬁability and containment (which will be discussed in Section 7), the semantics of ﬁlters can be axioma tisatised, thus removing the need for special interpreted r elations. The ﬁlter ax iomatisation presented in [37] captures the semantics of all SHACL ﬁlters with the single exception of sh:pattern, as this ﬁlter deﬁnes complex non-standard regular ex pressions based on the sparql regex function [42]. Another major language used to study shacl is L which was pre sented in [13] and paved the way to subsequent formal studies o f shacl. The L language diﬀers from SCL in scope and purpose. While SCL sentences describe who le shacl documents, sentences in L describe individual shacl constraints. The L language is primarily designed to inves tigate the complexity of shacl validation. As such, it relies on assumptions that do not hold when studying other decision problems such as sa tisﬁability and c ontainment, which, instead, can be studied using SCL. In pa rticular, L as sumes that all ﬁlter components can be evaluated on a node in constant time, and thus are all e quivalent, for the purposes of validation. Thanks to this re duced scope, L seems less complex than SCL, and it is a useful formalism to study the evaluation of shacl constraints. The semantics of an L sentence φ is deﬁned in [13] through the us e of faithful assignments. In particular, [13] ﬁxes a lookup table that provides the truth value of the evaluation of φ on a node n for a graph G and an assignment σ. Instead, SCL relies on the standard model-theoretic semantics. The grammar of L sentences is given next. In this grammar s is a shape name; I is an IRI; r is a shacl property path; n is a positive integer. Table 4 deﬁnes the correspondence between L and the ψ(x) sub-grammar of SCL. It is easy to see that L sentences correspond to a subset of the ψ(x) sub- grammar of SCL, assuming that r denotes a predicate path. This assumption is r e quired as in L both ar guments of EQ (r , r ), which capture s the shacl equality operator (sh:equals), a re path expressions. This is a generalisa tion of shacl, since the shacl speciﬁcation requires one of the two paths to be a simple predicate path, or in other words, an IRI. It should also be noted that L does not model property pa ir order components (denoted O in SCL), and that the sh:closed component is modelled using path expression oper ators not supported by shacl paths. The shacl disjoint constr aint component (denoted D in SCL) is only implicitly included in L when considering recursion. It is possible, in fact, to repres e nt a disjoint constraint component in L using two auxiliary recursive shapes [13]. <title>7 shacl Decision Problems</title> Several existing pieces of work in the litera ture fo cus on shacl, and several related decision problems have been investigated. In Section 7.1 we r eview existing work on the core decision problem for shacl, namely va lidation. Unlike validation, which studies the relationship between a shacl document and a n rdf graph, the decision problems of satisﬁability and containment, reviewed in Section 7.2, focus on intrinsic properties of SHACL documents and their components. Validation is a cor e decision problem for shacl, since the main application of this language is the validation of rdf graphs. This decision pro blem is decidable for all of the semantics discussed in this article, including the four extended semantics. The complexity lower bounds for validation, however, depend on the fragment of shacl being considered. Table 5 lists the data complexity of three fragments of shacl given in [13,3]. The thr e e fra gments are (1) shacl the fragment of non- recursive shacl documents built using L co nstraints; (2) shacl , the fragment of shacl do c uments built using L constraints with a restricted use of negation, that is, substituting the ¬φ production rule o f L into ∨ φ ; and (3 ) shacl , the fragment of shacl doc uments built using L constraints. The most e xpressive of these fr agments, shacl , is NP-complete in data complexity. Satisﬁability and containment are standard decision problems that have been investigated in the context of shacl. These two decision problems, unlike validation, do not take a graph as an input. Instead, they focus on shacl documents, shapes or constr aints. Given any no tion of validity from one of the semantics deﬁned earlier, the following decision problems are deﬁned. For simplicity, when discussing satistiability and containment, we will assume the us e of the semantics of validation from Deﬁnitions 8 and 5. Deﬁnition 14. A shacl document M is satisﬁable iﬀ there exists a graph G such that G |= M. Deciding whether a shacl document is satisﬁable is the decision problem of shacl satisﬁability. Deﬁnition 15. shacl Containment: For all shacl documen ts M , M , we say that M is contained in M , denoted M ⊆ M , iﬀ for all graphs G, if G |= M then G |= M . Deciding whether a shacl docu ment is contained in another is the decision problem of shacl containment. Two shacl documents M and M that are contained in ea ch other (M and M ⊆ M ) are semantically equ ivalent. Two semantically equivalent documents are not necessarily equiva le nt syntactically, s ince in shacl the same constraint can be expressed using diﬀerent sets of s hap es. The satisﬁability and c ontainment decision problems for shacl can be polynomially r e duced to the satisﬁability decision problem for SCL, deﬁned as follows in the na tur al way [37]. Deﬁnition 16. An SCL sentence φ is satisﬁable iﬀ there exists structure Ω such that Ω |= φ. Deciding whether a SCL sentence is s atisﬁable is the decision problem of SCL satisﬁability. This reduction allows us to study the decidability and complexity of the shacl satisﬁability and containment problems for a given shacl fragment by studying the decidability and complexity of SCL satisﬁability, for the corresponding fragments. The results of this study, published in [37], are summarised in Figure 3. Negative results indicate the undecidability of both the SCL fragment, and the corresponding shacl fragment. Positive results, shown in round blue in the ﬁgure, indicate that bo th satisﬁability and containment are decidable, for that fragment of non-recursive shacl, and are accompanied with complexity upperbounds. Starting from the negative results, shacl satisﬁability and containment is, in general, undecidable. This was shown even for several non-recurs ive fragments, through a semi- c onservative reduction from the standard domino problem [50,5,39], which is an undecidable decision problem. More speciﬁca lly, the shacl sa tisﬁability problems for the S O, S A C, S E C, S E O’, and S Z A E fragments are undecidable [37]. Positive results are obtained by noticing that several SCL fragments are included in decidable fragments of ﬁrst order logic. For exa mple, the S Z A T D fragment of SCL is included in the extension of the unary-negation fragment of ﬁrst-order lo gic with arbitrary transitive relations, which can be solved in 2ExpTime [1,20,15]. The complexity upper bounds identiﬁed in [37] for shacl fragments range from ExpTime to 2ExpTime. Both decision problems are deﬁned over shacl documents which, similarly to the schema of a dataset, could be assumed to be of small o r constant size. Up until this po int we cons idered the satisﬁability and containment problems deﬁned at the level of shacl documents. However, it is po ssible to study variations of these problems at diﬀerent levels of granularity. For example, the satisﬁability and containment problems at the le vel of shacl c onstraints are deﬁned in [37], and are shown to be reducible to the problem of shacl satisﬁability. An approa ch that uses Description Logics Reasoning is presented in [26] to compute shape containment, that is, containment at the level o f shapes, for a restrictive fragment of shacl, which however allows recurs ion. <title>8 Inference Rules and the Schema Expansion</title> Datasets are often dynamic objects, which ar e fr e quently subject to modiﬁcation. When an rdf graph is modiﬁed, its validity w.r.t. a shacl document might change. If the modiﬁcations that a dataset undergoes are completely arbitrary, then it is not po ssible to make predictions regarding validity, and the da taset might need to be re-validated after each modiﬁcation. Many types of modiﬁcations that can be applied on a dataset, however, are predictable or a result of some reasoning process . In particular, many ty pes of modiﬁcations can be represented as inference rules B → H, where a set of facts H, called the head are added to a dataset whenever a query B, called the body, ﬁnds a match on the dataset. Given an rdf graph G, and a s et of inference rules R, it is possible to compute g raph G , closure of G under R, by applying the chase algorithm [4 ]. The chase algorithm, intuitively, consists in repeatedly applying the rules of R on G until convergence. For simplicity, we assume that the chase algorithm is guaranteed to terminate for the inference rules considered. Assuming graph G is valid w.r.t. to a shacl document M , the approach presented in [38], called schema expansion, allows us to predict whether the graph closure G will still be valid w.r.t. M without having to validate G against M. In particular, given a shacl document M and a set of inference rules R, the schema expansion process computes the “ma ximal sub-document” of M which will still validate G after the rule applications. That is, the schema expansion is a shacl document M , ca lled schema consequence, such that (1) M ⊆ M (i.e., is a subset of the restrictions of M ); (2) validity is preserved after closure, that is, for any graph G valid w.r.t. M , its closure G under R is valid w.r.t. M and (3) M is “minimally-containing”, i.e., there is no document M that satisﬁes conditions (1) and (2) and such that that M ⊂ M . If a schema consequence of a shacl document M under inference rules R is semantically equivalent to M , then any graph G, valid w.r.t. M is guaranteed to remain valid w.r.t. M after computing its closure under R. In other words, this means that the application of rules R cannot “invalidate” graphs valid w.r.t. document M . Consider, for example, the following graph G , which describes :Eve, a manager of the company in the IT department, and one of her subordinates :Fiona. This graph is valid w.r.t. the following shacl document M , which states that each employee must have a manager , and each manager must have a department. Consider now the set of inference rules R = {r , r }, where rules r and r are deﬁned as follows. For s implicity, we represent both the head and the body of rules as sparql graph pa tter ns , which are interpreted as sparql construct queries where the where and construct clauses are the body and the head, respectively. Rule r states that every manager can be inferred to be an employee, and r states that everyone can be inferred to be in the same department a s their manager. Notice that gr aph G is not valid w.r.t. M , since :Eve violates :SubordinateS, but it is valid w.r.t. a nother document M which only contains shape :ManagerS. In fact, M is a schema consequence of M and R . Therefore, we know tha t the closure under R of any graph valid w.r.t. M will validate shape :ManagerS, but it might not validate :SubordinateS. Two approaches to compute the schema expansion are presented in [38], for datalog [9] inference rules without negation. The ﬁrst based on the concept of critical instance [30], and the sec ond an optimisation of the ﬁr st. These approaches are only deﬁned on a fragment of shacl that, although restricted, is sufﬁcient to express common constraints for rdf validation, such as the Data Quality Test Patterns typedep, typrodep, pvt, rdfs-domain and rdfs-range in the categorisation by Kontokostas et al. [24]. Intuitively, the diﬃculty in computing a schema expansion lies in having to c onsider all possible graphs that are valid w.r.t. a shacl document, and their interactions with arbitrarily complex inference rules. <title>9 Applications, Tools and Implementations</title> Over a few years since reaching its status as a W3C recommendation, the level of maturity and adoption of the shacl technology has been steadily increasing. In this section we review existing shacl implementations, tools designed to facilitate the cr e ation and management of shacl documents, and documented usages of shacl in practical applications. The availability of mature tools is often a crucial requirement for the widespread adoption of a technology. To date, shacl validation has been integrated in a number of mainstream tools a nd triplestores . An example of this is RDF4J, a Java framework for managing rdf data, which now includes an engine for shacl validation. The RDF4J framework is integrated in a number of projects, most notably the GraphDB triplestore. Other shacl-enabled databa ses include AllegroGra ph by Franz Inc, Apache Jena by Apache, and Stardog by Stardog Union Inc. A benchmark for the comparison of diﬀerent shacl implementation was proposed in [41], a long with results fo r four diﬀerent databases . A shacl implementation is also available for Python through the pySHACL library. One of the ﬁrst tools to enable the validation of recursive shacl graphs was SHAC L 2SPARQL [11]. Another tool, Trav-SHACL [18], implements a shacl engine designed to optimise the evaluation of shacl core constraint components expressible in fragments of the L language [13]. On these fragments of shacl, Trav-SHACL was shown to achieve signiﬁcantly faster validation times compared to the SHACL2SPARQL tool. While eﬃcient tools to perform graph validation are undoubtedly essential to the widespread adoption of shacl, it is also important to devise pr actical ways to generate suitable shacl documents, without which validation would not be p ossible. On the one hand, shacl documents can b e manually created by experts. Tools to support this manual process can facilitate this, especially w hen integrated with already established software . An example of this is SHACL4P [17], a plugin for the Protégé ontology editor [31] which includes an editor to create shacl documents, and a validator that allows users to test the document by validating an ontology with it, and then visualising any constraint violations. Shape Designer [6] is another tool to create shacl documents that combines a graphical editor, and additional algor ithms to create constraints semi-automatically by analysing the data gra ph. The beneﬁts of diﬀerent types of visualisations as an aid to the creating and editing of constraints for rdf graphs was studied in [28]. Existing work also investigated the possibility of generating shacl documents from natural language text [43]. A numb er of approaches have been designed to automate the creation of shacl documents. The SHACLearner [33] approach, generates shacl doc uments by learning a kind of rules called Inverse Open Path (IOP) Rules from the graph data provided. IOP r ules a re strongly related to SCL and therefore shacl. An IOP rule essentially follows the same s tructure as an SCL constraint ax iom, bo th syntactically a nd semantically, with the only exception that the iﬀ o perator is replaced by a rightward implicatio n. Another approach to automate the creation of shacl documents is the Astrea-KG Mappings [10]. These mappings consist of a set of manually created mappings from OWL [49] to shacl, that can be used to automatically generate shacl documents from OWL ontologies. As described in [34], shacl documents can also be generated from the axioms deﬁned by ontology design patterns [19]. The approach from [44] g enerates shacl documents for the purpose of quality asses sment, using the ontology design patterns and data statistics created by the ABSTAT [45] tool as an input. Another similar approach, presented in [8], allows the automatic extraction of shacl constraints from a sparql endpoint, and was tested on the dataset of Europ e ana Notably, shacl documents can also be seen as describing a des irable “schema” for graph data. As such, they can be used as a template to generate new RDF data. An ex ample of this is the Schímatos [51] tool, which generates forms for RDF gra ph editing bas e d on shacl documents, in order to simplify the graph editing task, and minimize the chance of error. An analysis of existing use cases of shacl ca n be useful to gain insights on how this technology is used in pra c tice, and on in its level of adoption. In a recent review, 13 existing projects using shacl have been reviewed, and the mos t common constraints observed were cardinality, class, datatype and dis junction [29]. Several works investigate the use of shacl to verify compliance of a dataset w.r.t. certain policie s, such as GDPR requirements [35,2]. Other applications of shacl include type checking program code [2 7] and detecting metadata erro rs in clinical s tudies [22]. shacl is also used by the European Commission to facilitate data sharing, for example by validating metadata about public services against the recommended voca bularies [46]. Notably, several approaches deﬁne translations into shacl from other technologies, such as ontologies and other schema and constraint languages [16,21,25,3 2,40,47]. These results show that shacl tools, and in particular valida tors, can beneﬁt areas where technologies other than shacl are already established. <title>10 Conclusion</title> Within this review we examined shacl, a constraint language that can be used to validate rdf graphs. These constraints can be used to describe the proper ties of a graph, to detect possible er rors in the data or provide data quality assurances. In this review we ﬁrst presented the main concepts of the shacl speciﬁcation, such as the concept of shapes, and their two main components, targets and constraints. We discussed the primary way to perform shacl validation, using sparql quer ie s, and how the semantics of validation can be abstracted with the concept of assignments. While the shacl speciﬁcation describes how validation should be performed, its semantics is left implicit and not formally deﬁned. We have extensively discussed studies that address this problem. In particula r, we reviewed a complete formalisation of shacl into a fragment of ﬁrst order logic called SCL. This formalisation lays bare several properties of shacl, and provides decidability and complexity results for several shacl-related dec ision problems. Another important line of work focuses on deﬁning potential extensions of shacl semantics that can be used in the face of recursion. The shacl speciﬁcation, in fact, allows constraints to be recursively deﬁned, but it does not deﬁne its semantics. We also presented existing work studying the interaction of shacl with inference rules. Datasets are often dynamic objects, and several questions arise w hen considering the eﬀects of this dynamism on the constraints imposed over them. From the point of view of maturity and level of adoption of the shacl technology, we reviewed several implementations of shacl validators, which are now integrated in many mainstream rdf databas es, and s e veral tools designed to facilitate the creation and management of shacl documents. Several approaches, in particular, provide automated or semi-automated ways of generating suitable shacl documents from a diverse range of sources, such as graph data, ontologies, or natural language texts. Existing eﬀorts in ma pping other constraint/validation languages into shacl is also worth noting, as it sugg ests that the usefulness of shacl could be extended to support other existing technologies. While the true extent of shacl adoption is ha rd to establish, since not all us ages of shacl are publicly documented, we found evidence of its usage in several areas, such as to facilitate data sharing, to validate dataset aga ins t policies, and to detect errors in datasets. Despite the wealth of work on this topic, shacl is still a recent speciﬁcation, and a number of important directio ns for future work still exist. For example, there are opportunities to optimise shacl validators for particular type of constraints, or for particular scenarios, like for highly dynamic databases. More studies are needed to properly assess the usage of shacl in practical applications, and what types of constraints are more commonly used and how. While the full semantics of shacl has bee n formally deﬁned, more work is needed to formally establish its relation with other constraint language s. It is also impor tant to notice tha t most of the pieces of work reviewed in this article limit their scope to ad-hoc subsets of the shacl speciﬁcation. In addition to the custom requirements of each application, this is commonly done in order to avoid excessively complex language components. At the same time, it is often diﬃcult to understand what these subsets exactly are as they a re not always explicitly deﬁned. Therefore, there might be scope to deﬁne r e usable fragments of shacl, that could ﬁll the role of lightweight but expres sive alternatives to the full languag e, similarly to how OWL fragments are deﬁned. It might also be beneﬁcial, for similar reasons, to converge towards a single standard or “preferre d” semantics for shacl rec ursion, which could be deﬁned in a future version of the speciﬁcation. <title>References</title>