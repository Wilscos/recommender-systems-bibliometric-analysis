Motif-based graph decomposition is widely used to mine hierarchical dense structures in graphs. In bipartite graphs, wing and tip decomposition construct a hierarchy of butterÓÄûy (2,2-biclique) dense edge and vertex induced subgraphs, respectively. They have applications in several domains including e-commerce, recommendation systems and document analysis. Existing decomposition algorithms use a bottom-up approach that constructs the hierarchy in an increasing order of subgraph density. They iteratively select the entities (edges or vertices) with minimum support (butterÓÄûy count) and pe el them i.e. remove them from them graph and update the support of other entities. The amount of butterÓÄûies in real-world bipartite graphs makes bottom-up peeling computationally demanding. Furthermore, the strict order of peeling entities results in a large number of iterations with sequential dependencies on preceding support updates. Consequently, parallel algorithms based on bottom up peeling can only utilize intra-iteration parallelism and require heavy synchronization, leading to poor scalability. In this paper, we propose a novel Parallel Bipartite Network peelinG (PBNG) framework which adopts a two-phased peeling approach to relax the order of peeling, and in turn, dramatically reduce synchronization. The ÓÄõrst phase divides the decomposition hierarchy into few partitions, and requires little synchronization to compute such partitioning. The second phase concurrently processes all of these partitions to generate individual levels in the ÓÄõnal decomposition hierarchy, and requires no global synchronization. EÓÄùectively, both phases of PBNG parallelize computation across multiple levels of decomposition hierarchy, which is not possible with bottom-up peeling. The two-phased peeling further enables batching optimizations that dramatically improve the computational eÓÄúciency of PBNG. The proposed approach represents a non-trivial generalization of our prior work on a two-phased vertex peeling algorithm [30], and its adoption for both tip and wing decomposition. We empirically evaluate PBNG using several real-world bipartite graphs and demonstrate radical improvements over the existing approaches. On a shared-memory 36 core server, PBNG achieves up to 19 art parallel framework PÓÅ°ÓÅ≤BÓÅµÓÅ¥ÓÅ¥ÓÅ•ÓÅ≤ÓÅ¶ÓÅ¨ÓÅπ, PBNG reduces synchronization by up to 15260 it achieves up to 38 decomposition results of some of the largest public real-world datasets, which PBNG can peel in few minutes/hours, but algorithms in current practice fail to process even in several days. Our source code is made available at https://github.com/kartiklakhotia/RECEIPT. Additional Key Words and Phrases: Graph Algorithms, Parallel Graph Analytics, Dense Graph Mining, Bipartite Graphs A bipartite graph ùëâ (ùê∫)such that any edge systems naturally exhibit bipartite relationships, such as consumer-product purchase network of an e-commerce website [26 group memberships in a social network [ mining of dense structures in bipartite graphs has become a popular research topic [30, 51, 54, 66, 67, 72]. .5√óspeedup over state-of-the-art algorithms speciÓÄõcally tuned for wing decomposition. We also present the ÓÄõrst ùê∫ (ùëä = (ùëà,ùëâ ), ùê∏)is a special graph whose vertices can be partitioned into two disjoint setsùëà (ùê∫)and ], user-ratings data in a recommendation system [23,34], author-paper network of a scientiÓÄõc ÓÄõeld [41], Nucleus decomposition is commonly used to mine hierarchical dense subgraphs where minimum clique participation of an edge in a subgraph determines its level in the hierarchy [53]. Truss decomposition is arguably the most popular case of nucleus decomposition which uses triangles (3-cliques) to measure subgraph density [5,18,46,50,63,70]. However, truss decomposition is not directly applicable for bipartite graphs as they do not have triangles. One way to circumvent this issue is to compute unipartite projection of a bipartite graphùê∫which contains an edge between each pair of vertices with common neighbor(s) inùê∫. But this approach suÓÄùers from (a) information loss which can impact quality of results, and (b) explosion in dataset size which can restrict its scalability [51]. ButterÓÄûy (2,2‚àíbiclique/quadrangle) is the smallest cohesive motif in bipartite graphs. ButterÓÄûies can be used to directly analyze bipartite graphs and have drawn signiÓÄõcant research interest in the recent years [24,48,49,51,54,64‚Äì 66]. Sariyuce and Pinar [51] use butterÓÄûies as a density indicator to deÓÄõne the notion ofùëò‚àíwings andùëò‚àítips, as maximal bipartite subgraphs where each edge and vertex, respectively, is involved in at leastùëòbutterÓÄûies. For example, the graph shown in ÓÄõg.1a is a 1‚àíwing since each edge participates in at least one butterÓÄûy. Analogous toùëò‚àítrusses [8], ùëò‚àíwings (ùëò‚àítips) represent hierarchical dense structures in the sense that a(ùëò +1)‚àíwing ((ùëò +1)‚àítip) is a subgraph of a ùëò‚àíwing (ùëò‚àítip). In this paper, we explore parallel algorithms for wingand tip decomposition analytics, that construct the entire hierarchy ofùëò‚àíwings andùëò‚àítips in a bipartite graph, respectively. For space-eÓÄúcient representation of the hierarchy, these analytics output wing number of each edgeùëíor tip number of each vertexùë¢, which represent the densest level of hierarchy that containsùëíorùë¢, respectively. Wing and tip decomposition have several real-world applications such as: ‚Ä¢Link prediction in recommendation systems or e-commerce websites that contain communities of users with common preferences or purchase history [12, 24, 32, 40]. ‚Ä¢Mining nested communities in social networks or discussion forums, where users aÓÄúliate with broad groups and more speciÓÄõc sub-groups based on their interests. [24]. ‚Ä¢ Detecting spam reviewers that collectively rate selected items in rating networks [15, 34, 38]. ‚Ä¢ Document clustering by mining co-occurring keywords and groups of documents containing them [10]. ‚Ä¢ Finding nested groups of researchers from author-paper networks [51] with varying degree of collaboration. Existing algorithms for decomposing bipartite graphs typically employ an iterative bottom-up peeling approach [51, 54], wherein entities (edges and vertices for wing and tip decomposition, respectively) with the minimum support (butterÓÄûy count) are peeled in each iteration. Peeling an entityùëôinvolves deleting it from the graph and updating the support of other entities that share butterÓÄûies withùëô. However, the huge number of butterÓÄûies in bipartite graphs makes bottom-up peeling computationally demanding and renders large graphs intractable for decomposing by sequential algorithms. For example, trackers ‚Äì a bipartite network of internet domains and the trackers contained in them, has 140 million edges but more than 20 trillion butterÓÄûies. Parallel computing is widely used to scale such high complexity analytics to large datasets [33,42,57]. However, the bottom-up peeling approach used in existing parallel frameworks [54] severely restricts parallelism by peeling entities in a strictly increasing order of their entity numbers (wing or tip numbers). Consequently, it takes a very large number of iterations to peel an entire graph, for example, it takes>31 million iterations to peel all edges of the trackers dataset using bottom-up peeling. Moreover, each peeling iteration is sequentially dependent on support updates in all prior iterations, thus mandating synchronization of parallel threads before each iteration. Hence, the conventional Fig. 1. (a) Bipartite graph approach of parallelizing workload within each iteration [ parallel scalability. In this paper, we propose a novel two-phased peeling approach for generalized bipartite graph decomposition. Both phases in the proposed approach exploit parallelism across multiple levels of the decomposition hierarchy to drastically reduce the number of parallel peeling iterations and in turn, the amount of thread synchronization. The ÓÄõrst phase creates a coarse hierarchy which divides the set of entity numbers into few non-overlapping ranges. It accordingly partitions the entities by iteratively peeling the ones with support in the lowest range. A major implication of range-based partitioning is that each iteration peels a large number of entities corresponding to a wide range of entity numbers. This results in large parallel workload per iteration and little synchronization. The second phase concurrently processes multiple partitions to compute the exact entity numbers. Absence of overlap between corresponding entity number ranges enables every partition to be peeled independently of others. By assigning each partition exclusively to a single thread, this phase achieves parallelism with no global synchronization. We implement the two-phased peeling as a part of our Parallel Bipartite Network peelinG (PBNG) framework which adapts this approach for both wing and tip decomposition. PBNG further encapsulates novel workload optimizations that exploit batched peeling of numerous entities in the ÓÄõrst phase to dramatically improve computational eÓÄúciency of decomposition. Overall, our contributions can be summarized as follows: (1)We propose a novel two-phased peeling approach for bipartite graph decomposition, that parallelizes workload across diÓÄùerent levels of decomposition hierarchy. The proposed methodology is implemented in our PBNG framework which generalizes it for both vertex and edge peeling. To the best of our knowledge, this is the ÓÄõrst approach to utilize parallelism across the levels of both wing and tip decomposition hierarchies. (2)Using the proposed two-phased peeling, we achieve a dramatic reduction in the number of parallel peeling iterations and in turn, the thread synchronization. As an example, wing decomposition of trackers dataset in PBNG requires only 2034 parallel peeling iterations, which is four orders of magnitude less than existing parallel algorithms. (3)We develop novel optimizations that are highly eÓÄùective for the two-phased peeling approach and dramatically reduce the work done by PBNG. As a result, PBNG traverses only 3.3 trillion wedges during tip decomposition of internet domains in trackers dataset, compared to 211.1 trillion wedges traversed by the state-of-the-art. We empirically evaluate PBNG on several real-world bipartite graphs and demonstrate its superior scalability compared to state-of-the-art. We show that PBNG signiÓÄõcantly expands the limits of current practice by decomposing some of the largest publicly available datasets in few minutes/hours, that existing algorithms cannot decompose in multiple days. In a previous work [30], we developed a two-phased algorithm for tip decomposition (vertex peeling). This paper generalizes the two-phased approach for peeling any set of entities within a bipartite graph. We further present non-trivial techniques to adopt the two-phased peeling for wing decomposition (edge peeling), which is known to reveal better quality dense subgraphs than tip decomposition [51]. 2 BACKGROUND In this section, we formally deÓÄõne the problem statement and review existing methods for butterÓÄûy counting and bipartite graph decomposition. Note that counting is used to initialize support (running count of butterÓÄûies) of each vertex or edge before peeling, and also inspires some optimizations to improve eÓÄúciency of decomposition. Table 1 lists some notations used in this paper. For description of a general approach, we use the term entity to denote a vertex (for tip decomposition) or an edge (for wing decomposition), and entity number to denote tip or wing number (sec.2.2), respectively. Correspondingly, notations‚ä≤‚ä≥andùúÉdenote the support and entity number of entityùëô. ùê∫ (ùëä = (ùëà , ùëâ ), ùê∏) bipartite graph ùê∫ with disjoint vertex sets ùëà (ùê∫) and ùëâ (ùê∫), and edges ùê∏(ùê∫) ùúÉ/ùúÉmaximum tip number of vertices in ùëà (ùê∫) / maximum wing number of edges in ùê∏(ùê∫) 2.1 BuÓÄùerfly counting A butterÓÄûy (2,2-bicliques/quadrangle) can be viewed as a combination of two wedges with common endpoints. For example, in ÓÄõg.1a, both wedges butterÓÄûies is to explore all wedges and combine the ones with common end points. However, this is computationally ineÓÄúcient with complexity O Chiba and Nishizeki [ from each vertexÓÄê√ç a cache-eÓÄúcient version of this algorithm that traverses wedges such that the degree of the last vertex is greater than the that of the start and middle vertices (alg.1, line 10). Thus, wedge explorations frequently end at a small set of high degree vertices that can be cached. The vertex-priority algorithm can be easily parallelized by concurrently processing multiple start vertices [ PBNG, we use the per-vertex and per-edge counting variants of the parallel algorithm [ avoid conÓÄûicts, each thread is provided an individual and butterÓÄûy counts of entities are incremented using atomic operations. Algorithm 1 Counting per-vertex and per-edge butterÓÄûies (pveBcnt) Input: Bipartite Graph ùê∫ (ùëä = (ùëà , ùëâ ), ùê∏) Output: ButterÓÄûy counts ‚Äì ‚ä≤‚ä≥ ‚Üê 0 for each ùë¢ ‚àà ùëä (ùê∫); ‚ä≤‚ä≥ 2.2 Bipartite Graph Decomposition Sariyuce et al.[ They are formally deÓÄõned as follows: ùë¢, only those wedges are expanded whereùë¢has the highest degree. It has a theoretical complexity ofÓÄë min (ùëë, ùëë)= O(ùõº ¬∑ ùëö), which is state-of-the-art for butterÓÄûy counting. Wang et al.[66] further propose in increasing order of new labels ‚Üê ‚ä≤‚ä≥+ ùëèùëêùëõùë°; ‚ä≤‚ä≥‚Üê ‚ä≤‚ä≥+ ùëèùëêùëõùë° and ùëídenote edges (ùë†ùë°ùëéùëüùë°,ùëöùëñùëë) and (ùëöùëñùëë, ùëôùëéùë†ùë°), respectively ‚Üê ‚ä≤‚ä≥+ (ùë§ùëíùëëùëîùëí_ùëêùëúùë¢ùëõùë° [ùëôùëéùë†ùë°] ‚àí 1); ‚ä≤‚ä≥‚Üê ‚ä≤‚ä≥+ (ùë§ùëíùëëùëîùëí_ùëêùëúùë¢ùëõùë° [ùëôùëéùë†ùë°] ‚àí 1) 51] introducedùëò‚àítips andùëò‚àíwings as a butterÓÄûy dense vertex and edge-induced subgraphs, respectively. DÓÅ•ÓÅ¶ÓÅ©ÓÅÆÓÅ©ÓÅ¥ÓÅ©ÓÅØÓÅÆ 1. A bipartite subgraph ùêª ‚äÜ ùê∫, induce d on edges ùê∏(ùêª ) ‚äÜ ùê∏(ùê∫), is a k-wing iÓÄù ‚Ä¢ each edge ùëí ‚àà ùê∏(ùêª ) is contained in at least k butterÓÄûies, ‚Ä¢ any two edges (ùëí, ùëí) ‚àà ùê∏is connected by a series of butterÓÄûies, ‚Ä¢ ùêª is maximal i.e. no other ùëò‚àíwing in ùê∫ subsumes ùêª. DÓÅ•ÓÅ¶ÓÅ©ÓÅÆÓÅ©ÓÅ¥ÓÅ©ÓÅØÓÅÆ 2. A bipartite subgraph ùêª ‚äÜ ùê∫, induce d on vertex sets ùëà (ùêª ) ‚äÜ ùëà (ùê∫) and ùëâ (ùêª) = ùëâ (ùê∫), is a k-tip iÓÄù ‚Ä¢ each vertex ùë¢ ‚àà ùëà (ùêª ) is containe d in at least k butterÓÄûies, ‚Ä¢ any two vertices {ùë¢, ùë¢} ‚àà ùëà (ùêª ) are connected by a series of butterÓÄûies, ‚Ä¢ ùêª is maximal i.e. no other ùëò‚àítip in ùê∫ subsumes ùêª. Bothùëò‚àíwings andùëò‚àítips are hierarchical as aùëò‚àíwing/ùëò‚àítip completely overlaps with aùëò‚àíwing/ùëò‚àítip for all ùëò‚â§ ùëò. Therefore, instead of storing allùëò‚àíwings, a wing numberùúÉof an edgeùëíis deÓÄõned as the maximumùëòfor whichùëíis present in aùëò‚àíwing. Similarly, tip numberùúÉof a vertexùë¢is the maximumùëòfor whichùë¢is present in a ùëò‚àítip. Wing and tip numbers act as a space-eÓÄúcient indexing from which any level of theùëò‚àíwing andùëò‚àítip hierarchy, respectively, can be quickly retrieved [51]. In this paper, we study the problem of ÓÄõnding wing and tip numbers, also known as wing and tip decomposition, respectively. Bottom-Up Peeling (BUP) is a commonly employed technique to compute wing decomposition (alg.2). It initializes the support of each edge using per-edge butterÓÄûy counting (alg.2, line 1), and then iteratively peels the edges with minimum support until no edge remains. When an edgeùëí ‚àà ùê∏is peeled, its support in that iteration is recorded as its wing number (alg.2, line 4). Further, for every edgeùëíthat shares butterÓÄûies withùëí, the support‚ä≤‚ä≥is decreased corresponding to the removal of those butterÓÄûies. Thus, edges are peeled in a non-decreasing order of wing numbers. Bottom-up peeling for tip decomposition utilizes a similar procedure for peeling vertices. A crucial distinction here is that in tip decomposition, vertices in only one of the setsùëà (ùê∫)orùëâ (ùê∫)are peeled as aùëò‚àítip consists of all vertices from the other set (defn.2). For clarity of description, we assume thatùëà (ùê∫)is the vertex set to peel. As we will see later in sec.3.2, this distinction renders the two-phased approach of PBNG highly suitable for decomposition. Runtime of bottom-up peeling is dominated by wedge traversal required to ÓÄõnd butterÓÄûies that contain the en-ÓÄê√ç√çÓÄë tities being peeled (alg.2, lines 7-9). The overall complexity for wing decomposition isOùëë=ÓÄêÓÄëÓÄêÓÄëÓÄêÓÄë O√ç√çùëëùëë. Relatively, tip decomposition has a lower complexity ofO√ç√çùëë= O√çùëë, which is still quadratic in vertex degrees and very high in absolute terms. 2.3 Bloom-Edge-Index Chiba and Nishizeki [7] proposed storing wedges derived from the computational patterns of their butterÓÄûy counting algorithm, as a space-eÓÄúcient representation of all butterÓÄûies. Wang et al.[67] used a similar representation termed Bloom-Edge-Index (BE-Index) for quick retrieval of butterÓÄûies containing peeled edges during wing decomposition. We extensively utilize BE-Index not just for computational eÓÄúciency, but also for enabling parallelism in wing decomposition. In this subsection, we give a brief overview of some key concepts in this regard. The butterÓÄûy counting algorithm assigns priorities (labels) to all vertices in a decreasing order of their degree (alg.1, line 2). Based on these priorities, a structure called maximal priorityùëò‚àíbloom, which is the basic building block of BE-Index, is deÓÄõned as follows [67]: DÓÅ•ÓÅ¶ÓÅ©ÓÅÆÓÅ©ÓÅ¥ÓÅ©ÓÅØÓÅÆ 3. A maximal priorityùëò‚àíbloomùêµ(ùëä = (ùëà , ùëâ ), ùê∏)is a(2, ùëò)‚àíbiclique (eitherùëà (ùêµ)orùëâ (ùêµ)has exactly two vertices, each connected to all ùëò vertices in ùëâ (ùêµ) or ùëà (ùêµ), respectively) that satisÓÄões the following conditions: Algorithm 2 Wing decomposition using bottom-up peeling (BUP) Input: Bipartite graph ùê∫ (ùëä = (ùëà , ùëâ ), ùê∏) (1) The highest priority vertex in ùëä (ùêµ) belongs to the set (ùëà (ùêµ) or ùëâ (ùêµ)) which has exactly two vertices, and (2) ùêµ is maximal i.e. there exists no (2, ùëò)‚àíbiclique ùêµ Maximal Priority Bloom Notations dominant set of be twins of each other in bloom is a maximal priority 2 The twin of an edge is called the bloom number of ùêµ. Wang et al.[67] further prove the following properties of maximal priority blooms: PÓÅ≤ÓÅØÓÅ∞ÓÅ•ÓÅ≤ÓÅ¥ÓÅπ 2. A butterÓÄûy in ùê∫ must be contained in exactly one maximal priority ùëò‚àíbloom. Note that the butterÓÄûies containing an edge all blooms that contain ùëí. For quick access to blooms of an edge and vice-versa, BE-Index is deÓÄõned as follows: DÓÅ•ÓÅ¶ÓÅ©ÓÅÆÓÅ©ÓÅ¥ÓÅ©ÓÅØÓÅÆ 4. BE-Index of a graph priority blooms in ùê∫ to the respective edges within the blooms. ‚Ä¢ W(I) ‚Äì Each vertex ùêµ ‚àà ùëà (ùêº ) also stores the bloom number ùëò ‚Ä¢ E(I) ‚Äì Each edge (ùëí, ùêµ) ‚àà ùê∏ (ùêº) is labeled with ùë°ùë§ùëñùëõ(ùëí, ùêµ). BE-Index Notations notationùêµ ùêµ ‚àà ùëà (ùêº ) by ùëò(ùêº ). Note that ùëò ‚Üê ‚ä≤‚ä≥, ùê∏(ùê∫) ‚Üê ùê∏ (ùê∫) \ {ùëí} denote edge (ùë¢, ùë£) ‚Üê maxùúÉ, ‚ä≤‚ä≥‚àí1; ‚ä≤‚ä≥‚Üê maxùúÉ, ‚ä≤‚ä≥‚àí1; ‚ä≤‚ä≥‚Üê maxùúÉ, ‚ä≤‚ä≥‚àí1‚ä≤ Update support ùêµ. Note that each vertex in the non-dominant set has exactly two incident edges inùê∏(ùêµ), that are said to ùëò‚àíbloomùêµ(ùëä = (ùëà , ùëâ ), ùê∏)consists of exactlyÓÄÄÓÄÅ=butterÓÄûies. Each edgeùëí ‚àà ùê∏(ùêµ)is contained ùëò ‚àí1 butterÓÄûies inùêµ. Further, edgeùëíshares allùëò ‚àí1 butterÓÄûies withùë°ùë§ùëñùëõ(ùëí, ùêµ), and one butterÓÄûy each with all ‚àà ùê∏(ùêµ) \ {ùë°ùë§ùëñùëõ(ùëí, ùêµ)}. Vertices inùëà (ùêº )andùëâ (ùêº)uniquely represent all maximal priority blooms inùê∫and edges inùê∏(ùê∫), respectively. There exists an edge(ùëí, ùêµ) ‚àà ùê∏(ùêº )if and only if the corresponding bloomùêµ ‚äÜ ùê∫contains the edgeùëí ‚àà ùê∏(ùê∫). (orùëí) to denote both a bloom (or edge) and its representative vertex in BE-Index. Neighborhood of a vertex andùëí ‚àà ùëâ (ùêº )is denoted byùëÅ(ùêº )andùëÅ(ùêº ), respectively. The bloom number ofùêµin BE-Indexùêºis denoted Fig.2 depicts a graphùê∫(subgraph ofùê∫from ÓÄõg.1) and its BE-Index.ùê∫consists of two maximal priority blooms: (a)ùêµwith dominant setùëâ (ùêµ) = {ùë£, ùë£}andùëò(ùêº ) =2, and (b)ùêµwith dominant vertex setùëâ (ùêµ) = {ùë£, ùë£}and ùëò(ùêº ) =3. As an example, edgeùëíis a part of 1 butterÓÄûy inùêµshared with twinùëí, and 2 butterÓÄûies inùêµshared with twin ùëí. With all other edges in ùêµand ùêµ, it shares one butterÓÄûy each. Construction of BE-Index: Index construction can be easily embedded within the counting procedure (alg.1). Each pair of endpoint vertices{ùë†ùë°ùëéùëüùë°, ùëôùëéùë†ùë° }of wedges explored during counting, represents the dominating set of a bloom (with ùëôùëéùë†ùë°as the highest priority vertex) containing the edges{ùë†ùë°ùëéùëüùë°,ùëöùëñùëë}and{ùëöùëñùëë, ùëôùëéùë†ùë° }for all midpointsùëöùëñùëë. Lastly, for a given vertexùëöùëñùëë, edges{ùë†ùë°ùëéùëüùë°,ùëöùëñùëë}and{ùëöùëñùëë, ùëôùëéùë†ùë° }are twins of each other. Thus, the space and computational complexities of BE-Index construction are bounded by the the wedges explored during counting which is O(ùõº ¬∑ ùëö). Wing Decomposition with BE-Index: Alg.3 depicts the procedure to peel an edgeùëíusing BE-Indexùêº. Instead of traversing wedges inùê∫to ÓÄõnd butterÓÄûies ofùëí, edges that share butterÓÄûies withùëíare found by exploring 2-hop neighborhood ofùëíinùêº(alg.3, line 7). Number of butterÓÄûies shared with these edges in each bloom is also obtained analytically using property 1 (alg.3, lines 4 and 8). Remarkably, peeling an edgeùëíusing alg.3 requires at most‚ä≤‚ä≥ÓÄê√çÓÄë traversal in BE-Index [67]. Thus, it reduces the computational complexity of wing decomposition toO‚ä≤‚ä≥. However, it is still proportional to the number of butterÓÄûies which can be enormous for large graphs. Algorithm 3 Support update during edge peeling, using BE-Index 2.4 Challenges Bipartite graph decomposition is computationally very expensive and parallel computing is widely used to accelerate such workloads. However, state-of-the-art parallel framework PÓÅ°ÓÅ≤BÓÅµÓÅ¥ÓÅ¥ÓÅ•ÓÅ≤ÓÅ¶ÓÅ¨ÓÅπ [11,54] is based on bottom-up peeling and only utilizes parallelism within each peeling iteration. This restricted parallelism is due to the following sequential dependency between iterations ‚Äì support updates in an iteration guide the choice of entities to peel in the subsequent iterations. Hence, even though PÓÅ°ÓÅ≤BÓÅµÓÅ¥ÓÅ¥ÓÅ•ÓÅ≤ÓÅ¶ÓÅ¨ÓÅπ is work-eÓÄúcient [54], its scalability is limited because: (1)It incurs large number of iterations and low parallel workload per iteration. Due to the resulting synchronization and load imbalance, intra-iteration parallelism is insuÓÄúcient for substantial acceleration. Objective 1 synchronization and exposes large amount of parallel workload. (2)It traverses an enormous amount of wedges (or bloom-edge links in BE-Index) to retrieve butterÓÄûies removed by peeling. This is computationally expensive and can be infeasible on large datasets, even for a parallel algorithm. Objective 2 is therefore, to reduce the amount of traversal in practice. 3 PARALLEL BIPARTITE NETWORK PEELING (PBNG) In this section, we describe a generic parallelism friendly two-phased peeling approach for bipartite graph decomposition (targeting objective 1, sec.2.4). We further demonstrate how this approach is adopted individually for tip and wing decomposition in our Parallel Bipartite Network peelinG (PBNG) framework. 3.1 Two-phased Peeling The fundamental observation underlining our approach is that entity number number of butterÓÄûies shared between ùê∫ (ùëä = (ùëà , ùëâ ), ùê∏) and per-entity butterÓÄûy counts in ùê∫ (obtained from counting), only the cumulative eÓÄùect of peeling all entities with entity number strictly smaller than decomposition hierarchy. Due to commutativity of addition, the order of peeling these entities has no impact on This insight allows us to eliminate the constraint of deleting only minimum support entities in each iteration, which bottlenecks the available parallelism. To ÓÄõnd concurrently, providing suÓÄúcient parallel workload. However, for every possible number will be computationally very ineÓÄúcient. To avoid this ineÓÄúciency, we develop a novel two-phased approach. 3.1.1 Coarse-grained Decomposition. The ÓÄõrst phase divides the spectrum of all possible entity numbers intoùëÉsmaller non-overlapping ranges user-speciÓÄõed parameter. A range allùëó ‚â† ùëñ. These ranges are computed using a heuristic described in sec.3.1.3. Corresponding to each range also computes the partition entity number Coarse-grained Decomposition (PBNG CD). The absence of overlap between the ranges allows each subset to be peeled independently of others in the second phase, for exact entity number computation. Entity partitions are computed by iteratively peeling entities whose support lie in the minimum range (alg.4,lines 5-13). For each partition, the ÓÄõrst peeling iteration in PBNG CD scans all entities to ÓÄõnd the peeling set, denoted as ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë° up peeling, PBNG CD does not require a priority queue data structure which makes support updates relatively cheaper. PBNG CD can be visualized as a generalization of bottom-up peeling (alg.2). In each iteration, the latter peels entities with minimum support ( is therefore, to design a parallelism aware peeling methodology for bipartite graphs that reduces ùúÉof an entityùëô, the ÓÄõrst phase of PBNG computes bounds onùúÉ. Therefore, we refer to this phase as (alg.4, line 9). In subsequent iterations,ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°is computed jointly with support updates. Thus, unlike bottom- Fig. 3. Graphical illustration of PBNG‚Äôs two-phased peeling for wing decomposition of the graph ùê∫ from fig.1. The coarse-grained decomposition divides ùê∏ (ùê∫) into ùëÉ = 2 partitions using parallel peeling iterations. The fine-grained decomposition peels each For example, in ÓÄõg.3, PBNG CD divides edgesùê∏(ùê∫)into two partitions corresponding to rangesùëÖ= [0,2]andùëÖ= [3,5], whereas bottom-up peeling will create 4 partitions corresponding to every individual level in the decomposition hierarchy (ùúÉ = {1,2,3,4}). SettingùëÉ ‚â™ ùúÉensures a large number of entities peeled per iteration (suÓÄúcient parallel workload) and signiÓÄõcantly fewer iterations (dramatically less synchronization) compared to bottom-up peeling. In addition to the ranges and partitions, PBNG CD also computes a support initialization vector‚ä≤‚ä≥. For an entity ùëô ‚àà ùêø,‚ä≤‚ä≥is the number of butterÓÄûies thatùëôshares only with entities in partitionsùêøsuch thatùëó ‚â• ùëñ. In other words, it represents the aggregate eÓÄùect of peeling entities with entity number in ranges lower thanùëÖ. During iteative peeling in PBNG CD, this number is inherently generated after the last peeling iteration ofùëÖand copied into‚ä≤‚ä≥(ùëô)(alg.4, lines 6-7). For example, in ÓÄõg.3, support of ùëíafter peeling ùê∏= {ùëí, ùëí, ùëí, ùëí, ùëí} is 3, which is recorded in ‚ä≤‚ä≥. 3.1.2 Fine-grained Decomposition. The second phase computes exact entity numbers and is called Fine-grained Decomposition (PBNG FD). The key idea behind PBNG FD is that if we have the knowledge of all butterÓÄûies that each entity ùëô ‚àà ùêøshares only with entities in partitionsùêøsuch thatùëó ‚â• ùëñ,ùêøcan be peeled independently of all other partitions. The‚ä≤‚ä≥vector computed in PBNG CD precisely indicates the count of such butterÓÄûies (sec.3.1.1) and hence, is used to initialize support values in PBNG FD. PBNG FD exploits the resulting independence among partitions to concurrently process multiple partitions using sequential bottom up peeling. SettingùëÉ ‚â´ ùëáensures that PBNG FD can be eÓÄúciently Algorithm 4 PBNG Coarse-grained Decomposition (PBNG CD) for wing decomposition Input: Bipartite graph ùê∫ (ùëä = (ùëà , ùëâ ), ùê∏), # partitions ùëÉ Output: Ranges {ùúÉ (1), ùúÉ (2) . . . ùúÉ (ùëÉ + 1)}, Edge Partitions {ùê∏ ‚Üê {ùúô} ‚àÄ ùëñ ‚àà {1, 2 . . . ùëÉ } parallelized across partitions on between diÓÄùerent levels of decomposition hierarchy to eÓÄúciently parallelize the peeling process. The two-phased approach can potentially double the computation required for peeling. However, we note that since partitions are peeled independently in PBNG FD, support updates are not communicated across the partitions. Therefore, to improve computational eÓÄúciency, PBNG FD operates on a smaller representative subgraph each partitions ùêø ‚Üê arg min(ùúÉ)such that ùë§ùëúùëüùëò [ùúÉ] ‚â• ùë°ùëîùë° + 1 ‚Üê ùë°ùë§ùëñùëõ(ùëí, ùêµ), ùëò(ùêº ) ‚Üê bloom number of ùêµ in ùêºÓÄÄÓÄÅ (ùëí‚àâ ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°)orùëíùëëùëîùëíùêº ùê∑ (ùëí) < ùëíùëëùëîùëíùêºùê∑ (ùëí)thenÓÄÄÓÄÅ . SpeciÓÄõcally, ùê∫preserves a butterÓÄûy ‚ä≤‚ä≥ iÓÄù it satisÓÄões both of the following conditions: (2) ‚ä≤‚ä≥only contains entities from partitionsùêøsuch thatùëó ‚â• ùëñ. If‚ä≤‚ä≥contains an entity from lower ranged partitions, then it does not exist inùúÉ (ùëñ)-level of decomposition hierarchy (lowest entity number inùêø). Moreover, the impact of removing ‚ä≤‚ä≥ on the support of entities in ùêø, is already accounted for in ‚ä≤‚ä≥(sec.3.1.1). For example, in ÓÄõg.3,ùê∫contains the butterÓÄûy‚ä≤‚ä≥ =(ùë¢, ùë£, ùë¢, ùë£)because (a) it contains multiple edges{ùëí, ùëí} ‚àà ùêø and satisÓÄões condition 1, and (b) all edges in ‚ä≤‚ä≥ are from ùêøor ùêøand hence, it satisÓÄões condition 2. However, ùê∫does not contain this butterÓÄûy because two if its edges are in ùêøand hence, it does not satisfy condition 2 for ùê∫. 3.1.3 Range Partitioning. In PBNG CD, the ÓÄõrst step for computing a partitionùêøis to ÓÄõnd the rangeùëÖ= [ùúÉ (ùëñ), ùúÉ (ùëñ + 1))(alg.4, line 8). For load balancing,ùúÉ (ùëñ +1)should be computedsuch that the all partitionsùêøpose uniform workload in PBNG FD. However, the representative subgraphs and the corresponding workloads are not known prior to actual partitioning. Furthermore, exact entity numbers are not known either and hence, we cannot determine beforehand, exactly which entities will lie inùêøfor diÓÄùerent values ofùúÉ (ùëñ +1). Considering these challenges, PBNG uses two proxies for range determination: (1) Proxy 1 ‚Üí current support ‚ä≤‚ä≥of an entity ùëô is used as a proxy for its entity number. (2)Proxy 2‚Üícomplexity of peeling individual entities inùê∫is used as a proxy to estimate peeling workload in representative subgraphs. Now, the problem is to computeùúÉ (ùëñ +1)such that estimated workload ofùêøas per proxies, is close to the average workload per partition denoted asùë°ùëîùë°. To this purpose, PBNG CD creates a bin for each support value, and computes the aggregate workload of entities in that bin. For a givenùúÉ (ùëñ +1), estimated workload of peelingùêøis the sum of workload of all bins corresponding to support less thanùúÉ (ùëñ +1). Thus, the workload ofùêøas a function ofùúÉ (ùëñ +1)can be computed by a preÓÄõx scan of individual bin workloads (alg.4, lines 17-18). Using this function, the upper bound is chosen such that the estimated workload of ùêøis close to but no less than ùë°ùëîùë° (alg.4, line 19). Adaptive Range Computation: Since range determination uses current support as a proxy for entity numbers, the target workload for each partitionùêøis covered by the entities added toùêøin its very ÓÄõrst peeling iteration in PBNG CD. After the support updates in this iteration, more entities may be added toùêøand ÓÄõnal workload estimate ofùêømay signiÓÄõcantly exceedùë°ùëîùë°. This can result in signiÓÄõcant load imbalance among the partitions and potentially, PBNG CD could ÓÄõnish in much fewer thanùëÉpartitions. To avoid this scenario, we implement the following two-way adaptive range determination: (1)Instead of statically computing an average target, we dynamically updateùë°ùëîùë°for every partition based on the remaining workload and the number of partitions to create. If a partition gets too much workload, the target for subsequent partitions is automatically reduced, thereby preventing a situation where all entities get peeled in ‚â™ ùëÉ partitions. (2)A partitionùêølikely covers many more entities than the initial estimate based on proxy 1. The second adaptation scales down the dynamic target for ùêøin an attempt to bring the actual workload close to the intended value. It assumes predictive local behavior i.e.ùêøwill overshoot the target similar toùêø. Therefore, the scaling factor is computed as the ratio of initial workload estimate ofùêøduringùúÉ (ùëñ)computation, and ÓÄõnal estimate based on all entities inùêø. 3.1.4 Partition scheduling in PBNG FD. While adaptive range determination(sec.3.1.3) tries to create partitions with uniform estimated workload, the actual workload per partition in PBNG FD depends on the the representative subgraphs ùê∫and can still have signiÓÄõcant variance. Therefore, to improve load balance across threads, we use scheduling strategies inspired from Longest Processing Time (LPT) scheduling rule which is a well known We use the workload of ùêø ‚Ä¢Dynamic task allocation from the queue and processes the corresponding partition. Thus, all threads are busy until every partition is scheduled. ‚Ä¢Workload-aware Scheduling partitions with highest workload get scheduled ÓÄõrst and the threads processing them naturally receive fewer tasks in the future. Fig.4 shows how workload-aware scheduling can improve the eÓÄúciency of dynamic allocation. Fig. 4. Benefits of Workload-aware Scheduling (WaS) in a 3-thread (ùëá estimated time to peel them in PBNG FD. Dynamic allocation without WaS finishes in 28 units of time compared to 20 units with WaS. 3.2 Tip Decomposition In this section, we give a brief overview of PBNG‚Äôs two-phased peeling (sec.3.1) applied for tip decomposition. A detailed description of the same is provided in our previous work [30]. For tip decomposition, PBNG CD divides the vertex set ùë¢ ‚àà ùëà (ùê∫) uses wedge count of vertices in one of the vertex sets of support updates to a vertex to support ‚ä≤‚ä≥ PBNG FD also utilizes the fact that any butterÓÄûy peeled (sec.2.2). If are satisÓÄõed only when ùëä= (ùëà,ùëâ (ùê∫)) FD (sec.3.1.4), we use the total wedges in ùê∫ requires traversal of all wedges withùë¢as one of the endpoints. Therefore, range determination in PBNG CD can be simply computed by atomically aggregating the updates from individual vertices in ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°. ùë¢ ‚àà ùëàandùë¢‚àà ùëà, the two conditions for preserving‚ä≤‚ä≥in either representative graphsùê∫orùê∫ . Clearly,ùê∫preserves every butterÓÄûyùë¢, ùë£, ùë¢, ùë£where{ùë¢, ùë¢} ‚àà ùëà. For task scheduling in PBNG Given the bipartite nature of graphùê∫, any edge(ùë¢, ùë£) ‚àà ùê∏(ùê∫)exists in exactly one of the subgraphsùê∫and thus, the collective space requirement of all induced subgraphs is bounded by ùëÇ (ùëö). Moreover, by the design of representative (induced) subgraphs, PBNG FD for tip decomposition traverses only those wedges for which both the endpoints are in the same partition. This dramatically reduces the amount of work done in PBNG FD compared to bottom-up peeling and PBNG CD. Note that we do not use BE-Index for tip decomposition due to the following reasons: ‚Ä¢ButterÓÄûies between two vertices are quadratic in the number of wedges between them, and wedge traversal (not butterÓÄûy count) determines the work done in tip decomposition. Since BE-Index facilitates per-edge butterÓÄûy retrieval, peeling a vertex using BE-Index will require processing each of its edge individually and can result in increased√ç√ç computation ifùëë‚â™‚ä≤‚ä≥(sec.2.3).ÓÄêÓÄë ‚Ä¢BE-Index has a high space complexity ofO√çmin(ùëë, ùëë)compared to justO(ùëö)space needed to store ùê∫and all induced subgraphsùê∫. This can make BE-Index based peeling infeasible even on machines with large amount of main memory. For example, BE-Index of a user-group dataset Orkut (327 million edges) has 26 billion blooms, 150 billion bloom-edge links and consumes 2.6 TB memory. 3.3 Wing Decomposition 3.3.1 Challenges. Each butterÓÄûy consists of 4 edges inùê∏(ùê∫)which is the entity set to decompose in wing decomposition. This is unlike tip decomposition where each butterÓÄûy has only 2 vertices from the decomposition setùëà (ùê∫), and results in the following issues: (1)When a butterÓÄûy‚ä≤‚ä≥is removed due to peeling, the support of unpeeled edge(s) in‚ä≤‚ä≥should be reduced by exactly 1 corresponding to this removal. However, when multiple (but not all) edges in‚ä≤‚ä≥are concurrently peeled in the same iteration of PBNG CD, multiple updates with aggregate value > 1 may be generated to unpeeled edges in ‚ä≤‚ä≥. (2)It is possible that a butterÓÄûy‚ä≤‚ä≥contains multiple but not all edges from a partition. Thus,‚ä≤‚ä≥may need to be preserved in the representative subgraph of a partition, but will not be present in its edge-induced subgraph. Due to these reasons, a trivial extension of tip decomposition algorithm (sec.3.2) is not suitable for wing decomposition. In this section, we explore novel BE-Index based strategies to enable two-phased peeling for wing decomposition. 3.3.2 PBNG CD. This phase divides the edgesùê∏(ùê∫)intoùëÉpartitions ‚Äì{ùê∏, ùê∏, . . . , ùê∏}, as shown in alg.4. Not only do we utilize BE-Index for computationally eÓÄúcient support update computation in PBNG CD, we also utilize it to avoid conÓÄûicts in parallel peeling iterations of PBNG CD. Since a butterÓÄûy is contained in exactly one maximal priority bloom (sec.2.3, property 2), correctness of support updates within each bloomùêµimplies overall correctness of support updates in an iteration. To avoid conÓÄûicts, we therefore employ the following resolution mechanism for each bloom ùêµ: (1)If an edgeùëíand its twinùëí= ùë°ùë§ùëñùëõ(ùëí, ùêµ)are both peeled in the same iteration, then only the edge with highest index amongùëíandùëíupdates (a) the support of other edges inùêµ, and (b) the bloom numberùëò(ùêº )(alg.4, lines 26-31). This is because all butterÓÄûies in ùêµ that contain ùëí also contain ùëí(sec.2.3, property1). (2)If in an iteration, an edgeùëí ‚àà ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°butùëí= ùë°ùë§ùëñùëõ(ùëí, ùêµ) ‚àâ ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°, then the support‚ä≤‚ä≥is decreased by exactly ùëò(ùêº ) ‚àí 1whenùëíis peeled. Other edges inùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°do not propagate any updates to‚ä≤‚ä≥via bloomùêµ(alg.4, lines 26-30). This is becauseùëíis contained in exactlyùëò(ùêº ) ‚àí 1butterÓÄûies inùêµ, all of which are removed whenùëíis peeled. To ensure thatùëò(ùêº )correctly represents the butterÓÄûies shared between twin edges, support updates from all peeled edges are computed prior to updating ùëò(ùêº ). Peeling an edge uses edge support as a proxy to estimate the workload of peeling each partition ùê∏ Algorithm 5 PBNG Fine-grained Decomposition (PBNG FD) for wing decomposition Input: Graph ùê∫ (ùëä = (ùëà , ùëâ ), ùê∏), BE-Index ùêº (ùëä = (ùëà,ùëâ ), ùê∏), edge partitions {ùê∏ 3.3.3 PBNG FD. The ÓÄõrst step for peeling a partition its representative subgraph to construct ùêº ‚Ä¢Computing expensive. Additionally, the overhead of index construction even for a few hundred partitions can be signiÓÄõcantly large. ‚Ä¢Any edge ùê∫requires O (ùëöùëÉ) memory space. To avoid these drawbacks, we directly compute ùê∫(alg.5, lines 12-25). Our partitioning mechanism ensures that all butterÓÄûies satisfying the two preservation conditions (sec.3.1.2) for a partition ùê∏ ùëí ‚àà ùê∏(ùê∫)requiresO(‚ä≤‚ä≥)traversal in the BE-Index. Therefore, range determination in PBNG CD Support initialization vector ‚ä≤‚ä≥ for all ùëí ‚àà ùê∏‚ä≤ Initialize Support , . . . , ùêº ‚Üê ‚ä≤‚ä≥, ùê∏‚Üê ùê∏\ {ùëí} ) ‚Üê ùê∏, ùëà (ùêº) ‚Üê {ùúô}, ùê∏(ùêº) ‚Üê {ùúô} ‚àÄ ùëñ ‚àà {1, 2 . . . ùëÉ } ‚Üê ùë°ùë§ùëñùëõ(ùëí, ùêµ) (ùêº) ‚Üêùë§ùëíùëëùëîùëí_ùëêùëúùë¢ùëõùë° (ùêº , ùêº, . . . , ùêº} . However, this approach has the following drawbacks: ùê∫requires mining all edges inùê∏(ùê∫)that share butterÓÄûies with edgesùëí ‚àà ùê∏, which can be computationally ùëí ‚àà ùê∏can potentially exist in all subgraphsùê∫such thatùëó ‚â§ ùëñ. Therefore, creating and storing all subgraphs Firstly, for an edgeùëí ‚àà ùê∏, its link(ùëí, ùêµ)with a bloomùêµis preserved inùêºif and only if the twinùëí= ùë°ùë§ùëñùëõ(ùëí, ùêµ) ‚àà ùê∏ such thatùëó ‚â• ùëñ(alg.5, lines 19-20). Since all butterÓÄûies inùêµthat containùëíalso containùëí(sec.2.3, property 1), none of them need to be preserved inùêºifùëó < ùëñ. Moreover, if{ùëí, ùëí} ‚àà ùê∏, their contribution to the bloom numberùëò(ùêº)is counted only once (alg.5, lines -22).ÓÄÄÓÄÅ Secondly, for a space-eÓÄúcient representation,ùêºdoes not store a linkùëí, ùêµifùëí‚àâ ùê∏. However, while such an edge ùëíwill not participate in peeling ofùê∏, it may be a part of a butterÓÄûy inùêµthat satisÓÄões both preservation conditions for ùêº(sec.3.1.2). For example, ÓÄõg.2 shows the representative subgraphùê∫and BE-Index for the partitionùê∏generated by PBNG CD in ÓÄõg.3. For space eÓÄúciency, we do not store the links{(ùëí, ùêµ), (ùëí, ùêµ), (ùëí, ùêµ), (ùëí, ùêµ)}inùêº. However, the two butterÓÄûies inùêµ‚Äì(ùëí, ùëí, ùëí, ùëí)and(ùëí, ùëí, ùëí, ùëí), satisfy both preservation conditions forùêº, and may be needed when peelingùëíorùëí. In order to account for such butterÓÄûies, we adjust the bloom numberùëò(ùêº)to correctly represent the number of butterÓÄûies inùêµthat only contain edges from all partitionsùê∏such thatùëó ‚â• ùëñ(alg.5, lines 23-24).ÓÄåÓÄå For example, in ÓÄõg.2b, we initialize the bloom number ofùêµtoùëò(ùêº) =3 even thoughÓÄåùëÅ(ùêº)ÓÄå=2. Thus,ùëò(ùêº)ÓÄÄÓÄÅ correctly represents the= 3 butterÓÄûies in ùêµ, that contain edges only from ‚à™{ùê∏}. After the BE-Indices for partitions are computed, PBNG FD dynamically schedules partitions on threads, where they are processed using sequential bottom-up peeling. Here, the aggregate initial support of a partition‚Äôs edges (given by ‚ä≤‚ä≥vector) is used as an indicator of its workload (alg.5, line 4) for LPT scheduling (sec.3.1.2). 4 ANALYSIS 4.1 Correctness of Decomposition Output In this section, we prove the correctness of wing numbers and tip numbers computed by PBNG. We will exploit comparisons with sequential BUP (alg.2) and hence, ÓÄõrst establish the follwing lemmas: LÓÅ•ÓÅ≠ÓÅ≠ÓÅ° 1. InBUP, the support‚ä≤‚ä≥of an edgeùëíat any timeùë°before the ÓÄõrst edge with wing number‚â• ùúÉis peeled, depends on the cumulative eÓÄùect of all edges peeled till ùë° and is independent of the order in which they are peeled. PÓÅ≤ÓÅØÓÅØÓÅ¶.Let‚ä≤‚ä≥denote the number of butterÓÄûies inùê∫that containùëí,ùëÜbe the set of vertices peeled till timeùë°and ‚ä≤‚ä≥denote a butterÓÄûy containing ùëí and other edges {ùëí, ùëí, ùëí} such that ùëé > ùëè > ùëê (for uniqueness of representation). Ifùëí,ùëíorùëíare peeled tillùë°, corresponding to the removal of‚ä≤‚ä≥, only one of them (the ÓÄõrst edge to be peeled) reduces the support‚ä≤‚ä≥by a unit. SinceBUPpeels edges in a non-decreasing order of their wing numbers,ùúÉ< ùúÉ√ç for allùëí‚àà ùëÜ. Hence, current support (alg.2, line 11) ofùëíis given by‚ä≤‚ä≥= ‚ä≤‚ä≥‚àí1(ùëí‚àà ùëÜ or ùëí‚àà ùëÜ or ùëí‚àà ùëÜ). The ÓÄõrst term of RHS is constant for a givenùê∫, and by commutativity of addition, the second term is independent of the order in which contribution of individual butterÓÄûies are added. Therefore,‚ä≤‚ä≥is independent of the order of peeling inùëÜ.‚ñ° LÓÅ•ÓÅ≠ÓÅ≠ÓÅ° 2. Given a setùëÜof edges peeled in an iteration, the parallel peeling in PBNG CD (alg.4, lines 21-33) correctly updates the support of remaining edges in ùê∏(ùê∫). PÓÅ≤ÓÅØÓÅØÓÅ¶.Parallel updates are correct if for an edgeùëínot yet assigned to any partition,‚ä≤‚ä≥decreases by exactly 1 for each butterÓÄûy ofùëídeleted in a peeling iteration. By property 2 (sec.2.3), parallel updates are correct if this holds true for butterÓÄûies deleted within each bloom. Consider a bloomùêµ(ùëä = (ùëà , ùëâ ), ùê∏)and let‚ä≤‚ä≥‚äÜ ùêµbe a butterÓÄûy containing edges{ùëí, ùëí, ùëí, ùëí}, where ùëí= ùë°ùë§ùëñùëõ(ùëí, ùêµ)andùëí= ùë°ùë§ùëñùëõ(ùëí, ùêµ)(property 1, sec.2.3), such that‚ä≤‚ä≥is deleted in theùëópeeling iteration of PBNG CD. Clearly, neither of ‚ä≤‚ä≥corresponding to the deletion of butterÓÄûy deleted if and only if either of the following is true: (1) ùëí ‚àà ùëÜ ‚Üí (2) ùëí ‚àâ ùëÜbut in ùêµ that contains ùëí (property 1, sec.2.3). No updates from other edges are propagated to ‚ä≤‚ä≥ (3) {ùëí, ùëí} ‚àâ ùëÜ is decreased by exactly 1 when the highest indexed edge among (ùëí, ùêµ) not generate support updates corresponding to ‚ä≤‚ä≥ Lemmas 1 and 2 together show that whether we peel a set any order in PBNG CD, the support of edges with wing numbers higher than all edges in peelingùëÜ. Next, we show that PBNG CD correctly computes the edge partitions corresponding to wing number ranges and ÓÄõnally prove that PBNG FD outputs correct wing numbers for all edges. For ease of explanation, we use denote the support of a edge ùëí after ùëó Consider an edge the number of butterÓÄûies containing butterÓÄûies that contain which is a contradiction. Thus, no such PÓÅ≤ÓÅØÓÅØÓÅ¶. edges not peeled till this iteration. Clearly, be peeled in or before the butterÓÄûies that contain edges only from wing number, ùúÉ TÓÅ®ÓÅ•ÓÅØÓÅ≤ÓÅ•ÓÅ≠ 1. PBNG CD (alg.4) correctly computes the edge partitions corresponding to every wing number range. TÓÅ®ÓÅ•ÓÅØÓÅ≤ÓÅ•ÓÅ≠ 2. PBNG correctly computes the wing numbers for all ùëí ‚àà ùê∏ (ùê∫). In this case,ùëíis already assigned to a partition and updates to‚ä≤‚ä≥have no impact on the output of PBNG. ùëí‚àà ùëÜ ‚Üí ‚ä≤‚ä≥is reduced by exactly(ùëò‚àí1)via bloomùêµ, which amounts to unit reduction per each butterÓÄûy butùëí‚àà ùëÜorùëí‚àà ùëÜ ‚Üí ‚ä≤‚ä≥is decreased by exactly 1 whenùëí/ùëíis peeled. If both{ùëí, ùëí} ‚àà ùëÜ, then‚ä≤‚ä≥ and(ùëí, ùêµ)are deleted and bloom numberùëòis decreased by 1. Hence, subsequent peeling of any edges will Letùëóbe the ÓÄõrst iteration in PBNG CD that wrongly peels a set of edgesùëÜ, and assigns them toùê∏even ‚â• ùúÉ (ùëñ +1) ‚àÄ ùëí ‚àà ùëÜ. LetùëÜ‚äá ùëÜbe the set of all edges with wing numbers‚â• ùúÉ (ùëñ +1)andùëÜbe the set of ‚äÜ ùê∏(ùê∫) \ ùëÜ. LetùëÖbe the smallest range for which there exists an edgeùëísuch thatùúÉ (ùëñ) ‚â§ ùúÉ< ùúÉ (ùëñ +1), butùëí ‚àà ùê∏for . Letùëóbe the last peeling iteration in PBNG CD that assigns edges toùê∏, andùëÜ= ‚à™ùê∏denote the set of PÓÅ≤ÓÅØÓÅØÓÅ¶.From theorem 1,ùúÉ (ùëñ) ‚â§ ùúÉ< ùúÉ (ùëñ +1)for each edgeùëí ‚àà ùê∏. Consider an edge partitionùê∏and Let ùëÜ= ùê∏‚à™ ùê∏. . . ùê∏denote the set of edges peeled beforeùê∏in PBNG CD. From theorem 1,ùúÉ‚â• ùúÉ (ùëñ)for all edges ùëí ‚àà ùê∏, andùúÉ< ùúÉ (ùëñ)for all edgesùëí ‚àà ùëÜ. Hence,ùëÜwill be peeled beforeùê∏inBUPas well. Similarly, any edge in ùëÜ= ùê∏‚à™ ùê∏¬∑ ¬∑ ¬∑ ‚à™ ùê∏will be peeled afterùê∏inBUP. Hence, support updates to any edgeùëí ‚àà ùëÜhave no impact on wing numbers computed for edges in ùê∏. For each edgeùëí ‚àà ùê∏, PBNG FD initializes‚ä≤‚ä≥using‚ä≤‚ä≥, which is the support ofùëíin PBNG CD just afterùëÜis peeled. From lemma 2, this is equal to the support of ùëí in BUP just after ùëÜis peeled. Note that both PBNG FD andBUPemploy same algorithm (sequential bottom-up peeling) to peel edges inùê∏. Hence, to prove the correctness of wing numbers generated by PBNG FD, it suÓÄúces to show that when an edge inùê∏is peeled, support updates propagated to other edges in ùê∏via each bloom ùêµ, are the same in PBNG FD and BUP. (1)Firstly, every bloom-edge link(ùëí, ùêµ)whereùëí ‚àà ùê∏andùë°ùë§ùëñùëõ(ùëí, ùêµ) ‚àà ùê∏‚à™ ùëÜ, is preserved in the partition‚Äôs BE-Index ùêº. Thus, when an edgeùëí ‚àà ùê∏is peeled, the set of aÓÄùected edges inùê∏are correctly retrieved fromùêº(same as the set retrieved from BE-Index ùêº in BUP). (2)Secondly, by construction (alg.5, lines 21-22 and 23-24), the initial bloom number ofùêµinùêºis equal to the number of those twin edge pairs inùêµ, for which both edges are inùê∏or higher ranged partitions (not necessarily in same partition). Thus,ùëò(ùêº) =, which in turn is the bloom numberùëò(ùêº )inBUPjust before ùê∏is peeled. Since both PBNG FD andBUPhave identical support values just before peelingùê∏, the updates computed for edges inùê∏ and the order of edges peeled inùê∏will be the same as well. Hence, the ÓÄõnal wing numbers computed by PBNG FD will The correctness of tip decomposition in PBNG can be proven in a similar fashion. A detailed derivation for the same is given in theorem 2 of [30], 4.2 Computation and Space Complexity To feasibly decompose large datasets, it is important for an algorithm to be eÓÄúcient in terms of computation and memory requirements. The following theorems show that for a reasonable upper bound on partitionsùëÉ, PBNG is at least as computationally eÓÄúcient as the best sequential decomposition algorithm BUP. TÓÅ®ÓÅ•ÓÅØÓÅ≤ÓÅ•ÓÅ≠ 3. ForùëÉ = Opartitions, wing decomposition in PBNG is work-eÓÄúcient with computational complexity of Oùõº ¬∑ ùëö +√ç‚ä≤‚ä≥, where ‚ä≤‚ä≥is the number of butterÓÄûies in ùê∫ that contain ùëí. PÓÅ≤ÓÅØÓÅØÓÅ¶. PBNG CD initializes the edge support using butterÓÄûy counting algorithm with O(ùõº ¬∑ ùëö)complexity. Since ùúÉ‚â§ ùëö, binning for range computation of each partition can be done using anO(ùëö)-element array, such thatùëñ element in the array corresponds to workload of edges with supportùëñ(alg.4, lines 16-19). A preÓÄõx scan of the array gives the range workload as a function of the upper bound. Parallel implementations of binning and preÓÄõx scan perform O(ùëö)computations per partition, amounting toO(ùëÉ ¬∑ ùëö)computations in entire PBNG CD. Constructingùëéùëêùë°ùëñùë£ùëíùëÜùëíùë° for ÓÄõrst peeling iteration of each partition requires anO(ùëö)complexity parallel ÓÄõlter on remaining edges. Subsequent iterations constructùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°by tracking support updates doingO(1)work per update. Further, peeling an edgeùëí generatesO(‚ä≤‚ä≥)updates, each of which can be applied in constant time using BE-Index (sec.2.3). Therefore, totalÓÄê√çÓÄë complexity of PBNG CD is O‚ä≤‚ä≥+ (ùëÉ + ùõº) ¬∑ ùëö. PBNG FD partitions BE-Index requires constant number of traversals of entire set is represented in at most one partition‚Äôs BE-Index. Therefore, PBNG FD will also generate updates. Hence, the work complexity of PBNG FD is O PÓÅ≤ÓÅØÓÅØÓÅ¶. number can be cubic in the size of the vertex set. Therefore, range determination uses a hashmap with support values as the keys. The aggregate workloads of the bins need to be sorted on keys before computing the preÓÄõx scan. Hence, total complexity of range determination for tip decomposition in PBNG CD is Next, we prove that PBNG‚Äôs space consumption is almost similar to the best known sequential algorithms. TÓÅ®ÓÅ•ÓÅØÓÅ≤ÓÅ•ÓÅ≠ 5. Wing decomposition in PBNG parallelized over ùëá threads consumes O PÓÅ≤ÓÅØÓÅØÓÅ¶. O(ùëõ ¬∑ ùëá ) space consumption [66]. For peeling: (1) PBNG CD uses the BE-Index ùêº (ùëä = (ùëà , ùëâ ), ùê∏) whose space complexity is O (2)PBNG FD uses individual BE-Indices for each partition. Any bloom-edge link partition‚Äôs BE-Index. Therefore, cumulative space required to store all partitions‚Äô BE-Indices is O Thus, overall space complexity of PBNG‚Äôs wing decomposition is O TÓÅ®ÓÅ•ÓÅØÓÅ≤ÓÅ•ÓÅ≠ 6. Tip decomposition in PBNG parallelized over ùëá threads consumes O PÓÅ≤ÓÅØÓÅØÓÅ¶. counts, resulting in at most one partition (because partitions of induced subgraphs, resulting in overall O 5 OPTIMIZATIONS Despite the use of parallel computing resources, PBNG may consume a lot of time to decompose large graphs such as the trackers dataset, that contain several trillion wedges (for tip decomposition) or butterÓÄûies (for wedge decomposition). In this section, we propose novel optimization techniques based on the two-phased peeling of PBNG, that dramatically improve computational eÓÄúciency and make it feasible to decompose datasets like trackers in few minutes. 5.1 Batch Processing Due to the broad range of entity numbers peeled in each iteration of PBNG CD (sec.3.1.1), some iterations may peel a large number of entities. Peeling individual entities in such iterations requires a large amount of traversal in ùëÉ = Opartitions, tip decomposition in PBNG is work-eÓÄúcient with computational The proof is simliar to that of theorem 3. The key diÓÄùerence from wing decomposition is that maximum tip For butterÓÄûy counting, each thread uses a privateO(ùëõ)array to accumulate wedge counts, resulting to For butterÓÄûy counting and peeling in PBNG, each thread uses a privateO(ùëõ)array to accumulate wedge BE-Indexùêº. However, visualizing such iterations as peeling a single large set of entities can enable batch optimizations that drastically reduce the required computation. Tip Decomposition. Here, we exploit the fact that (per-vertex) butterÓÄûy counting is computationally eÓÄúcient and parallelizble (sec.2.1). Given a vertex setùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°, the number of wedges traversed for peelingùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°is given√ç√ç by‚àß(ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°) =ùëë. However, number of wedges traversed for re-counting butterÓÄûies for√ç remaining vertices is upper bounded by‚àß=min(ùëë, ùëë), which is constant for a givenùê∫(sec.2.1). If ‚àß(ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°) > ‚àß, we re-compute butterÓÄûies for all remaining vertices inùëàinstead of peelingùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°. Thus, computational complexity of a peeling iteration in PBNG tip decomposition is O(ùõº ¬∑ ùëö). Algorithm 6 Batch computation of support updates from peeling a set of edges ùëéùëêùë°ùëñùë£ùëíùëÜùëíùë° Wing Decomposition. For peeling a large set of edgesùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°, we use the batch processing proposed in [67]. The key idea is that when an edgeùëíis peeled, the aÓÄùected edges are discovered by exploring the neighborhood of blooms in ùëÅ(ùêº )(alg.3). Therefore, the support updates from all edges inùëéùëêùë°ùëñùë£ùëíùëÜùëíùë°can be aggregated at the blooms (alg.6, line 8), and then applied via a single traversal of their neighborhoods (alg.6, lines 10-13). Thus, computational complexity of a peeling iteration in PBNG wing decomposition is bounded by the size of BE-Index which isO(ùõº ¬∑ ùëö). While batch processing using BE-Index was proposed in [67], we note that it is signiÓÄõcantly more beneÓÄõcial for PBNG CD compared to bottom-up peeling, due to the large number of edges peeled per iteration. 5.2 Dynamic Graph Updates After a vertexùë¢(or an edgeùëí) is peeled in PBNG, it is excluded from future computation in the respective phase. However, due to the undirected nature of the graph, the adjacency list data structure forùê∫(or BE-Indexùêº) still contains edges ofùë¢(or bloom-edge links ofùëí) that are interleaved with other edges. Consequently, wedges incident onùë¢(or bloom-edge links ofùëí), though not used in computation, are still explored even afterùë¢(orùëí) is peeled. To prevent such wasteful exploration, we update the data structures to remove edges incident on peeled vertices (or bloom-edge links of peeled edges). These updates can be performed jointly with the traversal required for peeling. In tip decomposition, updating vertex support requires traversing adjacencies of the neighbors of peeled vertices. Edges to peeled vertices can be removed while traversing neighbors‚Äô adjacency lists. In wing decomposition, updating edge support requires iterating over the aÓÄùected blooms (alg.6, lines 10-13) and their neighborhoods their twins can be removed from ùëÅ 6 EXPERIMENTS In this section, we present detailed experimental results of PBNG for both tip and wing decomposition. In sec.6.1, we list the datasets and describe the baselines used for comparison. Secondly, in sec.6.2, we provide a thorough evaluation of wing decomposition in PBNG. We (a) compare PBNG against the baselines on several metrics, (b) report empirical beneÓÄõts of optimizations proposed in sec.5, (c) compare workload and execution time of coarse and ÓÄõne decomposition phases, and (d) evaluate parallel scalability of PBNG. Lastly, in sec.6.3, we report a similar evaluation of tip decomposition. 6.1 Setup We conduct the experiments on a 36 core dual-socket linux server with two Intel Xeon E5-2695 v4 processors@ 2.1GHz and 1TB DRAM. All algorithms are implemented in C++-14 and are compiled using G++ 9.1.0 with the -O3 optimization ÓÄûag, and OpenMP v4.5 for multithreading. Datasets: We use twelve unweighted bipartite graphs obtained from the KOBLENZ collection [ Repository [ publicly available real-world bipartite datasets. Table 2. Bipartite graphs with the corresponding number of buÓÄùerflies ( Baselines: We compare the performance of PBNG against the following baselines: ‚Ä¢ BUP‚Üí sequential bottom-up peeling (alg.2) that does not use BE-Index. ‚Ä¢ ParB‚Üí iteration of BUP using a parallel bucketing structure [11]. ‚Ä¢ BE_Batch dynamic deletion of bloom-edge links (sec.5). ‚Ä¢ BE_PC(for wing decomposition only) in [67]. It generates candidate subgraphs top-down in the hierarchy to avoid support updates from peeling edges in lower subgraphs (small candidate subgraphs is set to ùúè = 0.02, as speciÓÄõed in [67]. 44], whose characteristics are shown in table 2. To the best of our knowledge, these are some of the largest PÓÅ°ÓÅ≤BÓÅµÓÅ¥ÓÅ¥ÓÅ•ÓÅ≤ÓÅ¶ÓÅ¨ÓÅπ frameworkwith the best performing BatchS aggregation method [54]. It parallelizes each (for wing decomposition only)‚ÜíBE-Index assisted peeling with batch processing optimization [67], and Furthermore, to evaluate the eÓÄùect of optimizations (sec.5), we create two variants of PBNG: ‚Ä¢ PBNG- ‚Üí PBNG without dynamic graph updates (sec.5.2). ‚Ä¢ PBNG-- ‚Üí PBNG without dynamic graph updates (sec.5.2) and batch processing optimization (sec.5.1). Parameter Setting: The only user-speciÓÄõed parameter in PBNG is the no. of partitionsùëÉ. For tip decomposition, we useùëÉ =150 which was empirically determined in [30]. For wing decomposition, we measure the runtime of PBNG as a function ofùëÉas shown in ÓÄõg.5. Performance of PBNG CD improves with a decrease inùëÉbecause of reduced peeling iterations and larger peeling set (batch size) per iteration. However, for PBNG FD, a small value ofùëÉreduces parallelism and increases the workload. Thus,ùëÉrepresents a trade-oÓÄù between the two phases of PBNG. Based on our our observations, we setùëÉ =400 for graphs with<100 M edges, andùëÉ =1000 for graphs with‚â•100 M edges. We also note that the performance of PBNG is robust (within 2√óof the optimal) in a wide range ofùëÉfor both small and large datasets. 6.2 Results: Wing Decomposition 6.2.1 Comparison with Baselines. Table 3 shows a detailed comparison of PBNG and baseline wing decomposition algorithms. To compare the workload of diÓÄùerent algorithms, we measure the number of support updates applied in each algorithm [67]. Note that this may under-represent the workload ofBUPandParB, as they cannot retrieve aÓÄùected edges during peeling in constant time. However, it is a useful metric to compare BE-Index based approaches [67] as support updates represent bulk of the computation performed by during decomposition. Amongst the baseline algorithms,BE_PCdemonstrates state-of-the-art execution time and lowest computational workload, represented by the number of support updates, due to its top-down subgraph construction approach. However, with the two-phased peeling and batch optimizations, support updates in PBNG are at par or even lower thanBE_PC in some cases. Moreover, most updates in PBNG are applied to a simple array and are relatively cheaper compared to updates applied to priority queue data structure in all baselines (includingBE_PC). Furthermore, by utilizing parallel computational resources, PBNG achieves up to 38.5√óspeedup overBE_PC, with especially high speedup on large datasets. Compared to the parallel frameworkParB, PBNG is two orders of magnitude or more (up to 295√ó) faster. This is becauseParBdoes not use BE-Index for eÓÄúcient peeling, does not utilize batch optimizations to reduce computations, and requires large amount of parallel peeling iterations (ùúå). The number of threads synchronizations is directly proportional toùúå, and PBNG achieves up to 15260√óreduction inùúåcompared toParB. This is primarily because PBNG CD peels Table 3. Comparing execution time (t), number of support updates and thread synchronization (or parallel peeling iterations ùúå) for PBNG and baseline algorithms. Missing entries denote that execution did not finish in 2 days. ParB will generate same number of support updates as BUP, and parallel variants of all baselines will have same amount of synchronization (ùúå) as ParB. vertices with a broad range of support in every iteration, and PBNG FD does not require a global thread synchronization at alll. This drastic reduction in ùúå is the primary contributor to PBNG‚Äôs parallel eÓÄúciency. Quite remarkably, PBNG is the only algorithm to successfully wing decompose Gtr and De-ut datasets in few hours, whereas all of the baselines fail to decompose them in two days workload, execution time and synchronization compared to all previously existing algorithms. 6.2.2 EÓÄõect of Optimizations. Since dynamic BE-Index updates do not aÓÄùect the updates generated during peeling, PBNG and PBNG- exhibit the same number of support updates. Hence, to highlight the beneÓÄõts of BE-Index updates (sec.5.2), we also measure the number of bloom-edge links traversed in PBNG with and without the optimizations. Fig.6 shows the eÓÄùect of optimizations on the performance of PBNG. Normalized performance of PBNG- (ÓÄõg.6) shows that deletion of bloom-edge links (corresponding to peeled edges) from BE-Index reduces traversal by an average of 1 relatively inexpensive compared to support updates as the latter involve atomic computations on array elements (PBNG CD) or on a priority queue (PBNG FD). Fig.6 also clearly shows a direct correlation between the execution time of PBNG-- and the number of support updates. Consequently, the performance is drastically impacted by batch processing, without which large datasets of PBNG-- shows that both optimizations cumulatively enable an average reduction of 9 support updates and execution time of wing decomposition, respectively. This shows that the two-phased approach of PBNG is highly suitable for batch optimization as it peels large number of edges per parallel iteration. 6.2.3 Comparison of DiÓÄõerent Phases. Fig.7 shows a breakdown of the support updates and execution time of PBNG across diÓÄùerent steps, namely initial butterÓÄûy counting and BE-Index Construction, peeling in PBNG CD, BE-Index partitioning more than 60% of the support updates for most graphs. In some datasets such as Tr and Gtr, the batch optimizations drastically reduce the workload of PBNG CD, rendering PBNG FD as the dominant phase. The trends in execution time are largely similar to those of support updates. However, due to diÓÄùerences in parallel scalability of diÓÄùerent steps, contribution of PBNG FD to execution time of several datasets is slightly higher than its corresponding contribution and peeling in PBNG FD. For most datasets, PBNG CD dominates the overall workload, contributing PBNG- (PBNG without dynamic BE-Index updates) PBNG-- (PBNG- without batch processing) Fig. 6. EÓÄõect of optimizations (sec.5) on wing decomposition in PBNG. All quantities are normalized with respective measurements for PBNG with all optimizations enabled. With batch processing disabled (PBNG--), Gtr, Tr and De-ut did not finish within 2 days. Fig. 7. Contribution of diÓÄõerent steps to the overall support updates and the execution time of wing decomposition in PBNG to support updates. We also observe that peeling in PBNG CD and PBNG FD is much more expensive compared to BE-Index construction and partitioning. Fig. 8. Strong scaling of wing decomposition in PBNG. Datasets shown on the leÓÄú were decomposed in less than a minute, and on 6.2.4 Scalability. Fig.8 demonstrates the parallel speedup of PBNG over sequential execution an average 8 generally higher for large datasets (up to 11 average 2.6√ó speedup over sequential BUP, due to the large amount of synchronization. We also observe that PBNG consistently accelerates decomposition up to 18 threads (single socket), providing average 7.2√óparallel speedup. However, scaling to two sockets (increasing threads from 18 to 36) only fetches 1 on average. This could be due to NUMA eÓÄùects which increases the cost of memory accesses and atomics. This can signiÓÄõcantly impact the performance as PBNG‚Äôs workload is dominated by traversal of the large BE-Index and atomic support updates. Further, edges contained in a large number of butterÓÄûies may receive numerous support updates, which increases coherency traÓÄúc and reduces scalability. 6.3 Results: Tip Decomposition To evaluate tip decomposition in PBNG, we select 6 of the largest datasets from table 2 and individually decompose both vertex sets in them. Without loss of generality, we label the vertex set with higher peeling complexity as the other as ùëâ . Corresponding to the set being decomposed, we suÓÄúx the dataset name with ùëà or ùëâ . Table 4. Comparing execution time ( and baseline algorithms for tip decomposition. ParB traverses the same # wedges as BUP and has missing entries due to 6.3.1 Comparison with Baselines. Table 4 shows a detailed comparison of various tip decomposition algorithms. To compare the workload of tip decomposition algorithms, we measure the number of wedges traversed in traversal is required to compute butterÓÄûies between vertex pairs during counting/peeling, and represents bulk of the computation performed in tip decomposition . With up to 80 for all datasets. Contrarily, speedups are typically higher for large datasets that oÓÄùer large amount of computation to parallelize and beneÓÄõt more from batch optimization (sec.5.1). Optimization beneÓÄõts are also evident in the wedge traversal of PBNG wedges than the baselines, achieving up to 64 1105√óreduction in synchronization ( .7√óparallel speedup with 36 threads, which is signiÓÄõcantly better thanParB. Furthermore, the speedup is .8√óand 64.7√óspeedup overBUPandParB, respectively, PBNG is dramatically faster than the baselines, parallel eÓÄúciency and workload optimizations enable PBNG to decompose large datasets like EnU in few minutes, unlike baselines that take few days for the same. Quite remarkably, PBNG is the only algorithm to successfully tip decompose TrU dataset within an hour, whereas the baselines fail to decompose it in two days. We also note PBNG can decompose both vertex sets ofOrdataset in approximately half an hour, even though none of the algorithms could feasibly wing decompose theOrdataset (sec.6.2). Thus, tip decomposition is advantageous over wing decomposition, in terms of eÓÄúciency and feasibility. PBNG- (PBNG without dynamic graph updates)PBNG-- (PBNG- without batch processing) Fig. 9. EÓÄõect of optimizations (sec.5) on tip decomposition in PBNG. All quantities are normalized with the respective measurements 6.3.2 Optimizations. Fig.9 shows the eÓÄùect of workload optimizations on tip decomposition in PBNG. Clearly, the execution time closely follows the variations in number of wedges traversed. Dynamic deletion of edges (corresponding to peeled vertices) from adjacency lists can potentially half the wedge workload since each wedge has two endpoints in peeling set. Normalized performance of PBNG- (ÓÄõg.6) shows that it achieves 1.41√ó and 1.29√ó average reduction in wedges and execution time, respectively. Similar to wing decomposition, the batch optimization provides dramatic improvement in workload and execution time. This is especially true for datasets with a large ratio of total wedges with endpoints in peeling set to the wedges traversed during counting (for example, for LjU, EnU and TrU, this ratio is>1000). For instance, in TrU, both optimizations cumulatively enable 68.8√óand 47.7√óreduction in wedge traversal and execution time, respectively. Contrarily, in datasets with small value of this ratio such as DeV, OrV, LjV and EnV, none of the peeling iterations in PBNG CD utilize re-counting. Consequently, performance of PBNG- and PBNG-- is similar for these datasets. 6.3.3 Comparison of phases. Fig.7 shows a breakdown of the wedge traversal and execution time of PBNG across diÓÄùerent steps, namely initial butterÓÄûy counting, peeling in PBNG CD and PBNG FD. As expected, PBNG FD only contributes less than 15% of the total wedge traversal in tip decomposition. This is because it operates on small subgraphs that preserve very few wedges ofùê∫. When peeling the large workloadùëàvertex set, more than 80% of the wedge traversal and 70% of the execution time is spent in PBNG CD. 6.3.4 Scalability. Fig.11 demonstrates the parallel speedup of PBNG over sequential execution. When peeling the large workload vertex setùëà, PBNG achieves almost linear scalability with 14.4√óaverage parallel speedup on 36 threads, and up to 19.7√óspeedup forùê∫ùë°ùëüùëàdataset. Contrarily,ParBachieves an average 1.54√óspeedup over sequentialBUP, and up to 2.3√ó speedup for ùëáùëüùëâ dataset. Fig. 10. Contribution of diÓÄõerent steps to the overall wedge traversal and the execution time of tip decomposition in PBNG Typically, datasets with small amount of wedges (LjV, EnV ) exhibit lower speedup, because they provide lower workload per synchronization round on average. For example, LjV traverses 86 scalability of PBNG CD, which is the highest workload step in PBNG (ÓÄõg.10). Similar to wing decomposition, NUMA eÓÄùects on scalability to multiple sockets (36 threads) can be seen in tip decomposition of some datasets such as andTrU. However, we still observe 1 threads. This is possibly because most of the workload in tip decomposition is comprised of wedge traversal which only reads the graph data structure. It incurs much fewer support updates, and in turn atomic writes, compared to wing decomposition. 7 RELATED WORK Discovering dense subgraphs and communities in networks is a key operation in several applications [ containing an entity (vertex or an edge) acts as an indicator of its local density. Consequently, several recent works have focused on eÓÄúciently ÓÄõnding such motifs in the graphs [1, 16, 22, 25, 35, 54, 56, 66]. fewer synchronizations. This increases the relative overheads of parallelization and restricts the parallel 59]. Motif-based techniques are widely used to reveal dense regions in graphs [3,4,14,17,19,27,31,36,50‚Äì 63,63,65,69]. Motifs like triangles represent a quantum of cohesion in graphs and the number of motifs Nucleus decomposition is a clique based technique for discovering hierarchical dense regions in unipartite graphs. Instead of per-entity clique count in the entire graph, it considers the minimum clique count of a subgraph‚Äôs entities as an indicator of that subgraph‚Äôs density [2]. This allows mining denser subgraphs compared to counting alone [2,53]. Truss decomposition is a special and one of the most popular cases of nucleus decomposition that uses triangle clique. It is a part of the GraphChallenge [47] initiative, that has resulted in highly scalable parallel decomposition algorithms [9,21,57,62]. However, nucleus decomposition is not applicable on bipartite graphs as they do not have cliques. The simplest non-trivial motif in a bipartite graph is a ButterÓÄûy (2,2-biclique). Several algorithms for butterÓÄûy counting have been developed: in-memory or external memory [64,66], exact or approximate counting [48,49] and parallel counting on various platforms [54,64,66]. The most eÓÄúcient approaches are based on Chiba and Nishizeki‚Äôs [7] vertex-priority butterÓÄûy counting algorithm. Wang et al.[66] propose a cache optimized variant of this algorithm and use shared-memory parallelism for acceleration. Independently, Shi et al.[54] develop provably eÓÄúcient shared-memory parallel implementations of this algorithm. Notably, their algorithms are able to extract parallelism at the granularity of wedges explored. Such ÓÄõne-grained parallelism can also be explored for improving parallel scalability of PBNG. Inspired byùëò-truss, Sariyuce et al.[51] deÓÄõnedùëò-tips andùëò-wings as subgraphs with minimumùëòbutterÓÄûies incident on every vertex and edge, respectively. Similar to nucleus decomposition algorithms, they designed bottom-up peeling algorithms to ÓÄõnd hierarchies ofùëò-tips andùëò-wings. Independently, Zou [72] deÓÄõned the notion of bitruss similar to ùëò-wing. Shi et al.[54] propose the ùëÉÓÅ°ÓÅ≤ùêµÓÅµÓÅ¥ÓÅ¥ÓÅ•ÓÅ≤ÓÅ¶ÓÅ¨ÓÅπ framework that parallelizes individual peeling iterations. Chiba and Nishizeki [7] proposed that wedges traversed in butterÓÄûy counting algorithm can act as a space-eÓÄúcient representation of all butterÓÄûies in the graph. Wang et al.[67] propose a butterÓÄûy representation called BE-Index (also derived from the counting algorithm) for eÓÄúcient support updates during edge peeling. Based on BE-Index, they develop several peeling algorithms for wing decomposition that achieve state-of-the-art computational eÓÄúciency and are used as baselines in this paper. Very recently, Wang et al.[68] also proposed parallel versions of BE-Index based wing decomposition algorithms. Although the code is not publicly available, authors report the performance on few graphs. Based on the reported results, PBNG signiÓÄõcantly outperforms their parallel algorithms as well. Secondly, these algorithms parallelize individual peeling iterations and will incur heavy synchronization similar toùëÉÓÅ°ÓÅ≤ùêµÓÅµÓÅ¥ÓÅ¥ÓÅ•ÓÅ≤ÓÅ¶ÓÅ¨ÓÅπ(table 3). Lastly, they are only designed for wing decomposition, whereas PBNG comprehensively targets both wing and tip decomposition. This is important because tip decomposition in PBNG (a) is typically faster than wing decomposition, and (b) can process large datasets like Orkut in few minutes, that none of the existing tip or wing decomposition algorithms can process in several days. 8 CONCLUSION AND FUTURE WORK In this paper, we studied the problem of bipartite graph decomposition which is a computationally demanding analytic for which the existing algorithms were not amenable to eÓÄúcient parallelization. We proposed a novel parallelism friendly two-phased peeling framework called PBNG, that is the ÓÄõrst to exploit parallelism across the levels of decomposition hierarchy. The proposed approach further enabled novel optimizations that drastically reduce computational workload, allowing bipartite decomposition to scale beyond the limits of current practice. We presented a comprehensive empirical evaluation of PBNG on a shared-memory multicore server and showed that it can process some of the largest publicly available bipartite datasets two orders of magnitude faster than the state-of-the-art. PBNG also achieved a dramatic reduction in thread synchronization, allowing up to 19.7√óself-relative parallel speedup on 36 threads. There are several directions for future research in the context of this work. The proposed two-phased peeling can open up avenues for distributed-memory parallel bipartite decomposition on HPC clusters. Clusters allow scaling of both computational and memory resources, which is crucial for decomposing large graphs. To further improve the performance of PBNG, we will also explore ÓÄõne-grained parallelism, and techniques to avoid atomics and enhance memory access locality. Such system optimizations have been shown to be highly eÓÄùective in conventional graph processing frameworks [ unipartite graphs, which is an interesting direction to explore. Acknowledgement Contract Number FA8750-17-C-0086, and National Science Foundation (NSF) under Grant Numbers CNS-2009057 and OAC-1911229. Any opinions, ÓÄõndings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reÓÄûect the views of DARPA or NSF. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation here on. . This material is based on work supported by the Defense Advanced Research Projects Agency (DARPA) under