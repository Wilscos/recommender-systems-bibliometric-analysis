The Semantic Web [2] extends the World-Wide Web with machine-interpretable data. The de facto standard of this web is that data is stored and published in the Resource Description Framework [22], i.e., as a set of triples, referred to as a graph, often extended with semantic information expressed in OWL [20]. While in principle the Semantic Web is open and every agent can represent their data however they want, from the perspective of applications, or when consuming RDF data in some other way, it can often be useful to know which structural properties an RDF graph in question satisﬁes. In other words, there is a need for a declarative language for describing integrity constraints on RDF graphs. RDF graph can satisfy, e.g., the shape of “things that have a name” will be satisﬁed for those nodes that appear as the subject in a triple with predicate foaf:name. On top of a language for deﬁning such shapes, the two proposals also have a mechanism for targeting: for specifying which nodes should satisfy which shapes, e.g., to declare that “All persons should satisfy the has-a-name shape”. between shapes and concepts descriptions, as known from description logics [3]; we recently deepened this connection further [7]. Following this line of research, we formalize a SHACL schema as a tuple (Def ,T), where Def is a set of rules of the form s ← φ and T is a set of concept inclusions of the form φ ⊆ s with φ a shape (i.e., a concept description) and s a shape name. Def deﬁnes the shapes in terms of relations in the RDF graph and T contains the so-called targeting constraints. if no shape is deﬁned in terms of itself, but recently, some efforts have been made to lift this restriction, i.e., to deﬁne a supported and a stable semantics for recursive SHACL [12, 1]. ommendation only speciﬁes semantics for non-recursive SHACL; recently, some efforts have been made to allow recursive SHACL schemas. In this paper, we argue that for deﬁning and studying semantics of recursive SHACL, lessons can be learned from years of research in non-monotonic reasoning. We show that from a SHACL schema, a three-valued semantic operator can directly be obtained. Building on Approximation Fixpoint Theory (AFT), this operator immediately induces a wide variety of semantics, including a supported, stable, and well-founded semantics, related in the expected ways. By building on AFT, a rich body of theoretical results becomes directly available for the study of recursive SHACL, which can later enable an informed decision for an extension of the W3C recommendation. Several proposals have emerged to ﬁll this need, the most prominent of them being ShEx [9] and In our paper, we will build on a formalization of SHACL [12], which has revealed a striking similarity The W3C recommendation for SHACL only speciﬁes the semantics when Def is non-recursive, i.e., on Approximation Fixpoint Theory (AFT), an abstract lattice-theoretic framework originally designed to unify semantics of non-monotonic logics [14] with applications, among others, in (extensions of) logic programming, autoepistemic logic, default logic, abstract argumentation, and active integrity constraints [15, 21, 24, 19, 11, 5]. There are several advantages to deﬁning semantics of SHACL in this way: In a nutshell, our main contribution is establishing formal foundations for the study of recursive SHACL. In actual SHACL, semantics is deﬁned in terms of RDF graphs, but we recently showed how to reduce this to the logical setting [7]. As such, for the purpose of the current paper, we focus on the logical setting and take abstraction of RDF graphs. Throughout this paper, we (implicitly) ﬁx a vocabulary, i.e., a set of node names (denoted N), property names (denoted P), and shape names (denoted S). A node name c is also referred to as a constant, a property name p as a binary predicate symbol and a shape name s as a unary predicate symbol. Path expressions E and shapes φ are deﬁned as follows: where p, c, and s represent property names, node names, and shape names respectively, and n stands for non-zero natural numbers. When developing our semantics, we will treat φ ¬(¬φ to enable the comparison with existing semantics in Section 5. element JcK relation JpK of a domain and an interpretation for node and property names (not shape names). Intuitively, such an interpretation corresponds to an RDF graph. A path expression E evaluates in I to a binary relation JEK on ∆ A SHACL schema is a tuple (Def ,T) with In this paper, we put forward another principled way to deﬁne semantics of recursive SHACL, building • It is simple and straightforward: the power of AFT, comes largely from the fact that all that is required to apply it, is to deﬁne a (three-valued) semantic operator (similar to Fitting’s immediate consequence operator for logic programs [18]). In many domains (including SHACL), there is a natural choice for such an operator; AFT then immediately induces all major classes of semantics. • It provides conﬁdence: AFT guarantees that the developed semantics follow well-established principles in nonmonotonic reasoning. Even in case semantics are already deﬁned, applying AFT can be a sanity check. A striking example of this is the fact that applications of AFT uncovered some issues in the semantics of (weighted and non-weighted) Abstract Dialectic Frameworks [24, 10, 4]. • It provides access to a large body of theoretical results, including theorems on stratiﬁcation [27, 6], predicate introduction [28], and strong equivalence [25], thereby eliminating the need to “reinvent the wheel” by rediscovering these results in each of the separate domains. E ::= p | p| E ∪E | E ◦ E | E| E? φ ::= > | s | {c} | φ ∧ φ | φ ∨ φ | ¬φ | ∀E.φ | ≥E.φ | eq(E,E) | disj(E, E) | closed(Q) ∧ ¬φ) and ∀E.φ as an abbreviation for ¬ ≥E.¬φ. The reason for having them in the syntax is As usual, an interpretation I consists of (i) a set ∆, called the domain of I; (ii) for each constant c, an , and a shape φ to a subset JφKof ∆, as deﬁned in Tables 1 and 2. • Def a set of rules of the form s ← φ with s a shape name (referred to as the head of the rule) and φ a shape (the body of the rule), such that each s ∈ S appears exactly once in the head of a rule, and • T a set of (concept) inclusions of the form φ ⊆ s, with φ a shape that does not mention any shape names, and s a shape name. Table 1: Semantics of a path expression E in an interpretation I. A shape name s name that depends on s extended to an interpretation I we say that I validates with respect to (Def ,T) if Jφ K recursive case, the situation is less obvious; in Section 4, we use approximation ﬁxpoint theory to study the different semantic options that arise, but before doing so, we recall preliminaries on AFT. A complete lattice hL, ≤i is a set L equipped with a partial order ≤, such that every set S ⊆ L has a least upper bound and a greatest lower bound. A complete lattice has a least element ⊥ and a greatest element >. An operator O : L → L is monotone if x ≤ y implies that O(x) ≤ O(y). An element x ∈ L is a ﬁxpoint of O if O(x) = x. Every monotone operator O in a complete lattice has a least ﬁxpoint, denoted lfp(O). (x,y) We call (x,y) ∈ L consistent elements. The precision order on L is consistent, this means that (x,y) approximates all elements approximated by (u,v). that all the consistent ﬁxpoints studied in AFT are uniquely determined by an approximator’s restriction to L approximator of O if it is ≤ all x ∈ L). AFT studies ﬁxpoints of O using ﬁxpoints of A. Kthe reﬂexive-transitiveeq(E,E| JEK(a) = JEK(a)} If (Def , T) is a non-recursive SHACL schema, and I a graph-interpretation, then I can be uniquely Given a lattice L, AFT uses a bilattice L. We deﬁne projections for pairs as usual: (x, y)= x and = y. Pairs (x, y) ∈ Lare used to approximate elements in the interval [x, y] = {z | x ≤ z ∧ z ≤ y}. In its original form, AFT makes use of approximators, which are operators on L, but [16] showed and developed a theory of consistent approximators. An operator A : L→ Lis a consistent • The A-Kripke-Kleene ﬁxpoint is the ≤-least ﬁxpoint of A; it approximates all ﬁxpoints of O. • A partial A-stable ﬁxpoint is a pair (x, y) such that x = lfp(A(·, y)) and y = lfp(A(x, ·)), where A(·,y): L → L maps z to A(z, y)and similarly for A(x,·). • The A-well-founded ﬁxpoint is the least precise (≤-least) partial A-stable ﬁxpoint. • An A-stable ﬁxpoint of O is a ﬁxpoint x of O such that (x, x) is a partial A-stable ﬁxpoint. Emden and Kowalski’s immediate consequence operator T valued extension Ψ For the rest of this paper, we ﬁx a SHACL schema (Def , T) and a graph-interpretation I. We already mentioned that if Def is non-recursive, it uniquely induces a complete interpretation I constraints in T are to be veriﬁed. When Def is recursive, however, the situation becomes more complex. On the one hand, there is a range of possible semantics dealing with recursion. On the other hand, some of the semantics yield not a single interpretation I interpretation. This will give us a choice between brave and cautious validation; the focus of this paper is on the treatment of negation, but we brieﬂy discuss brave and cautious validation below. is the lattice L N ∪ P, or in other words, the set of interpretations that expand I. This set is equipped with the standard truth order, I the interpretation of the shapes. In analogy with logic programming, its deﬁnition is straightforward: it maps the interpretation I such pairs correspond one-to-one to three-valued interpretations that assign each s ∈ S a function ∆ → {t,f,u}, mapping a to t if a in JsK what is certainly true and I three-valued interpretations. Kleene’s truth tables, as also used in previous studies of recursive SHACL [12, 1]; for completeness, this is included in Table 3. This table makes use of the truth order ≤ and the negation on truth values deﬁned as usual: ¬t = f; ¬f = t; ¬u = u. These deﬁnitions allow reconstructing all major logic programming semantics by taking for O Van To apply AFT, the ﬁrst step to take is to determine a suitable lattice. In our case, the obvious candidate (I)(s) = Jφ K. With the lattice hL,≤i, elements of Lare pairs I = (I,I) of two interpretations with I≤I; We can evaluate a shape φ in a three-valued interpretation I with a straightforward extension of ≥E.φf if ]{b ∈ JEK(a) | JφK(b) ≤u} < n, eq(E,E,E)K; f otherwiseab disj(E,E) t if a ∈ Jdisj(E,E)K; f otherwise Once a three-valued evaluation of shapes is deﬁned, an approximator is obtained directly: like the operator, the approximator updates the value of each shape symbol according to its deﬁning rule: it maps I to Ψ Theorem 4.1. Ψ The ﬁrst was our choice of order on the lattice. We opted here for the truth order, but its inverse would also have been a possible choice. Several of the semantics induced by AFT aim to minimize models in the chosen order for reasons of groundedness [8], e.g., if s has s ← s as deﬁning rule, in stable and wellfounded semantics, our chosen order would result in no nodes satisfying s. The second choice we made is which three-valued truth evaluation to use; we opted for the most obvious choice: a direct extension of Kleene’s three-valued truth tables, which was used in other studies of recursive SHACL as well [12, 1]. Given these choices, models of the different types (stable, well-founded, ... ) are deﬁned by AFT, and hence semantics for brave and cautious validation under of each semantics are established. Deﬁnition 4.2. Let σ ∈ {KK, WF} and let I be the σ -model. We say that I cautiously (resp. bravely) σ-validates with respect to (Def ,T) if Jφ ∧ ¬sK Let σ ∈ {St,Sup} and let M be the set of σ-models. We say that I cautiously (resp. bravely) σ-validates with respect to (Def ,T) if Jφ ∧ ¬sK Example 4.3. Consider binary predicates closeTo, hasSymptoms, and vaccinated and an interpretation I with domain {a, b, c, d,e, f , Pﬁzer,Cough}, where a, . . . , f represent people (divided in two cliques of three “close” friends); one person (c) is vaccinated and one person (d) shows Covid symptoms. This interpretation is visually depicted in Fig. 1. We deﬁne two shapes: the shape of people at risk (those who (i) are not vaccinated and (ii) have symptoms or are close to someone at risk) and the shape of people who can go to ofﬁce (those who are not at risk), as formalized below: For this set of shape deﬁnitions, the unique stable model equals the well-founded model and states that d, e, and f are at risk, while a, b, and c can work. In the Kripke-Kleene model, d, e, and f are again at risk, c is not at risk (and hence can work), but for a and b it is unknown whether they are at risk. There Corman et al. [12] already deﬁned a supported semantics and Andres¸el et al. [1] a stable semantics for and to the semantics induced by AFT, e.g., as AFT-stable. Both of them focus on brave validation, but Andres¸el et al. also mention the possibility of cautious validation. The main results on correspondence between the semantics are summarized here. operator Ψ showed that in fact, by deﬁning the approximator Ψ Since Corman et al. also characterized supported models as ﬁxpoints of Ψ semantics and theirs coincide. (I ) where for each shape s ∈ S deﬁned by the rule s ← φ , Ψ(I )(s) = Jφ K. At this point, AFT dictates what the supported models (ﬁxpoints of T), (partial) stable models -stable ﬁxpoints), well-founded model (Ψ-well-founded ﬁxpoint), and Kripke-Kleene model -KK ﬁxpoint) of Def are. It is worth stressing that to arrive to this point, we made two choices. Let us illustrate the differences between the various types of models on a small example. In fact, Corman et al. [12, Deﬁnition 5] already deﬁned the three-valued immediate consequence Theorem 5.1. I CRS-validates (Def , T) if and only if I bravely Sup-validates (Def , T). of level mappings. Deﬁnition 5.2 ([1]). Let I ples in {(φ , a) | Jφ K (ii) level(φ for which there are n elements b and (iv) level(∀E.φ,a) = max({level(φ,b) | (a, b) ∈ JEK level(s,a) > level(φ Deﬁnition 5.3. Def is in shape normal form if all rules in Def have one of the following forms: Theorem 5.4. If I shape normal form, the converse also holds. terms of the standard three-valued truth evaluation) versus a syntactic (the level mappings are deﬁned in terms of the syntactic structure of the shapes) treatment of negation and is illustrated in the next example. Example 5.5 (Example 4.3 continued). Suppose that in our same interpretation, we wish to deﬁne a shape that identiﬁes possible superspreaders. To do this, we say that a person is “safe” if they are vaccinated, or in contact with at most 1 non-safe person. This can be formalized as: Where ≤ model in which a, b, and c are safe, but d, e, and f are not. However, there are two ACROSS-stable models: the one mentioned above, and one in which everyone is safe, including the three-clique of When Corman et al. [12] deﬁned the supported model semantics for SHACL, they showed how to translate actual SHACL expressions (as speciﬁed by the W3C recommendation) into logical expressions in a language akin to description logics. For studying recursive SHACL expressions, they even already deﬁned the operator Ψ this operator is indeed an approximators and applying AFT. As such, we believe this paper establishes strong and formal foundations for the study of recursive SHACL. Indeed, AFT does not just dictate how the semantics are to be deﬁned, but immediately provides guarantees such as stratiﬁcation and predicate introduction results that can be instrumental when developing concrete validators for recursive SHACL: we immediately obtain results about which transformations can safely be applied to our theories. to realize though, that if one wants to view Def as an (inductive) deﬁnition of the shapes, it has been The situation is somewhat different for stable semantics, which Andres¸el et al. [1] deﬁned in terms ∨φ,a) = min{level(φ,a) | i ∈ {1, 2}∧JφK(a) = t}, (iii) level(≥E.φ) is the smallest k ≥ 0 A supported model Iis an ARCOSS-stable model if there exists a level assignment for Isuch that For the correspondence in case of stable semantics, we recall a normal form of Andres¸el et al. [1]: The difference between our stable semantics and the ACORSS-stable semantics is a semantic (in is an abbreviation for ¬ ≥. With the interpretation of Fig. 1, there is a single AFT-stable Our results have been presented without taking a stance on the choice of semantics. It is important argued repeatedly that the well-founded semantics correctly formalizes this [17]. Under the well-founded semantics, SHACL integrates ﬁrst-order constraints (of a restricted form) with inductive deﬁnitions and aggregates, and hence can be seen as a fragment of the language FO(ID, Agg), the formal foundation of the IDP language [13]. It is a topic for future work to investigate whether this can be exploited for either extending SHACL, or for developing alternative validation mechanisms, building on IDP. Acknowledgements This research was supported by the Flemish Government in the “Onderzoeksprogramma Artiﬁci