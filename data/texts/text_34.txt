Abstract—Programmers often use Q&A sites (e.g., Stack Overﬂow) to understand a root cause of program bugs. Runtime exceptions is one of such important class of bugs that is actively discussed on Stack Overﬂow. However, it may be difﬁcult for beginner programmers to come up with appropriate keywords for search. Moreover, they need to switch their attentions between IDE and browser, and it is time-consuming. To overcome these difﬁculties, we proposed a method, “Q&A MAESTRO”, to ﬁnd suitable Q&A posts automatically for Java runtime exception by utilizing structure information of codes described in programming Q&A website. In this paper, we describe a usage scenario of IDE-plugin, the architecture and user interface of the implementation, and results of user studies. A video is available at https://youtu.be/4X24jJrMUVw. A demo software is available at https://github.com/FujitsuLaboratories/Q-A-MAESTRO. While developing software, debugging is an important process. According to a survey [1], 50% of the total time of programmers is spent for debugging. In particular, runtime exceptions have a signiﬁcant impact on system availability and crashes [2]. As of March 2020 , Stack Overﬂow [3] has more than 190,000 posts related to Java runtime exception, which is 7% of Java posts. A study [4] collected mouse events to ﬁnd out how programmers spend their time. It found that average 43 percent of the total time was used for searching solutions to ﬁx bugs. Therefore, in order to improve the productivity of programmers, we need to help them do those time-consuming tasks quickly. In our research paper [5], we proposed a method “Q&A MAESTRO” to automatically suggest Q&A posts for Java runtime exceptions. (Note: In this paper, we have changed the name of the technique proposed in the research paper [5] from “MAESTRO” to “Q&A MAESTRO” due to the trademark reason.) It has three features as follows. It achieved better suggestion quality compared to other studies. user code to decide the relevancy of the post Fujitsu Research of America, Inc. answer code snippets are used to identify the buggy lines in question code snippets, and ignore other lines This paper introduces the implementation of Q&A MAESTRO. The main contribution is as follows. lems without leaving IDE to Web browser for search in Fig. 1 so that analysis and search tasks are executed on the server side plaining feedbacks from the trial users The organization of this paper is as follows. Section II introduces researches related to Q&A post suggestions. Section III summarizes our proposed method in our research paper. Section IV describes the usage scenario of Q&A MAESTRO and its implementation. Section V summarizes the experiments in our research paper at ﬁrst, and then, describes the user studies in two different groups in our company. Section VI concludes the paper. Several methods have been proposed for Q&A post suggestions for bug ﬁxing. Prompter [6] proposed a method to ﬁnd Q&A posts which are similar to the piece of code being edited in the IDE. This method relies on extracting important keywords for search, not taking into account the structural information of source codes in the post. FaCoY [7] also proposed a method to search code in Q&A articles similar to the given code snippet. It still focuses on the natural language description in question posts and corresponding answer posts. Q&A MAESTRO is different from the above studies because we utilize structural information in the codes in Q&A posts. Deckard [8] proposed a code clone detection method for ﬁnding similar codes. It ﬁnds not only exactly the same codes, but also similar codes. It uses AST (Abstract Syntax Tree) for analyzing codes, but our method uses APG (Abstract Program Graph) generated by abstracting AST to realize more accurate suggestions. This section summarizes our proposed method in our research paper [5]. The method can be divided into two phases: ofﬂine mining/analysis and real-time matching. The overall ﬂow of the method is shown in Fig. 2. In both phases, any codes are converted to tree structures for analysis. While AST is common for program analysis, our method uses APG generated by abstracting AST. A. APG (Abstract Program Graph) 1) About APG: Many existing studies related to software engineering use AST to analyze codes. However, when ﬁnding similar code from Q&A site, there is no need to focus too much on grammatical differences. Therefore, we consider that more abstracted structure is more suitable for Q&A suggestion. APG is designed to satisfy the above-mentioned properties. It is generated from AST through the following processes. single node “x=1”, then x is regarded as integer.) type (e.g., “for”, “while” and “for-each” can be “loop”) “userClass1” Please also see the illustrated example of APG in our research paper [5]. 2) APG structural alignment: The goal of this process is to ﬁnd the structural correspondence between two APGs. Since APG is a tree structure, the minimum tree edit distance can be calculated. To modify one tree structure into another, you can consider four operations: INSERT, DELETE, UPDATE and MATCH. MATCH nodes are the corresponding ones in the two trees. Each operation can have cost, for example, (INSERT, DELETE, UPDATE, MATCH) = (1, 1, 1, 0). Then, we can ﬁnd a set of operations whose total cost is the smallest. Such operations are called the minimum tree edit distance. You can ﬁnd APG structural alignment based on MATCH nodes. 3) Code similarity matching: The goal of this process is to calculate similarity score between two APGs. The score is the weighted sum of some sub-scores. One of the sub-scores is construct similarity, which is the number of MATCH nodes in APG structural alignment. Please refer to our research paper for further details. In this phase, we collect buggy code snippets from Q&A sites and store them in Exception scenario patterns (ESP, pruned APG) so that we can utilize the information in the recommendation phase. In Q&A site, users can post multiple answers to one question post. Especially in Q&A site for developers, like Stack Overﬂow, programmers can include codes in both question and answer posts. Questioners usually do not know where in their codes is buggy. Therefore, they tend to submit codes which are not related to an error. If a search is performed on the entire code in the posts, ones unrelated to the error may be proposed. To overcome this difﬁculty, we need to localize the buggy part of the code in a question post. We can achieve this by Failure Scenario Localization (FSL), which consists of three steps as follows. The basic idea of FSL is to ﬁnd similar but not identical parts in Q&A codes, and such part in the question code should be buggy. 1) Convert a question code and answer code into APGs: AP Gand AP Grespectively 2) Perform APG structural alignment between AP Gand AP G 3) Only edited parts are kept in AP G, and other nodes are removed We refer to such pruned APG as ESP. ESPs are stored in the database. This phase is performed when users ﬁnd runtime exceptions in their code. The inputs of this phase are as follows. {...}}) Q&A MAESTRO provides relevant Q&A posts by performing code similarity matching between ESPs stored in the database and APG converted from the input code causing the runtime exception. This phase performs the following process. First, we translate the function containing the erroneous line into APG: AP G. Next, we identify the ESPs corresponding to the same exception of the input. Then, we recommend some of these ESPs which have high similarity score with AP G. One usage scenario of Q&A MAESTRO is IDE plugin. The UI of the plugin is shown in Fig. 3. When an error occurs, a console window on the bottom shows a stack trace of the error as (a) in Fig. 3. You can get Q&A posts automatically by just pressing the search button on the console menu (b). The source code ﬁle containing the error is opened in the editor automatically (c), and the erroneous lines are highlighted (d). The recommended Q&A posts are provided as a web page and shown in a new IDE tab (e). The advantage of this usage scenario is that the search is highly automated. In addition, the search results are also displayed in the IDE, so you can minimize context switching between IDE and Web browser for keyword search. 1) Overall system architecture: We developed a prototype software for the usage scenario mentioned above. As in Fig. 1, it consists of two parts: server and IDE plugin. The prototype comes with an Eclipse plugin. By dividing the system into server and client, clients do not need to hold the vast amount of data retrieved from Stack Overﬂow. Each IDEs needs each implementation, so the server provides a RESTful API for easy implementation. In the server side, JavaParser [9] is used for analyzing Java code, and APTED [10] is used for calculating minimum tree edit distance. The indexed Q&A posts are retrieved from Stack Overﬂow [11]. As alternative for users not using Eclipse, we also implemented stand-alone Web interface on the server. 2) One click search: To realize one click search, we derive the inputs described in Sec.III-C in the following way. stack trace, we derive it from there. Exception message is ignored. us numerous ﬁle names and erroneous lines in its frames, we identify the proper ones from the ﬁrst frame pointing to a user-owned code (not linked libraries), since we are not interested in identifying error in libraries developed by someone else. In case the above method does not ﬁnd appropriate Q&A posts, we prepared alternative search functions in which we can manually select a speciﬁc stack frame, or a line of code and exception name. 3) Result UI: The search results are shown in a summarized way as in Fig. 4, not directly showing original Stack Overﬂow web page. It shows a question post, one recommended answer post, and colored difference between the codes in the question and the answer. It can show us up to ten results so that users can determine the right answer from them. This section summarizes the experiments conducted in our research paper [5]. It compares Q&A MAESTRO with three existing studies: Prompter [6], FaCoY [7], Deckard [8], and keyword search. The suggested Q&A posts are from Stack Overﬂow [11]. We used 78 open source codes in GitHub as a dataset [12], which causes runtime exceptions. Q&A MAESTRO suggested useful articles for 70% of the dataset, that was better than the others. You can ﬁnd the exception names, the number of stored ESPs and the detailed results in the research paper. The execution time of Q&A MAESTRO in the above experiment was about 2.6 sec on median (average = 76 sec). Please note that the implementation used in the research paper was a preliminary version. In the user studies, we implemented the system shown in IV-B, and its execution time was 0.2 sec on median (average = 0.45 sec). It is fast enough for interactive problems solving between users and Eclipse IDE. To survey the usability of the IDE plugin, we asked two groups in our company to use it in their own programming tasks for about two weeks. We distributed the plugin to users, and they access to the central server we managed. We asked them to complete an open-ended questionnaire on the three points: (1) Usability of the plugin (2) Accuracy of the suggested posts (3) Readability of the displayed results. The ﬁrst group is a team of ten programmers developing in-house systems. All of them are expert Java programmers and have several years of experience using Java in their work. We received the feedbacks from them as shown in TABLE I. The second group is a Java programming training class for new employees. There are about 20 students, and most participants are Java or programming beginners. We received feedbacks as in TABLE II. Both groups were generally satisﬁed with the suggestion accuracy. Q&A MAESTRO mainly targets bugs due to lack of knowledge, so it worked properly for such bugs (e.g., lack of an argument for toArray function). However, since NullPointerException can have variety of root causes, it is quite difﬁcult to suggest appropriate posts for this exception. Moreover, Q&A MAESTRO has difﬁculty in suggesting good posts for logical errors (e.g., ArrayIndexOutOfBounds, NegativeArraySize). The plugin was easy to use, so no one was confused about how to use it. However, the expert programmers asked additional features, e.g., automatic bug-ﬁx. On the other hand, the beginners were satisﬁed with the plugin’s functionality, but requested more detailed Q&A posts. As stated above, both the experts and the beginners were generally satisﬁed with the plugin’s usability and result UI. We also found that experts and beginners have different expectations for the plugin. Experts do not have problems with Q&A post searching, and want advanced features such as automatic correction. While the IDE plugin contributed to shorten the time spent for debugging, most of them thought its effectiveness was marginal. On the other hand, beginners have problems for ﬁnding and reading Q&A posts, and actually realized the reduction of debugging time. Therefore, the plugin is helpful for beginners especially. First, this paper explains our research paper [5] which proposed a method “Q&A MAESTRO” to automatically ﬁnd relevant Q&A posts to a Java runtime exception. Next, we propose IDE plugin as a use case of Q&A MAESTRO and describe the software architecture and its implementation. Finally, we explain the user studies in two groups, and introduce feedbacks from them. We ﬁnd that our tool is helpful especially for beginners. There are several challenges to make Q&A MAESTRO more helpful. The desirable Q&A post should include both a cause of an error and how-to-ﬁx. Because Q&A MAESTRO recognizes the differences in Q&A codes, it has potential to be able to suggest posts including how-to-ﬁx. On the other hand, the cause of the error is often explained in natural language, and it cannot be derived by code structure analysis. For a future work, we are planning to enhance Q&A Maestro by adding features such as automated ﬁx. Moreover, Q&A MAESTRO just suggests Q&A posts, and the experts requested additional features like auto ﬁx. This can be a future work.