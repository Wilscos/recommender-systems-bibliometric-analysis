Abstract guage for validating RDF data, by verifying certain shapes on graphs. Previous work has largely focused on the validation problem and the standard decision problems of satisﬁability and containment, crucial for design and o ptimisation purposes, have only been investigated for simpliﬁed versions of SHACL. Moreover, the SHACL spe ciﬁcation does not deﬁne the semantics of recursively-deﬁned constraints, which led to several alternative recurs ive semantics being proposed in the literature. The interaction between these diﬀerent semantics and important de cision problems has not been investigated yet. In this article we provide a comprehensive study of the diﬀerent features of SHACL, by providing a translation to a new ﬁrst-order language, c alled SCL, that prec isely captures the semantics of SHACL. We also present MSCL, a second-order extension of SCL, which allows us to deﬁne, in a single formal logic framework, the main recursive semantics of SHACL. Within this language we also provide an eﬀective treatment of ﬁlter constraints which are often neglected in the related literature. Using this logic we provide a detailed map of (un)decidability and complexity results for the satisﬁa bility and containment decision problems for diﬀerent SHACL fragments. Notably, we prove that both problems are undecidable for the full language, but we present decidable combinations of interesting features, even in the face of recursion. Shapes Constraint Language (SHACL, for short) [ language for validation of data in the form of RDF graphs [9] and is quickly beco ming the established technology. Similar to ontology languages like OWL [ seen as a language that strictly imposes a schema on graph data models, such a s RDF, which are inherently schemaless. Unlike ontology languages, SHACL focuses more on the structural prop erties of a graph rather than the semantic ones, and it is not intended for inference. A SHACL shape graph, which we will call SHACL documen t in this The Shapes Constraint Language (SHACL) is the recent W3C recommendation lan- Data validation is the process of ensuring data is clean, correct, and useful. The paper, validates an RDF graph by evaluating it against a set of constraints. In SHACL, constraints are modelled as a set of shapes which, intuitively, deﬁne the structure that certain entities in the graph must conform to. On the one hand, several important theoretical properties of the lang uage have not been studied. Among thes e are the decidability and complexity of diﬀerent problems, including satisﬁability and containment of SHACL documents. These problems are the main focus of this work. On the other hand, the W3C speciﬁcation does not deﬁne the semantics of SHACL in its full generality, since it does not describe how to handle recursive constraints. Recent work [ der to formally deﬁne a recursive semantics; the same work also studied the complexity of the validation pr oblem. Alternative recursive s e mantics for SHACL have been further suggested in [ This is an important contribution on its own, as it oﬀers a standard and well-established modelling of the language, where SHACL documents are translated into logical sentences that are interpreted in the usual way. This makes SHACL semantics easier to understand and study compared to existing approaches that rely on aux iliary ad hoc constructs and functions . In particular, [ an assignment of SHACL shapes to data nodes. This assignment captures which shape s are satisﬁed/violated by which nodes, while at at same time the target nodes of the validation proce ss are veriﬁed. As [ consider partial assignments, where the truth value of a constraint at so me nodes may be left unknown. In addition, [ validation, to verify the target nodes during the validation process. Deciding between partial or total as signments, and between brave or cautious validations gives rise to four diﬀerent semantics for SHACL, each with its own deﬁnition of validation. Using our logical approach we are able to capture all four semantics in a clear and uniform way, providing for a better understanding of SHACL features and taking advantage of the rich ﬁeld of computational logic. Despite its ongoing wides pread adoption many aspects of SHACL remain unexplored. In this article, we extend [22] to capture SHACL semantics using mathematical lo gic. Our contributions are the following: • We prove that all four major semantics of SHACL coincide for non-recursive documents and that partial-assig nment semantics reduces to the total-assignment one for all SHACL documents. (Section3) • We formalise non-recursive SHACL semantics by translating to a novel fragment of ﬁrst-order logic e xtended with counting quantiﬁers and a transitive closure operator; we call this logic SCL for Shapes Constraint Logic. The provided translation from SHACL to SCL is actually an one-to -one correspondence between these languages and we have identiﬁed eight prominent SHACL features that translate to particular restrictions of SCL. In eﬀect, SCL is the logical counterpart of SHACL. (Section4) • We ex tend SCL into a fragment of monadic second-order logic, called MSCL, that intuitively allows us to impose conditions over the space of all possible assignments and captures all four major recursive SHACL semantics. In particular, we reduce 2. Preliminaries hs, p, oi identiﬁes an edge with label p, called predicate, from a node s, calle d subject , to a node o, called object. Graphs in this article are represented in Turtle syntax [ using common XML namespaces, such as sh to refer to SHACL terms. Usually, in the RDF data model [9], subjects, predicates, and objects ar e deﬁned over diﬀerent but overlapping domains. For example, while IRIs can occupy any position in an RDF triple, literals (representing datatype values) can only appear in the object position. These diﬀerences are not central to the problem discussed in this article, and thus, for the sake of simplicity, we will assume that all e lements of a triple are drawn from a single and inﬁnite domain. This assumption actually corresponds to what is known in the literature as generalised RDF [ atom R(s, o) as a shorthand for the tuple hs, R, oi, and call R a graph relation name. We use a minus sign to identify the inverse role, i.e., we write R also consider the distinguished binary relation name isA to represent class membership triples, that is, we write hs, rdf:type, oi as isA(s, o). 3. Shapes Constraint Language: SHACL guage to deﬁne formal constraints for the validation of RDF graphs [ introduce the main elements of its syntax, and explain the role they play in the validation process. We then discuss assignments [ which nodes in a graph satisfy or violate which c onstraints. Assignments have been used to formally deﬁne SHACL semantics and this can non-ambiguously happen for the nonrecursive case. For recursive SHACL, the speciﬁc ation leaves the semantics o f recursive constraints open for interpretation, and there have been more than one ways to extend the ass ignments-based semantics for this. We review and discuss the four major extended SHACL satisﬁability and containment under all semantics to the MSCL satisﬁability problem. We also demonstrate how our logical framework generalises previo us languages designed to model SHACL. (Section5) • We pay particular a ttention to SHACL ﬁlters (e.g., constraints on the value of particular elementary datatyp es), which have not been previously addressed in the literature, and provide a corresponding axiomatisation in MSCL (Section6). • Finally, we turn our fo cus to SCL sa tis ﬁability, which corresponds to existential MSCL and can express several of SHACL de cision problems. In particular, we study the ﬁnite/unrestricted satisﬁability and containment problems for nonrecursive documents and the ﬁnite/unrestricted satisﬁability for recursive SHACL under brave semantics. We explore the interaction of the main language features we have identiﬁed and create a detailed map of decidability and complexity results for many interesting fragments. In general, satisﬁability and containment for the the full logic are undecidable. However, the base language has an ExpTime-complete satisﬁability and containment problem. (Section7). With the term graph we implicitly refer to a set of triples, where each single triple In this section we describe the Shapes Constraint Language (SHACL), a W3C lansemantics that have been proposed in the literature to handle recursive constraints. Notably, in the absence of recursion, we show the collapse of all four extended semantics into the same one. We also show that two of these extended semantics can be considered a special case of the other two, by proving a reduction from partial assignment to total assignment semantics (deﬁned later in this section). Having formalise d SHACL semantics, we de ﬁne the satisﬁability a nd containment decision problems for SHACL documents. 3.1. SHACL Syntax and (2) a SHACL document M that deﬁnes the conditions against which G must b e validated. The SHACL speciﬁcation deﬁnes the output of the data validation process as a validation report, detailing all the violations of the conditions set by M that were found in G. If the violation report contains no violations, a graph G is valid w.r.t. a SHACL document M. Determining whether a graph is valid w.r.t. a SHACL document is the decision problem called validation. a valid graph should have, by deﬁning a set of constraints that are evaluated against a set of nodes, known as the target nodes. Forma lly, a shape is a tuple hs, t, di deﬁned by three components: (1) a shape name s, which uniquely identiﬁes the shape; (2) a target deﬁnition t which is a set of target declarations; each target declaration can be represented by a unary query and identiﬁes the RDF nodes that must satisfy the constraints d; (3) a set of constraints which are use d in conjunction, and hence hereafter re ferred to as the single constraint d. The SHACL speciﬁcation deﬁnes several type s of constraints, called constraint components. The sh:datatype component, for example, constraints an RDF ter m to be an RDF literal o f a particular datatype. Without loss of generality, we assume that shape names in a SHACL document do not occur in other SHACL documents or graphs. As we formally deﬁne later, a graph is valid w.r.t. a document whenever all constraints of all shapes in the document are satisﬁed by the target nodes of the corresponding shapes. nodes to be validated that do not actually appear in the graph under consideration. Given a document M and a graph G, we denote by nodes(G, M) the set of nodes in G together with those referenced by the node target declarations in M. In the absence of a document, we use nodes(G) to denote the nodes of a graph G. With shapes(M) we refer to all the shape names in a document M . When it is clear for the context, we might use a shape name s either to refer to the name itself or to the entire shape tuple. of that shap e . We ca ll this a shape reference. L et S occurring in a constraint d of a shap e hs, t, di; these are the directly-referenced shapes of s. Let S of the shap es in S is said to be recursive if it contains a recursive shape, and non-recursive otherwise. For simplicity, all SHACL documents we consider in this work do not contain the sh:xone constraint over shape references, which models the logica l ope rator of exclusive or . Any SHACL document, in fact, can be linearly transformed into an equivalent document that does not contain the sh:xone operator using a standard logical transfo rmation. The Data validation in SHACL requires two inputs: (1) an RDF graph G to be validated A SHACL document is a set of s hapes. Shapes essentially restrict the structure that It is worth noting that one type of SHACL target declara tion might refere nc e speciﬁc Constraints can use the name of a shap e as a short-hand to refer to the constraints be the set of shapes in Sunion the directly-referenced shapes of the constraints intuition behind this transformation is that an sh:xone deﬁned over shape s s is equivalent to an sh:xone between two shapes s whose constraint is the sh:xone of shapes s two shapes can be linearly transformed into an equivalent expression that uses only conjunctions, disjunctions, and the negation operators. 3.2. Semantics of Non-Recursive SHACL that a node n is in the target of t w.r.t. a graph G. The target de claration t might be empty, in which case no node is in the target of t. To formally discuss about nodes satisfying the constraints of a shape we need to introduce the concept of assignments [ Intuitively, an assignment is used to keep track, for any RDF node, of all the shapes whose constraints the node satisﬁes and all of those that it does not. Deﬁnition 1. Given a graph G, and a SHACL document M , an assignment σ for G and M is a function mapping nodes in nodes(G, M), to subsets of shape literals in shapes(M) ∪ {¬s|s ∈ shapes(M)}, such that for all nodes n and shape names s, σ(n) does not contain both s and ¬s. all graph nodes to all document shapes or their negations. In fact, there mig ht exist node-shape pairs (n, s) for which neither s ∈ σ(n) nor ¬s ∈ σ(n). This is the reason why sometimes assignments are called partial assignments, as opposed to total assignments which have to associate all node s with all shape names or their neg ation. Deﬁnition 2. An assignment σ is total w.r.t. a graph G and a SHACL document M if, for all nodes n in no des(G, M) and shapes hs, t, di in M, either s ∈ σ(n) or ¬s ∈ σ(n). tively, the set of assignments, and the set of total assignments for G and M . Trivially, a shape, the outcome does not only depend on d, n, and G, but it might also depend, due to shape references, on whether other nodes satisfy the constraints of other shapes. This latter fact can be encoded in an assignment σ. The authors of [ the evaluation or conformance of a node n to a constraint d w.r.t. a graph G under an assignment σ as JdK Kleene’s logic: True, False, or Un deﬁned. If JdK node n conforms (resp., does not conform) to constraint d w.r.t. G under σ. Intuitively, the evaluation of JdK the ﬁrst veriﬁes conditio ns on G, such as the existence of certain triples . The second part examines other node-shape pairs that d itself is listing for conformance and, instead of triggering subsequent evaluation, checks whether their conformance is c orrectly encoded in σ. Since – in general and for arbitrary SHACL documents that might be recursive – σ is partial, it might be that JdK the outcome of the graph validation process (see Section validation depends on the existence of an assignment such that even if it is Undeﬁned for certain nodes, at least is consistent (as deﬁned below) and is True for all target nodes on A target declara tion t is a unary query over a graph G. We denote with G |= t(n) Notice that given a document and a graph, an assignment does not have to associate For any graph G and SHACL document M, we denote with Aand A, respec - ⊆ Aholds. When trying to determine whether a node n of a graph G satisﬁes a constraint d of the constraints of the shapes that describe these nodes as targets . Such assignments are known as faithful assignments [ documents there is a unique faithful assignment which is total and for which Undeﬁned conformance never appears. Deﬁnition 3. For all graphs G and SHACL documents M, an assignment σ is faithful w.r.t. G and M , denoted by (G, σ) |= M, if t he following two conditions hold true for any shape hs, t, di in shapes(M) and node n in nodes(G, M): (2) if G |= t(n) then s ∈ σ(n). indeed correct; while condition (2) ensures that the as signment agrees with the target deﬁnitions. The existence of a faithful assignment is a necessary and suﬃcient condition for validation of non-recursive SHACL do cuments [ Deﬁnition 4. A graph G is valid w.r.t. a non-recur sive SHACL document M if there exists an assignment σ such that (G, σ) |= M. requirement that all students must have at least one supervisor from the same faculty. The sha pe with name :studentShape has class :Student as a target, meaning that all members of this class must satisfy the constraint of the shape. The constraint definition of :studentShape requires the non-satisfaction of shape :disjFacultyShape, i.e., a node satisﬁes :studentShape if it doe s not satisfy :disjFacultyShape. The :disjFacultyShape shape states that an entity has no faculty in common with any of their supervisors (the sh:path term de ﬁnes a property chain, i.e., a compo sition of roles :hasSupervisor and :hasFaculty). A graph that is valid with res pects to these shapes is provided in Figure be made invalid by changing the fa culty of :Jane in the last triple to a diﬀerent value. for all other semantics that allow r ecursion. For those cases, however, we will want to consider additional assignments where the ﬁrst property of Deﬁnition necessarily the second, i.e., assignments that agree with the constraint deﬁnitions, but not necessarily the target deﬁnitions of the shapes. In or de r to do this, we will remove the Intuitively, condition (1) ensures that the evaluation described by the assignment is An example SHACL document is shown in Figure1. This example captures the As we will see later, the existence of a faithful assignment is also a necessary condition targets from a document and look for faithful as signments against the new document, since condition (2) of Deﬁnition 3 is trivia lly satisﬁed for SHACL documents where all target deﬁnitions are empty. Let M substituting all target deﬁnitions in SHACL document M with the empty set. Then, the following lemma is immediate: Lemma 1. For all graphs G, SHACL docum ents M and assignments σ, condition (1) from Deﬁnition (G, σ) |= M exists a unique faithful total assignment for M M, then this must be it. Lemma 2. For all graphs G and n on-recursive SHACL documents M, there exists a unique assignment ρ in A Proof. If M is non recursive, then there exists a non empty subset M tains shapes whose constraints do not use shap e references. Intuitively, the constraints of the shapes in M ment. Shape references are the only part of the evaluation of a constraint that depends on the assignment σ, and that could introduce the truth value Und eﬁned under threevalued logic [8]. Thus, for all graphs G, assignments σ, nodes n and constraints c in of a shape in M (2) has a Boolean truth value. It is easy to see that properties (1) and (2) also hold for the document M only reference shapes in M properties (1) and (2) hold for all the shapes of M. Point (1) ensures that there cannot be more than one assignment such that (G, σ) |= M an assignment is total. This assig nment σ exists and it can be computed iteratively as follows. Let σ n, s ∈ σ for M and ¬s ∈ σ all of the shapes of M, is computed. Notice that for all graphs G, SHACL documents M and assignments σ, fact (G, σ) |= M implies (G, σ) |= M assignment ρ that there cannot be more than one assignment that if faithful for G and M 3.3. Semantics of Full SHACL has been le ft undeﬁned in the original W3C SHACL spec iﬁc ation [ rise to several possible interpretations. In this work, we consider previously introduced extended se mantics of SHACL that deﬁne how to interpret recursive SHACL documents. These can be characterised by two dimensions, namely the choice between (1) partial and total assignments [ will subsequently formally introduce . Together, these two dimensions result in the four For non-recursive SHACL documents, the next lemma states that for any graph, there such that (G, σ) |= M, then σ = ρ. (n), if JdKis True, and ¬s ∈ σ(n), otherwise. Then let σbe the assignment such that for any shape hs, t, di in Mand node n, s ∈ σ(n), if JdKis True, As mentioned, the semantics of recursive shape deﬁnitions in SHACL documents extended semantics studied in this article, namely brave-partial, brave-total, cau tiouspartial and cautious-total. We do no t consider the less obvious dimension of stable-model semantics [ the existence of a faithful assignment can be directly used as a semantics for recursive documents as well. Nevertheless, in this case the assignment is not nece ssarily total, as is in the case of non-recursive documents, proven in Lemma “brave” nature of the semantics discussed later), we call this the br ave-partial se mantics. Deﬁnition 5. A graph G is valid w.r.t. a SHACL document M under brave-partial semantics if there exists an assignment σ ∈ A one just introduced. To motivate those, ﬁrst conside r an ex ample o f a recursive document and of a non-total faithful assignment that evaluates the conformance of some nodes against some constraints to Undeﬁned. This happens when recursion makes it impos sible for a node n to either conform or not to conform to a shape s but, at the same time, validity does not depend on w he ther n conforms to shape s or not. Consider, for instance, the following SHACL document, c ontaining the single shape hs This shape is deﬁned as the neg ation of itself, that is, given a node n, a graph G and an assignment σ, fact Jd to see that any assignment that maps a no de to either {s it would violate condition (1) of Deﬁnition node of a graph to the empty set would be faithful for that graph and document {s Intuitively, this means that nodes in the graph cannot conform nor not c onform to shape s, but this should not be interpreted as a violation of any constra int, since this shape does not have any target node to validate. In eﬀect, conformance for all nodes to the constraint of {s any gra ph valid w.r.t. to {s pretation, nodes can either confor m to, or not conform to a g iven shape , and the concept of an “undeﬁned” level of conformance is arguably alien to the speciﬁcation. It is natural, therefore, to consider restricting the evaluation of a constraint to the True and False values of Boolean logic. This is achieved by restricting assignments to be total. Deﬁnition 6. A graph G is valid w.r.t. a SHACL document M under brave-total semantics if there exists a total assignment σ ∈ A w.r.t. a SHACL document M under brave-total semantics, than it is als o va lid w.r.t. M under brave-partial semantics. T he converse, instead, is only true for non-recursive SHACL documents. In fact, as we show later on, all extended semantics coincide, for nonrecursive SHACL documents. Note also that there is no obvious preferable choice fo r the semantics of recursive documents. For example, while total assignments can be seen as a more natural way of interpreting the SHACL speciﬁcation, they are not without issues of their own. Going back to our previous example, we can notice that there cannot exist 2], which relates to non- monotone reasoning in logic programs. The ﬁrst extended semantics that we conside r coincides with Deﬁnition 4. That is, The other three extended semantics are deﬁned by adding further conditions to the In the W3C SHACL speciﬁcation, where recursion semantics was left open to inter- Since total assignments are a more speciﬁc type of assignments, if a graph G is valid a total faithful assignment for the SHACL document containing shape :InconsistentS, for any non-empty graph. This is a trivial consequence of the fact that no node can conform to, nor not conform to, shape :InconsistentS. In this example, however, bravetotal semantics conﬂicts with the SHACL speciﬁcation, since the latter implies that a SHACL document without target dec larations in any of its shapes (such as the one in our example) should trivially validate any graph. If there are no targ e t decla rations, in fact, there are no target nodes on which to verify the conformance of certain shapes, and thus no violations of constraints should be detected. is the diﬀerence between brave and cautious validation of recursive documents. When a SHACL document M is recursive, there might exist multiple assignments satisfying property (1) of Deﬁnition can be seen as equally “correct” assignments with re spe c t to the constraints of the shapes, and brave validation only checks whether at least one of them is compatible with the target deﬁnitions of the shapes. Cautious validation, instead, represents a str onger form of valida tion, where all such assignments must be compatible with the target deﬁnitions. Deﬁnition 7. A graph G is valid w.r.t. a SHACL document M under cautious-partial (resp., cautious-tota l) semantics if it is (1) valid under brave-partia l ( resp., brave-total) semantics and (2) for all assignments σ in A This document requires the daily special of a restaurant, node :DailySpecial, to be vegetarian, that is, to conform to shape :VegDishShape. This shape is r ecursively deﬁned as follows. Something is a veg etarian dish if it contains an ingredie nt, and all of its ingredients are vegetarian, that is , entities conforming to the :VegIngredientShape. A vegetarian ingredient, in turn, is an ingredient of at least one vegetarian dish. Consider now a graph G Due to the recursive deﬁnition of :VegDishShape, there exist two diﬀerent assignments shape, while σ and node :Chicken conforms to :VegIngredientShape. Essentially, either both the dish and the ingredient from graph G or not can be a pproached with diﬀerent levels of “caution”. Under brave validation, gra ph Another dimension in the choices for extended semantics studied in literatur e [2] holds then (G, σ) |= M holds as well. To exemplify this distinction, consider the following SHACL document M. and σ, which are both faithful for Gand M. In σ, no node in Gconforms to any and M, while σis not. The question of whe ther the daily special is a vegetarian dish is valid w.r.t. M, since it is possible that the daily specia l is vegetarian. Cautious validation, instead, takes the more conservative approach, and under its deﬁnition G not valid w.r.t. by M document M, denoted by G |= M, is summarised in the fo llowing list, and schematise d in Table brave-partial there is an assignment that is faithful w.r.t. G and M; brave-total there is an assignment that is total a nd faithful w.r.t. G and M ; cautious-partial there is an assignment that is faithful w.r.t. G and M, and every cautious-total there is an assignment that is tota l and faithful w.r.t. G a nd M, and four semantics are necessarily equivale nt to each other, s ince the semantics of nonrecursive SHACL documents is uniquely determined. The formalisation of this equivalence given in the ne xt theorem is essentially a consequence of Lemma Theorem 1. For any graph G, non-recursive SHACL document M, and extended semantics α and β, it holds that G|= M under α iﬀ G |= M u nder β. Proof. Since A of validity of cautious-total trivially subsumes the one of brave-total and cautious-partial which, in turn, s ubsumes the one of brave-partial. Notice that for all graphs G, SHACL documents M and assignments σ, if σ ∈ A also know that a faithful assignment for M and G is necessarily total, and it is the same unique a ssignment that is faithful for M deﬁnition of validity of brave-partial subsumes the one of cautious-t otal, and consequently the four extended semantics are equivalent. semantics, we can deﬁne the following decision problems, which we study in the rest of the article. For each extended semantics, the deﬁnition of validity of a g raph G w.r.t. a SHACL assignment that is faithful w.r.t. G and Mis also faithful w.r.t. G and M. every assignment that is total and faithful w.r.t. G and Mis also faithful w.r.t. G and M . We now prove that, when considering only non-recursive SHACL documents, these Given a notion of validity from Table 1, cor responding to one of the four extended 3.4. From Partial to Total Assignments one can focus on total assignments semantics only, as partial a ssignment semantics can be seen as a special case of total. Thus, in the re st of this article we will focus on total assignments semantics without loss of generality. In particular, any SHACL document M can be linearly transformed into another document M w.r.t. M under brave-partial, or cautious-partial, iﬀ G is valid w.r.t. M total or cautious-total, re spe c tively. Intuitively, this is achieved by splitting each shape s into two sha pes s the constraints of s the constraints of s, and such that the evaluation to Undeﬁned of the constraints of s corres pond to the negation of the constraints of both s tion Γ over SHACL documents. With a slight abuse of notation, we use ¬ and ∧ to denote, res pectively, the negated form of a SHACL constraint, and the co njunction of two SHACL constraints. We also deno te s(x) the constraint requiring node x to conform to shape s. We use s function of s. Deﬁnition 8. Given a SHACL document M , docu ment Γ(M ) contains shapes hs γ(d)i and hs d, the corresponding constraint γ(d) is constructed by replacing, for every shape s, every occurrence of the negated atom “¬s(x)” in d with “¬s of the non-negated atom “s(x)” in d with “s Deﬁnition 9. Given an assignment σ, let σ node n the following holds: σ {¬s and G, a ssignment σ the complexity of the transformation Γ(M ) is linear in the size of the origina l document Lemma 3. Given a SHACL document M , a graph G, an assignment σ, and a node n, the following hold: • SHACL Satisﬁabil ity: A SHACL document M is satisﬁable iﬀ there exists a graph G such that G |= M. • SHACL Containment: For all SHACL documents M, M, we say that Mis contained in M, denoted M⊆ M, iﬀ for all graphs G, if G |= Mthen G |= M. Obviously, the more meaningful satisﬁability problem is one on ﬁnite graphs. • SHACL Finite Model Property : A SHACL document M enjoys the ﬁnite model property if whenever it is satisﬁable it is so on a ﬁnite graph. In this subsection we show that in order to study the theoretical properties of SHACL In the following, we formalise the just discussed transformation by means of a func- , ¬s|s, ¬s 6∈ σ(n)}. We can observe that for any SHACL document M , graph G and assignment σ for M • JdKis True iﬀ Jγ(d)Kis True; Proof. Negation in SHACL is deﬁned in the standard way, and therefore JdK True iﬀ J¬dK statement of the lemma is also proof of the second. We can also notice that the third statement of the lemma necessarily follows from the ﬁrst two. Thus the entire lemma can be proved by proving just the ﬁrst statement. To prove the ﬁrst item, we show the following two implications, separately: (⇐): if Jγ(d)K that this evaluation does not depend on any of its sub-sentences that are evaluated to Undeﬁned (i.e., changing the truth value of one such sub-sentence would not aﬀect the truth value of the whole sentence). Notice also that the only atoms that can be evaluated as Undeﬁned are shape references s(x) [ a constraint d over a node, a graph and an assignment is True (resp., False), then this evaluation would still be True (resp., False), if every shape atom s(x) that evaluates to Undeﬁned evaluates to False instead. in the transformation from d to γ(d) (1) every constraint that is not a shape reference remains unchanged, and (2) every shape reference (in d) is transformed into a conjunction of shape references (in γ(d)) that still evaluates to the same tr uth value of the original expression, unless this tr uth value is Undeﬁned. However, by our previous observa tion, changing an Undeﬁned truth value cannot aﬀect the truth value of Jγ(d)K JdK True, since, in the inverse transformation from γ(d) to d: (1) every constraint that is not a shape reference remains unchanged, and (2) e very pair o f shape references “s (a) evaluates to the same truth value, or (b) evalua tes to the truth value of Undeﬁn ed when the original constraint evaluates to False. Notice that in SHACL, the constraints of a shape are considered in conjunction, and neg ation only appears in front of shape references. Since Jγ(d)K in a disjunction in γ(d) of which at least one disjunct evaluates to True w.r.t. n, G and σ since this disjunction cannot be within the scope of negation. Pairs of shape references do not aﬀect the truth value of Jγ(d)K Theorem 2. Given a SHACL document M and a graph G, it holds that G is valid w.r.t. M under brave-partial (resp., cautious-partial) s emantics iﬀ G is valid w.r.t. Γ(M ) under brave-total (resp., cautious-total) semantics. • JdKis False iﬀ Jγ(¬d)Kis True; • JdKis Undeﬁned iﬀ both Jγ(d)Kand Jγ(¬d)Kare False. In Kleene’s 3-valued logic, the evaluation of a sentence into True or False implies (⇒) If JdKevaluates to True, then Jγ(d)Kmust also evaluate to True, since evaluates to True. T hus implication (⇒) holds . (⇐) Similarly, if Jγ(d)Kevaluates to True, then JdKmust also evaluate to (x)” or “¬s(x) ∧ s(x)” is transformed into a single shape reference which either (x)” or “¬s(x) ∧ s(x)” that evaluates to False w.r.t. n, G and σcan only appear (x)∧¬s(x)” or “¬s(x)∧s(x)” that evaluate to False w.r.t. n, G a nd σ, therefore, From Deﬁnition 8 and Lemma 3 the main theorem of this subsection easily follows. use the term brave semantics to refer to brave-total and cautious semantics to refer to cautious-total. 4. Shapes Constraint Logic: SCL decision problems in a formal logical system. For the sake of simplicity of presentation, we ﬁrst fo cus on the brave semantics only, and then show how to adapt our system to mode l cautio us semantics (recall that, as shown in Section semantics is, model-theoretically, a special case of total assignments se mantics). The main c omponent of this logical system is the SCL language, a novel fragment of ﬁrstorder logic extended with counting quantiﬁers a nd the transitive closure operator, that precisely models SHACL documents. We will later show the equivalidity of SHACL and SCL, by demonstrating how, for any graph, the latter can be used to model total faithful assignments. second-order logic deﬁned on top of SCL, by extending the latter with second-order quantiﬁcations on monadic relations. Intuitively, MSCL allows us to deﬁne conditions over the space of all possible assignments, something that canno t be expressed in SCL. Nevertheless, as we will see later, several formulations of our decision problems are fully reducible to the ﬁrst-order logic satisﬁability problem. 4.1. A First-Order Logic for SHACL we consider arbitrary ﬁrst-order relational models with equality as the only built-in relation. When we deal with the SHACL encoding, instead, we a ssume the ﬁrst-order models to have the set of RDF terms as the domain of discourse, plus a set of interpreted relations for the SHACL ﬁlters. relations. In particular, each shape s is associated with a unique shape relation Σ an assignment σ such that s ∈ σ(x) (resp. ¬s ∈ σ(x)). Since our logical system uses standard B oolean lo gic, fo r any element of the domain c and shape relation Σ, it holds that Σ(c)∨ ¬Σ(c) holds, by the law of excluded middle. Thus any Boolean interpretation of shape relations deﬁnes a total assig nment. Thus, in the rest of the article we will only focus on total assignments and we shall In this section we provide a precise formalisation of SHACL semantics and related Our decision problems, instead, are modelled using MSCL, a fragment of monadic In the presentation of our logical system and in the analysis of its decision problems, Assignments are modelled by means of a set of monadic relation names Σ, called shape is a shape relation associated with shape s, then fact Σ(x) (resp. ¬Σ(x)) describes nition 10, whose main syntactic components are described later on. In the rest of the article, we will focus on this logic to study the decidability and complexity of our SHACL decision problems. In particular, we are going to reserve the symbols τ and τ the transla tions from SHACL documents into SCL sentences and vice versa and refer the reader to the appendix for the full details about these translatio ns. Bold capital letters in square brackets on the right of some of the grammar production rules are pure meta-annotations fo r naming SCL features and, obviously, not a n integral pa rt of the syntax. Deﬁnition 10. The Shap e Constraint Logic (SCL, for short) is the set of ﬁ rst-order sentences ϕ built according to the following context-free grammar, where c is a constant from the domain of RDF terms, Σ is a shape-relation name, F is a ﬁlter-relation name, R is a binary-relation name, Kleene’s star symbol binary relation induced by π(x, y), the superscript ± stands for a relation or its inverse, and n ∈ N: uments. These could be empty (⊤), a conjunction of documents, a target axiom (production rules 3 , 4, and 5 of rule ϕ) or a constraint axiom (production rule 6 of rule ϕ). Target axioms take one of three forms, based on the type of target declarations in the shapes of a SHACL document. There are four types of target declarations in SHACL, namely (1) a particular cons tant c (node target), (2) instances of class c (class target), or (3) - (4) subjects/objects of a triple with predicate R (subject- of/object-of target). The full corr esp ondence of SHACL target declarations to SCL target axioms is summarised in Table target declarations, is s imply the conjunction of the corresponding target axioms. straints components. Within this subgrammar, the true symbol ⊤ identiﬁes an empty Sentences a nd formulae in the SCL language follow the grammar reported in Deﬁϕ := ⊤ | ϕ ∧ ϕ π(x, y) := R(x, y) ς(x, y) := x <y | x ≤y. Intuitively, sentences obtained through grammar rule ϕ correspond to SHACL doc- The no n terminal symbol ψ(x) c orresponds to the subgrammar of the SHACL conconstraint, x = c a consta nt eq uivalence constraint and F a monadic ﬁlter relation (e.g., node-type, datatype, la nguage tag, regular expressions, and string length [ captured by the F(x) productio n rule and the O component. The C component captures qualiﬁed value shape c ardinality constraints. The E, D and O components capture the equality, disjointedness and order property pair components. S denotes sequence paths, A denotes alternate paths, Z denotes a zero-or-one path, and, ﬁnally, T denotes a zero-or-more path. mial in the size of the input and computable in polynomial time. Intuitively, as we show later in Theorem representing the latter satisﬁes the SCL sentence τ(M ). Vice versa, every SCL sentence ϕ is sa tisﬁe d by a ﬁrst-order structure representing graph G iﬀ the SHACL document τ(ϕ) validates G. SHACL recursion, that is, a SHACL document M is rec ursive iﬀ the SHACL document τ(τ(M )) is recursive. We will call an SCL sentence φ recursive if τ for each shape s in M. Sentence τ(M ) can be be split into constraint axioms and target axioms. Intuitively, these are used to verify the ﬁrst and second condition of Deﬁnition respectively. The constraint axioms of τ(M ) correspond to the sentence τ(M to the translation of the document ignoring targets, while the target axioms of τ(M) corres pond to taking targets into account, i.e., to a sentence φ, where φ ∧ τ(M τ(M ). we will call well-formed, and thus we restrict the inverse translation τ on well-formed SCL s e ntences. An SCL sentence ϕ is well-formed if, for every shape relation Σ, sentence ϕ contains e xactly one constraint axiom with relation Σ on the lefthand side of the implication. Intuitively, this condition ensures that every shape relatio n is “deﬁned” by a corresponding constraint axiom. Figure 2 shows the translation of the document from Figure 1 into a well-formed SCL sentence. the translations of graphs and assignments into ﬁrst-order structures. Deﬁnition 11. Given a graph G, the ﬁ r s t-order structure G i.e., R(s, o) holds true in G Deﬁnition 12. Given a total assignment σ, the ﬁrst-order structure σ Σ(n), i.e., Σ (x), true iﬀ x is an IRI). By ﬁlters we refer to the SHACL constraints a bo ut orde ring, The π(x, y) subgrammar models SHACL property paths. Within this subgrammar As usual, to enhance readability, we deﬁne the following syntactic shortcuts: • ψ(x) ∨ ψ(x) := ¬(¬ψ(x) ∧ ¬ψ(x)); • π(x, c) := ∃y.π(x, y) ∧ y = c; • ∀y . π(x, y) → ψ(y) := ¬∃y . π(x, y) ∧ ¬ψ(y). The above mentioned translations τ and τbetween SHACL and SCL are polyno- Another important property of these translations is that they preserve the notion of Given a SHACL document M, the SCL sentence τ(M ) contains a shape relation Σ Note that our translation τ results in a particular structure of SCL sentences, that Before deﬁning the semantic corres po ndenc e between SHACL and SCL we introduce Deﬁnition 13. Given a graph G and a total assignment σ, the ﬁrst -order structure I induced by G and σ is the disjoint union of structures G structure I: (1) the graph G induced by I is the graph that contains triple hs, R, oi if I |= R(s, o) and (2) the assignment σ induced by I is the assignment such that, for all elements of the domain n and shape relations Σ ¬s ∈ σ(n) is true if I 6|= Σ theorem. Theorem 3. For all graphs G, total assignments σ and SHACL documents M, it is true that (G, σ) |= M iﬀ I |= τ(M ), where I is the ﬁrst-order structure induced by G and σ. For any ﬁrst-order str ucture I and SCL sentence φ, it is true I |= φ iﬀ (G, σ) |= τ where G and σ are, respectively, the graph and assignment induced by I. over the document syntax, with an operator-by-operator analys is of the translation we provide in the appendix. presented in [ the sentences obtained by translating this document are purely syntactic and the two sentences are equisatisﬁable. In particular , the binary relation hasShape of [ represented instead as a set of monadic relations. For recursive SHACL documents, the grammar of Deﬁnition 10 introduces a one-to-one correspondence between SHACL target declarations/constraints, and target/constraint axioms respectively. constraints from [8], with the a ddition of ﬁlters. The grammar from [8] omits ﬁlters by assuming that their evaluation is not more co mputationally complex than evaluating equality. This assumption is true for validation, the main decision problem addressed in [ Section 6. SHACL components. The language deﬁned without any of these constructs is our base The semantic correspondence between SHACL and SCL is captured by the following This theorem can be proved by a tedious but straightforward structural induction Sentences in SCL have a direct correspondence to the sentences of the grammar The sub-grammar ψ(x) in Deﬁnition10 corresponds to the g rammar of SHACL 8], but it does not hold for satisﬁability and containment, as we further discuss in To distinguish diﬀerent fragments of SCL, Table 3 lists a number of prominent language, denoted ∅. When using an abbreviation of a prominent feature, we refer to the fragment of our logic that includes the base language together with that feature enabled. For example, S A identiﬁes the fragment that only allows the base language, sequence paths, and alternate paths. disjointedness and order components (corresponding to E, D, and O in SCL) for ce one of their two path expressions to be an atomic relation. This can result in situa tions where order constraints can be deﬁned in just one direction, since o nly the less -than and lessthan-or-equal prope rty pair constraints are deﬁned in SHACL. Our O fragment models a more natural order comparison that includes the > and ≥ compone nts, by using the inverse o f < and ≤. We instead denote by O’ the fragment whe re the order relations in the ς(x, y) subgrammar cannot be inverted. In our forma l analysis of Section consider both O and O’. 4.2. A S econd-Order Logic for SHACL Decision Problems straint Logic (MSCL, for short) built on top o f a second-order interpretation of SCL sentences. A second-order interpretation of an SCL sentence φ is the seco nd-order formula obtained by inter preting s hape relations as free monadic second order variables. Obviously, shap e relations that are under the scope of the same quantiﬁer describe the same assignment. While SCL can be used to describ e the faithfulness of a single assignment, MSCL can express properties that must be true for all possible assignments. This is necessary to model all extended semantics. As usual, disjunction and implication symbols in MSCL sentences are just syntactic shortcuts. Deﬁnition 14. The Monadic Shape Constraint Logic (MSCL, for short) is the set of second-order sentences bu ilt according to the following context-free grammar Φ, where ϕ is an SCL sentence and Σ is the second-order variable corresponding to a shape relation. The ∃SCL (resp., ∀SCL) fragment of MSCL is the set of sentences obtained by the above grammar deprived of the negation and universal (resp., existential) quantiﬁer rules. The SHACL speciﬁcation presents an unusual asymmetry in the fact that equality, In order to model SHACL decis ion pro ble ms, we intr oduce the Monadic Shape Conand containment for MSCL sentences, as well as the closely related ﬁnite-model property, in the natural way. MSCL Sentence Satisﬁability An MSCL sentence Φ is satisﬁable if there exists a MSCL Finite-model Property An MSCL sentence Φ enjoys the ﬁnite-model propproblems. In this respect, we assume that ﬁlters are interpreted re lations. In particular, we prove equivalence of SHACL and MSCL, for the purpose of validity, on models that we call canonical; that is, models having the following pr operties: (1) the domain of the model is the set of RDF terms, (2) constant symbols are interpreted as themselves (as in a standard Herbrand model [ for ﬁlters, and (4) ordering relations < and ≤ are the disjoint union of the total orders of the diﬀerent comparison types allowed in SPARQL. To enforce the fact that diﬀerent RDF terms are not equivalent to each other we adopt the unique name as sumption for the constants of our language. For the purpose of our decision problems, it is suﬃcient to axiomatise the ine quality of all the known constants. mentioned decision problem by looking at the “simpler” SCL satisﬁability and validity decision problems. Proposition 1. An ∃SCL (resp., ∀SCL) sentence Φ , ∃Σ is satisﬁable (resp., valid). 5. From SHACL Decision Problems to MSCL Satisﬁability us to formally deﬁne several decis ion problems. We ﬁrst use this language to deﬁne the main such problems studied in this ar ticle , namely SHACL validation, satisﬁability and containment. We then show how MSCL can also capture a number of related decision problems that have been proposed in the literature. 5.1. Principal Decision Problems reduction of our decision problems into MSCL satisﬁability. Notably, we also show how some of them can be further reduced into ∃SCL. As we will see later, this last reduction can be easily translated to a reduction into ﬁrst-order log ic , from which we derive several decidability r e sults. ment semantics. Given a second-order formula φ, second-order interpretation of an SCL Relying on the standar d semantics for se cond-order logic, we deﬁne the sa tis ﬁability relational structure Ω such that Ω |= Φ. erty if, whenever Φ is satisﬁable, it is so on a relational structure. In Section5 we discuss the correspondence between the SHACL and MSCL decision Finally, we state a trivial result used later on to show how to solve some of the . ϕ) is satisﬁable (resp., valid) iﬀ the subformula ϕ interpreted as an SCL sentence The r ich express iveness of the MSCL language, deﬁned in the previous section, allows In this section we describe the equivalidity of MSCL and SHACL, and provide a We aga in focus only on total assignment semantics which subsumes partial assignsentence, we denote with ∃(φ), respectively ∀(φ), the MSCL sentence obta ine d by existentially, respec tively universally, quantifying all of the shape relations of φ. Recall that, by construction, the assignments induced by models of an MSCL sentence are total, and that the second-order variables under the scope of the same quantiﬁer represent a single assignment. by a structure, easily follow from Theorem 1. The ﬁrst two corollaries ex press the equisatisﬁability of MSCL and SHACL. The las t four corollaries express our formalis ation of the SHACL satisﬁability and containment decision problems in the case of brave validation and in the case of cautious va lidation. Recall also that G notes the SHACL document obtained by removing all ta rget declarations from SHACL document M, which we use to test ﬁrst condition of Def. Corollary 1 (Brave-Total Valida tion). A graph G is valid w.r.t. a SHACL document M under brave-total semantics if G Corollary 2 (Cautio us-Total Validation). A graph G is valid w.r.t. a SHACL document M under cautious-total s emantics if G Corollary 3 (Brave-Total Satisﬁability). For any SHACL document M, document M is (ﬁn itely) satisﬁable under brave-total semantics if ∃(τ(M )) is (ﬁnitely) satisﬁable. Corollary 4 (Cautious-Total Satisﬁability). For any SHACL document M , document M is (ﬁnitely) satisﬁable under cautious-total semantics if ∃(τ(M ))∧∀(τ(M is (ﬁn itely) satisﬁable. Corollary 5 (Brave-Total Containment). For any pair of SHACL documents M Corollary 6 (Cautious-Total Containment). For any pair of SHACL documents M and M documents by exploiting the properties o f Lemma semantics are equivalent for non-rec ursive SHACL. Lemma 4. For any pair of non-recu rsive SHACL docum ents M is contained in M Proof. For non-recursive SHACL documents all semantics are equivalent, thus containment of two non-recursvie SHACL documents c an be expressed as containment under brave -total semantics (Corollary Notice that fo r all assignment σ and graphs G, if (G, σ) 6|= M thus we can rewrite containment as the unsatisﬁability of the following sentence: The following corolla ries, which rely on the s tandard notion of modelling of a sentence , docu ment Mis contained in Munder brave-total semantics iﬀ ∃(τ(M)) → )) is valid, that is, iﬀ ∃(τ(M)) ∧ ¬∃(τ(M)) is unsatisﬁable. , document Mis contained in Munder cautious- total semantics if ∃(τ(M)) ∧ ∀(τ(M) → τ(M))→∃(τ(M)) ∧ ∀(τ(M) → τ(M)) is valid, that is, iﬀ ∃(τ(M)) ∧ ∀(τ(M) → τ(M))∧ ¬∃(τ(M)) ∧ ∀(τ(M) → τ(M)) is un satisﬁable. We now provide a simpliﬁed deﬁnition of c ontainment for non-recursive SHACL (G, σ) |= M and thus ∃(τ(M criterion as the unsatisﬁability of the following se ntence: to the satisﬁability of ∃SCL sentences, which, as deﬁned in Propos ition 1, c an be further reduced to the satisﬁability of SCL. In Section of SCL to provide decidability and complex ity results for our decision problems that can be reduced to ∃SCL satisﬁability, namely the s atisﬁability and containment of nonrecursive SHACL documents, and satisﬁability of (recursive) SHACL documents under brave -total (and thus also brave-partial) semantics. The remaining decision problems, namely containment for recursive SHACL documents (under any ex tended semantics), and satisﬁability for re cursive SHACL documents under cautious validation, require the expressiveness of second-order logic, and are likely undecidable even for very restrictive fragments of SHACL. 5.2. Additional Decision Problems that shift the focus on more ﬁne-grained objects, such as shapes and constraints. While these additional decision problems a re not the focus of this article, we discuss them the sake of completeness. To better model these additional problems, we will use t a constraint deﬁnition that targets the single node n. of shape containment [ that whenever M is used for validation, nodes conforming to s necessarily conform to s. The deﬁnition of shape containment, adapted to the notation of our article, is the following. Deﬁnition 15. Given a SHACL document M , and two shapes hs, t, di and hs in M, s is shap e contained in s all graphs G, nodes n in nodes(G, ∅ ) and assignments σ in A (G, σ) |= M , if s ∈ σ(n) then s more general, as it also includes brave-partial. It is important to notice that, if a SHACL document is unsatisﬁable, any pa ir of shapes within that document trivially contain each other. In other words, the containment of a shape into another is not necessarily cause d by any particula r property of those shapes. ∃(τ(M)) ∧ ∀(¬τ(M) ∨ ¬τ(M)), which is trivially equivalent to the following: ∃(τ(M)) ∧ ∀(τ(M) → ¬τ(M)) is unsatis ﬁable. From Lemma2 we know that, for any graph G, there exists an assignment σ such that ∃(τ(M)) ∧ ∃(τ(M)) ∧ ∀(τ(M) → ¬τ(M)), which is trivially equivalent to: ∃(τ(M)) ∧ ∃(τ(M) ∧ ¬τ(M)) ∧ ∀(τ(M) → ¬τ(M)). From Lemma2 we also know that there is only one assignment σ such that (G, σ) |= , thus the conjunct in the for all quantiﬁcation can be removed. From the deﬁnitions above we can notice that several decision problems are reducible Our logical framework allows us to express a number of a dditio nal decision problems Given a SHACL doc ument M , and two shapes s and sin M , the decision problem While the or iginal deﬁnition only conside red brave-total semantics, our formulation is decidable is the SHACL fragment corresponding to the SCL sub-fragment of C (the base language plus counting quantiﬁers) where ﬁlters are not allowed. This is in agreement with our decidability results, that we present in Sec. of of the similar SHACL sa tis ﬁability problem for even more general fr agments of C. that document M ∪ {hs semantics, where s node n, and d Theorem 4. Given a SHACL document M , and two shapes hs, t, di and hs s is not shape contained in s exist a node n such that docum ent M ∪ {hs (resp. brave-total) semantics, where s that targets only node n, and d negation of d Proof. Given a node n let M to s ee that the following properties are true for graph G: (1) it is valid w.r.t. M (since M is a subset of M total) for M and G, and such that s ∈ σ(n) and ¬s but not d for G and M the σ then there e xists another graph G such graph G and a fresh relation name. This is b e cause the shap es of a SHACL document can only target nodes mentioned in the document, or those that are reachable by the relations mentioned in the document. Mor eover , the evaluation of any SHACL constraints on a node is unaﬀected by that node being the object of a triple with an unknown predicate. Since G (as for case n ∈ nodes(G)) to prove that sha pe s is not contained in s ment σ faithful (resp. faithful and total) for G and M, and a node n such that s ∈ σ(n) and ¬s σ assignment that accounts for the s ⊤} ∪ {¬s ment σ Deﬁnition 16. Given a SHACL document M, a shape name s not in M and a constraint d that only references s hapes in M ∪{ s}, template satisﬁability under brave-partial (resp. brave-total) semantics is the problem of deciding whether there exists a node n such that document M ∪{hs, t tics. We should also note that the fragment studied in [19] for which shape containment is The shape containment problem can be expressed as the existence of a node n such ⇒) If Mis satisﬁable, let G be a graph that is valid w.r.t. it. If n ∈ nodes(G) it is easy ). One such ass ignment σ can be obtained by taking an assignment σ, faithful function. Thus, shap e s is not contained in sw.r.t. M. Instead, if n 6∈ nodes(G), satisﬁes the same properties as G, we can apply the same reasoning as above ⇐) If shape s is not contained in sw.r.t. M then there exists a graph G, an assign- ∈ σ(n). Therefore, JdKmust be true. Let σbe the extension of the |¬JdK= ⊤}, for any node j in nodes(G, M). It is easy to see that assignis faithful (resp. faithful and total) for Mand G, and thus Mis satisﬁable. The above mentioned theorem introduces the following auxiliar y decision problem. ment, are deﬁned in [22] to study the properties of non-recursive SHACL constraints. Intuitively, a constraint d is satisﬁable if there exists a node that conforms to d, and a constraint d is contained in d provide here a generalisation of these problems by introducing a SHACL document as an additional input. The primary purpose of this additional document is to study constraints under recursion, that is, constraints that reference rec ursive shapes. However, it can also be used to study constraint satisﬁability and containment subject to a particular document being valid. When this document is empty the following decision pr oblems corres pond to the o ne s deﬁned in [ without recursion. Deﬁnition 17. Given a SHACL constraint d and a SHACL document M , such that d does not reference shapes not included in M, constraint d is satisﬁable under extended semantics α if there exists a node n such that SHACL document M ∪ {hs, t satisﬁable under α, where s is a fresh shape name. Deﬁnition 18. Given two SHACL constraints d and d such that d and d dunder extended semantics α if for all nodes n, document M ∪ {hs, t in M ∪ {hs tics are, by deﬁnition, sub-problems of SHACL template satisﬁa bility for the respective semantics. Constraint containment for non-re cursive SHACL documents is also a sub-problem of SHACL template satisﬁability. This is a consequence of the fact that containment of two non-recursive SHACL documents can be decided by dec iding the satisﬁability of an ∃SCL se ntence (Lemma problem of templa te satis ﬁability can be expressed as ∃SCL sentence satisﬁability. Therefore, our positive r esults that will be presented in Section upper b ound complexity results for the de c ision problems expressible as template satisﬁability, namely (1) shape containment, (2) constraint satisﬁability under brave-partial and brave-total semantics and (3) constraint containment for non-recursive SHACL documents. 6. From Interpreted To Uninterpreted Models via Filter Axiomatisation ters. The main goal of these axiomatisations is to account for ﬁlter semantics without requiring ﬁlters to be interpreted relations. For any MSCL sentence Φ we construct axiomatisa tions α such that Φ is satisﬁable on a canonical mo de l if and only if Φ ∧ α is satisﬁable on an uninterpreted models, that is, models who se domain is the set of RDF terms, but where ﬁlters a nd ordering relations are simple relations instead of interpreted ones. T his reduction to standard Fol allows us to prove decidability of the satisﬁability and containment problems for several SCL fragments in the face of ﬁlters. is exponential on size of the original sentence. We then provide an alternative axiomatisation, polynomial on size of the original sentence, that however requires counting quantiﬁers to express certain ﬁlters. We e xclude from our ax iomatisation the sh:lessThanOrEquals Two additional decision pro blems, constraint satisﬁability and constraint contain- , t, di} under α, where s and sare fresh s hape names. The problem of constraint satisﬁability under brave-partial and brave-total seman- In this section we discuss explicit axiomatizations of the semantics of a set of ﬁl- We ﬁrst present a simpliﬁed but expensive formulation of this axiomatis ation, that or sh:lessThan constra ints (the O and O’ components of our grammar) that are binary relations, and which do not belo ng to any decidable fragment we have so far identiﬁed, as shown in the next section. For the sh:pattern constraint, which tests whether the string representation of a node follows a certain regular expression, we only consider standard regular expressions (i.e. regular expressions that can be converted into a ﬁnite state machine). All features deﬁned as ﬁlters in Sec. components, are represented by monadic relations F (x) o f the SCL grammar. While equality remains an interpreted rela tion, for which we do not provide an axiomatisation, we will also consider equality to a constant c as a monadic ﬁlter relation (which we call equality-to-a-constant) whose interpretation is the singleto n set containing c. 6.1. Na¨ıve Axiomatisation the domain. For example, the interpretation of ﬁlter relation F since F MSCL whose interpretation is predetermined. Thus, we ca n axiomatise the s e mantics of ﬁlters w.r.t. deciding satisﬁability by capturing which conjunctions o f ﬁlters a re unsatisﬁable, and which conjunctions of ﬁlters are satisﬁable only by a ﬁnite set of elements. For example, the number of e lements o f the Boolean datatype is two, the number of elements that are literals is inﬁnite, and there are four elements of integer datatype that are both greater than 0 and lesser than 5. Let a ﬁlter combination F(x) denote a conjunction of atoms of the form x = c, x 6= c, F(x) or ¬F (x), where c is a constant and F is a ﬁlter predicate. Given a ﬁlter combination, it is possible to compute the set of elements of the domain that can satisfy it. Let γ be the function from ﬁlter combinations to subs ets of the domain that returns this set. The computation of γ(F(x)) for the monadic ﬁlters we consider is tedious but trivial as it boils down to determining: (1) the lexical space of datatypes; (2) the cardinality of intervals deﬁned by order or string- length constraints; (3) the number of elements accepted by a regular express ion; (4) well-known RDF-speciﬁc restrictions, e.g., the fact that each RDF term has exa c tly one node type, and at most one datatype and one language tag. Combinations of the previous four points are similarly computable. Let F the ﬁlters pr edicates and constants occurring in an MSCL sentence Φ. The na¨ıve ﬁlter axiomatization α(Φ) of a sentence Φ is the following conjunction, wher e Σ shape name. The semantics of each monadic ﬁlter relation is a predetermined interpretation over (x) is true iﬀ x is an IRI. Notice also that ﬁlters are the o nly components of α(φ) =(∀x. Σ(x) ↔ F(x)) To better illustr ate this axiomatisation, consider the following MSCL sentence φ. φ= Σ(q) ∧ ∀x.Σ(x) ↔∃y. R(x, y) ∧ F(y) ∧ F(y) ∧ F(y) Intuitively, this sentence is satisﬁable if a constant q can be in the R relation with four diﬀerent integers that (a) are greater than 0, (b) that are less than or e qual than 5, and (c), that are not equal to 2 or 3. Since there ar e only thr ee integers that satisfy the conditions (a), (b) a nd (c) simultaneously, this sentence is not satisﬁable on a canonical model. This sentence contains the ﬁlters F respectively, the fact that x is greater than the numbe r 0, the fact that x is less or equal than the number 5, and the fact that x belongs to the XSD integer datatype of known constants of φ known constants are literals of the XSD integer datatype. where Σ tion of φ Theorem 5. Given an MSCL sentence φ and its na¨ıve ﬁlter axiomatisation α(φ), sentence φ is satisﬁable on a canonical model iﬀ φ ∧ α(φ) is satisﬁable on an uninterpreted model. Containment φ φ∧ α(φ Proof. We focus on satisﬁability, since the proof for co ntainment is similar. Let c be any element of the domain and F(x) be any ﬁlter combination that can be constructed with the constants and ﬁlter relations in φ. Since the se mantics of ﬁlter relations has a universal interpretation, F(c) is either true on all cano nic al models, or false on all canonical models. Notice that, by construction of o ur axiomatisation, the truth value of F(c) on all canonical models corresponds to the truth value of F(c) on all uninterpreted models of α(φ). Let I canonical model of φ, by (1) changing all the uninterpreted ﬁlter relations in I corres ponding interpreted ones in I and (2) dropping from I shape relations that occ ur in α(φ). Let I be a canonical model of φ, we can construct I, uninterpreted mode l of φ ∧ α(φ), by (1) changing all the interpreted ﬁlter relations in I for their corresponding uninterpreted ones in I interpretation of each shape relation Σ combination such that ∀x. Σ such conjunct exists for any shape relation), relation Σ domain which satisfy the ﬁlter co mbination F(x) on canonical models. 6.2. Bounded Axiomatisation combinations. However, we can limit an a xiomatisation to ﬁlter combinations having a number of atoms smaller or equal to a constant number, thus making o ur axiomatis ation The na¨ıve ﬁlter ax iomatisation α(φ) contains, among others, the following conjuncts, is a fresh shape name. ∧ (∀x. Σ(x) ↔ x = 1 ∨ x = 4 ∨ x = 5) This axiomatisation states that only three constants satisfy the main ﬁlter combina, and thus φ∧ α(φ) is unsatisﬁable on an uninterpreted model. ∧ φ) ⊆ φholds on all uninterpreted models. The ma in exponential factor in the axiomatisations ab ove is the s e t of all possible ﬁlter polynomial w.r.t. an MSCL se ntence Φ. Intuitively, this can be achieved because F contains several redundant ﬁlter combinations. To illustrate this point, c onsider datatype ﬁlters atoms F true if x is a literal with datatype c. combination F diﬀerent datatypes , the truth value of F(x) is always false (i.e. |γ(F(x))| = 0). Trivially, any ﬁlter combination in F and thus its axiomatisation is not necessary. about each ﬁlter type to determine the maximum number of conjuncts of that type to consider in any ﬁlter combination. We call this number the maximum non-redundant capacity (MNRC) of tha t ﬁlter type. Any ﬁlter combination that contains more conjuncts of that ty pe than its MNRC, is nece ssarely redundant. Deﬁnition 19. A ﬁlter combination F(x) is redundant if there exists a ﬁlter combination F(x) such that γ(F(x)) = γ(F proofs we will assume that all conjuncts of a ﬁlter combination are syntactically diﬀerent from each other as any ﬁlter combination that contains multiple copies of the same conjunct is trivially redundant. The MNRC of datatype ﬁlters is two. Lemma 5. Any ﬁlter combination F(x) that contains more than two datatype ﬁlter conjuncts is redundant. Proof. Since no RDF term can have two datatypes, if F(x) contains two positive datatype ﬁlter conjuncts, then F(x) is unsatisﬁable. Thus F(x) cannot contain more tha n two positive datatype ﬁlter conjuncts without being redundant. Since RDF litera ls do not need to be annotated with a datatype, any neg ation ¬F not aﬀect the truth value of a ﬁlter combination, unless the datatype ﬁlter also contains conjunct F F(x) is not redundant, either it does not contain negated datatype ﬁlters, or it contains the two ﬁlters F of any further datatype ﬁlter in F(x) would make the ﬁlter combination redundant. with the F tag c. Since not all string literals have a language tag, but no string literal has more than one such tag, this ty pe of ﬁlter behaves analogously to the datatype ﬁlter. The proof of the following lemma, which states that the MNRC of language tag ﬁlters is two, can be derived from the one above. Lemma 6. Any ﬁlter combination F(x) that contains more than two language tag ﬁ lter conjuncts is redundant. In order to limit the size of the ﬁlter combinations to a constant number, we reason We will now deﬁne the MNRC for all the monadic SHACL ﬁlter types. In the following We represent language tag ﬁlters , derived from the sh:languageIn and sh:uniqueLang, sh:maxExclusive, sh:minInclusive and sh:maxInclusive constraint components, denote the x > c, x < c, x ≥ c and x ≤ c operators, respectively. Order comparison ﬁlters have an MNRC of two. Lemma 7. Any ﬁlter combination F(x) that contains more than two order comparison ﬁlter conjuncts is redundant. Proof. If two order c omparison ﬁlters in F(x) are deﬁned over incompatible comparison types (e.g. strings and dates) then F(x) is unsatisﬁable, and all the other comparison ﬁlters in F(x) are redundant. In a set of ﬁlters, we deﬁne as the most restrictive the one with the smallest number of elements satisfying it, or any such ﬁlter if there is more than one. If all the comparison ﬁlters in F(x) a re deﬁned over the same comparison type, let α be the most restrictive conjunct in F(x) of type x > c, ¬x < c, x ≥ c and ¬x ≤ c (or ⊤ if no ne such conjunct exists), and ω be the most restrictive conjunct in F(x) of type ¬x > c, x < c, ¬x ≥ c and x ≤ c. Trivially, F(x) is semantically equivalent to F(x), which is constructed by removing from F(x) all comparison ﬁlters that are not α or ω. ponents sh:minLength and sh:maxLength, and they behave analogously to the order comparison ﬁlters. The proof of the following lemma, which states that the MNRC of string length comparison ﬁlters is two, ca n be derived from the one above. Lemma 8. Any ﬁlter combination F(x) that contains more than two string length comparison ﬁlter conjuncts is redundant. ﬁlters have an MNRC of three. Lemma 9. Any ﬁlter combination F(x) t hat contains more than three node kind ﬁlter conjuncts is redundant. Proof. This lemma can be proven in the same manner as Lemma that, since all RDF terms belong to exactly one of the tree node kinds, ﬁlter combination SHACL with the sh:hasValue and sh:in constr aints), by noticing that any variable x, by the law of excluded middle, is either interpreted as one of the k nown constants, or as none of them. In SCL we can express with Σ C, where ν is a unique shape name deﬁned as Σ consider all possible interactions of the equality ope rator with ﬁlter combinations by considering whether an element x is one of the k nown constants, or whether it confo rms to shape Σ ﬁlter combination F(x) a s a conjunction of ato ms of the form x = c, x¬ = c, Σ F (x) and ¬F (x). Lemma 10. Any ﬁlter combination F(x) that contains more than one equality-to-aconstant conjuncts is redundant. The order comparison ﬁlters, which are expressible in SHACL with the sh:minExclusive, String length comparison ﬁlters are express e d in SHACL with the constraint com- Node kind ﬁlters can be re presented by three ﬁlter relations F(x), F(x) and (x) that are true if x is, respectively, an IRI, a literal or a blank node . Node kind (x) ∧ ¬F(x) ∧ ¬F(x) is uns atisﬁable and it is not redundant. We can establish an MNRC o f 1 for the equality-to-a-constant operator (expressed in Proof. Any ﬁlter combination F(x) that contains more than one equality-to-a-cons tant operator , of which at least one is in positive form, is redunda nt. In fact, a ﬁlter combination is made redundant by: (a) any two positive equality-to-a-constant operators x = c ∧ x = c which is unsatisﬁable by the standard interpretation of the equality operator, and (b) any pair of a po sitive and a negative equality-to-a-constant operators x = c ∧ x 6= c because (b.1) if c and c by the standard interpretation of the eq uality operator and (b.2) if c is not the same constant as c but all negated, is also redundant. Let D be the domain of discourse, C be the set of known constants in the sentence Φ from which the ﬁlter combinations have bee n c reated, and C of F(x). The equality-to-a-constant operators in F(x) restricts the domain to elements D \ C can rewrite F(x) into an equivalent set of ﬁlter combinations one equality-to-a-co nstant operator by noticing that we can rewrite D \ C C) ∪ (C \ C elements in the interpretation of Σ constants. The s e t of ﬁlter combinations follows: the domain either belongs to Σ imposed by F(x) and by the set is sh:pattern, since any numb e r of regular expressions c an be combined together to generate novel and non-redundant regular expressions. of all conjunctions such that (1) the conjuncts are atoms of the form x = c, Σ or ¬F (x), where c is a constant occurring in φ and F is a ﬁlter predicate occurring in φ; (2) the number of conjuncts of each ﬁlter type, and of equa lity, does not exceed its maximum non-redundant capacity. the size of the ﬁnite sets computed by the γ function. While certain ﬁlter constraints, such as sh:nodeKind, are either satisﬁable by an inﬁnite number of elements, or are unsatisﬁable, other constraints can be satisﬁed by an arbitrarily large number of elements. We c an reduce the size of each conjunct to a loga rithmic factor (with a binary numeric representation) by using counting quantiﬁers. This allows us to express the maximum number of elements that can satisfy a ﬁlter combination without explicitly enumerating them. axiomatisa tion ¯α(φ) of φ is deﬁned as follows. Moreover, any ﬁlter combination F(x) that contains equality-to-a-constant operators, the set of constants that are in the negated equality-to-a-constant operators . Let F(x) be the subse t of F(x) without equality-to-a-constant conjuncts. We ¯F = {F(x) ∧ Σ(x)} ∪ {F(x) ∧ x = c|c ∈ C \ C}. Since every element of The only ﬁlter constraint that doe s not have a ma ximum non-redundant capacity We deﬁne the set of bounded ﬁlter combinations Fof an MSCL sentence φ the set Notice that in the previous axiomatisation the size of each conjunct depends on Given an MSCL sentence φ and the set C of all known constants in φ, the bounded ¯α(φ) =Σ(x) ↔¬x = c∧∃x. F(x) bounded axiomatisation only includes ﬁlter combinations of up to 12 conjuncts. Thus, the size of the bounded axiomatisation is polynomial w.r.t. φ. MSCL sentence φ among others, the following conjuncts: satisfy a ﬁlter combination, only three can belong to Σ axiomatisa tion). The remaining one must s atisfy both (x = 2 ∨ x = 3 ∨ x = q) and x 6= 2 ∧ x 6= 3, and thus cannot be a constant other than q. However, q is not compatible with the ﬁlter combination (by the last line of the axiomatisation). Therefore , φ is unsatisﬁable on an uninterpreted model. mar, while the na¨ıve ﬁlter axiomatisation does, albeit not resulting in we ll-formed sentences. The diﬀerences between our axiomatisatio ns and well-formed MSCL sentences, however, do no t aﬀect our decidability and complexity results presented in the following section since (a ), the po sitive results are applicable to fragments of ﬁrst-o rder logic that are general enough to express our axiomatisations and (b), the negative results are applicable to SHACL sentences without ﬁlters, which therefore do not requir e an axiomatisation. For the purposes of the decidability and complexity analysis presented in the following se ction, the na¨ıve ﬁlter axiomatisation is compatible with all of the language fragments, while the bounded ﬁlter axiomatisation is compatible with the fragments that include counting quantiﬁers. Theorem 6 . Given an MSCL sentence φ and its bounded ﬁlter axiomatisation ¯α(φ), sentence φ is satisﬁable on a canonical model iﬀ φ∧ ¯α(φ) is satisﬁable on an uninterpreted model. Containment φ φ∧ ¯α(φ Proof. We focus on satisﬁability, since the proof for containment is similar. First notice that every canonic al model I of Φ is necessarily a model of φ∧α(φ). Indeed, by deﬁnition of the function γ, given a ﬁlter co mbination F(x), there cannot be more than |γ(F(x))| elements satisfying F(x), independently of the underlying canonical model. Thus, I satisﬁes α(φ). Consider now a model I of φ ∧ α(φ) and let I from I by replacing the interpretations of the monadic ﬁlter relations with their canonical ones. Obviously, for any ﬁlter combination F(x), there are exactly |γ(F(x))| elements in I between the elements satisfying F(x) in I and those satisfying F(x) in I one can prove that I used to verify a subformula ψ of Φ in I, one can use the value ι(x) to verify the same subformula ψ in I By lemmas 5 to 10, if φ does not c ontain any ﬁlter of the sh:pattern type, the To better explain this second axiomatisation, let us consider again the example of the Of the four elements require d by the existentially bounded sub-formula of φto It should be noted that the bounded axio matisation does not follow the MSCL gram- ∧ φ) ⊆ φholds on all uninterpreted models. satisfying F(x), since Iis canonical. As a consequence, there exists a injection ι 16) can be reduced into an ∃SCL satisﬁability problem. In particular, achieving this reduction in the face of ﬁlters requires the additional machinery o f the bounded ﬁlter axiomatisa tion. The correspondence betwee n SHACL template satisﬁability and ∃SCL sentence satisﬁability is given by the following theor e m. The intuition behind this theorem is that, in an uninterpreted model, unknown constant symbols are interchangable. Therefore, on an uninterpre ted model, conside ring template satisﬁability for one unknown constant symbol amounts to considering this problem for all possible constants. Let Constant(φ) denote the set of co nstants in φ. Theorem 7. The answer to the template satisﬁability problem for M, s and d under brave-total semantics is True iﬀ there exists a constant symbol f ∈ Constant(φ) ∪ {c}, with c a fresh constant symbol, such that φ∧ ¯α(φ)∧Σ model, where φ = τ(M ∪ {hs, ∅, di}). Proof. Recall that, by Theorem φ∧Σ under brave-total semantics is true. Per Def. graph G and a node n such that G is valid w.r.t. M ∪ {hs, t of target declarations in Table 2 it follows tha t τ(M ∪ {hs, t φ∧Σ structure I such that I |= τ (M ∪ {hs, t to our previous observa tion. Consider the following cases: (1) n ∈ Constant(φ) and (2) n 6∈ Constant(φ) J |= φ ∧ Σ MSCL sentence ρ depends only on the set of ﬁlter relations and the set of constants in ρ. Therefore, if n ∈ Constant(φ) then ¯α(φ ∧ Σ J |= φ ∧ Σ φ ∧ Σ additional constant. The additional constant in φ ∧ Σ axiomatisa tion that considers more cases. Thus J |= φ ∧ ¯α(φ) and Σ J. Le t J mapped to n, then J We distinguish two cases similar to the cases discussed before: (1) f ∈ Constant(φ) and (2) f 6∈ Constant(φ). case of the previous directionality. More speciﬁcally, ¯α(φ) = ¯α(φ ∧ Σ J |= φ ∧ ¯α(φ ∧ Σ I |= φ ∧ Σ in the domain of constants such that the uninterpreted model J[f 7→ v] (obtained by mapping constant symb ol f to v in J) models φ ∧ Σ As anticipated in the previous section, the problem of template satisﬁability (Def. (n) iﬀ there exists an uninterpreted model J such that J |= φ∧Σ(n)∧ ¯α(φ∧Σ(n)). (⇒) Assume that the answer to the template satisﬁability problem for M , s and d (n), where φ = τ(M ∪{hs, ∅, di} ). Moreover, by Theorem3, there exists a canonical In the ﬁrst case, let f be n. Then there exists a n uninterpreted model J such that (f) ∧ ¯α(φ ∧ Σ(f)). Notice also that the bounded ﬁlter axiomatisation of an In the second case there exists an uninterpreted model J and a constant n such that (n) contains the sa me ﬁlter relations as φ, and all the constants of φ plus one be the extension of the uninterpreted model J where constant symbol f is (⇐) Assume tha t there exists an uninterpreted model J such that J |= φ∧¯α(φ)∧Σ(f). In the ﬁrst case, the thesis can be proven by following the reverse proof of the ﬁrst (f). In case (2), we prove that J |= φ ∧ ¯α(φ) ∧ Σ(f) implies the existence of a value v v exists, then it must follow that there exist a non-empty ﬁlter combination F, without equality ope rators, such that J |= F(f), but such that ¯α(φ ∧ Σ F does not contain equality operators, and since φ∧Σ relations, it follows that ¯α(φ) → ∀x.¬F(x), which is in contradiction to the premises. Intuitively, this is due to the fa c t that the interpretation of ﬁlters is universal, so if a ﬁlter combination F is unsatisﬁable, it is unsatisﬁable in all axiomatisations whose ﬁlter relations can express F. Having proven the existence of uninterpreted model J[f 7→ v], such that J[f 7→ v] |= φ ∧ Σ that I |= φ ∧ Σ also applicable to SHACL templa te satisﬁability, and the complexity of the corresp onding decision pro cedures can be considered an upper bound for the complexity of SHACL template satisﬁability in the same fragment, when it is at leas t polynomial. This, in turn, allows us to extend our positive results to many of the additional decis ion problems discussed in Section 7. SCL Satisﬁability fragments of SCL. Some of the proven and derived results are visualise d in Figure The decidability res ults are proved via embedding in known decidable (extensions of) fragments of ﬁrst-order logic, while the undecidability ones are obtained throug h r e ductions from the classic domino proble m [ but through axiomatisation, the only interpreted relations are equality and orderings between elements. w.r.t. two aspects. First, it misses few fragments whose decidability can be immediately derived via inclus ion into a more expressive decidable fragment, e.g., Z A D E C or S Z A T D. Second, the rest of the missing cases have an open decidability problem. In particular, while there are several decidable fragments containing the T feature, we do not know any decidable fragment with the O or O’ features. Notice that the undecidability results exploiting the last two features are only applicable in the case of generalised RDF. 7.1. Decidability Results to express properties writable by combining the S, Z, and A features. In particular, the last one does not increase in expressive power when the D and O features are also taken in consideration. Theorem 8. There are (a) semantic-preserving and (b) polynomial-time ﬁnite-modelinvariant satisﬁability-preserving t ranslations among the following SCL fragments: 1. ∅ ≡ S ≡ Z ≡ A ≡ S Z ≡ SA ≡ ZA ≡ SZA; 2. D ≡ AD; 3. O ≡ AO; 4. DO ≡ ADO. Proof. To show the equivalences among the fourteen SCL fragments mentioned in the statement, we consider the following ﬁrst-order formula equivalences that represent few By this theorem, the positive decidability results that we will present in Sect. 7 are We ﬁnally embark on a detailed analysis of the satisﬁability problem for diﬀerent For the sake of clarity and readability, the map depicted in the ﬁgure is not complete As a preliminary result, we show that the base language ∅ is already powerful enough distributive pro perties enjoyed by the S, Z, and A features w.r.t. some of the other language cons tructs. The veriﬁcation of their correctness only requires the applicatio n of standard properties of Boole an connectives and ﬁrst-order quantiﬁers. • [S] T he s equence combination of two path formulae πand πin the body of an existential quantiﬁcation is removed by nesting two plain quantiﬁcations, one for each π: • [Z] The Z path construct can be removed from the body of an existential quantiﬁcation on a free variable x by verifying whether the formula ψ in its scope is already satisﬁed by the value bound to x itself: At this po int, the equivalenc e s between the fragments naturally follow by an iter ative application of the reported e quivalences used as rewriting rules. This clearly concludes the proof of Item however, to an exponential blow-up in the size of the formula due to the duplication of the body ψ of the quantiﬁcation. There fore, to prove Item ﬁnite-model-invariant satisﬁability-preserving translations, we ﬁrst construct from the given sentence ϕ a ﬁnite-model-invariant equisatisﬁable sentence ϕ linear in the original one and all the bodies of its quantiﬁcations are just plain relations. Then, we apply the above describ e d semantic-preserving translations to ϕ worst case, only leads to a doubling of the size. The sentence ϕ applying to ϕ the following two rewriting opera tions, until no complex formula appears in the scope of an existential quantiﬁcation. Let ψ where ψ(y) does not contain quantiﬁers other than possibly those of the S, D, and O features. Then: (i) replace ψ relation; (ii) c onjoin the resulting sentence with ∀x. Σ(x) ↔ ψ(x). The two rewriting operations in isolation only lea d to a constant increase of the size and are applied only a linear number of times. with universal roles, inverse roles, and nominals [3]. This resemblance is eﬀectively exploited as a key observation at the core of the following result. Theorem 9. All SCL subfragments of SZA enjoy the ﬁnite-model property and an ExpTime-complete s atisﬁ ability problem. Proof. The ﬁnite-model property follows from the fact that the subsuming S Z A D fragment enjoys the same prop erty, as shown later on in Theo rem can focus on the base fragment ∅. logic ALC e xtended with inverse roles and nominals (ALCOI) [ deprived of the universal quantiﬁcations at the level of sentences (i.e., the ∅ subfragment generated by grammar rule ϕ := ⊤ | ϕ ∧ ϕ | Σ(c)) ar e linearly interreducible. Indeed, every existential modality ∃R.C (resp., ∃R SCL construct ∃y. R(x, y) ∧ ψ the r ecursive tr anslation of the concept C. Moreover , every nominal n corresponds to the equality construct x = c • [A] The removal of the A path construct from the body of an existential quantiﬁer or of the D and O constructs can be done by exploiting the following eq uivalences: ∀y, z. (π(x, y) ∨ π(x, y)) ∧ R(x, z) → σ(y, z) ≡ (∀y, z. π(x, y) ∧ R(x, z) → σ(y, z)) ∧ The removal of the Z and A constructs from an existential quantiﬁcation might lead, It turns out that the base language ∅ resembles the description logic ALC extended As far as the satisﬁability problem is concerned, thanks to Item1 of Theorem 8, we On the one hand, on the hardness side, one can b e observe that the description symbols is considered. At this point, since the aforementioned description logic has an ExpTime-complete satisﬁability problem [28, 11], it holds that the same problem for all subfragments of S Z A is ExpTime-hard. tions at the level of s entences can be encoded in the further extension of ALC with the universal role U [ Indeed, the universal sentences of the form (a) ∀x. isA(x, c) → Σ(x), (b) ∀x, y. R Σ(x), (c) and ∀x. Σ(x) ↔ ψ(x) can be translated, respectively, as follows: (a) n ∀isA where C those – E and A E – are included in Figure in the two-variable fragment of ﬁrst-order logic [21]. Theorem 10. The ZADE fragment of SCL enjoys the ﬁnite-model property and a NExpTime satisﬁability problem. Proof. Via a syntactic inspection of the SCL grammar o ne can observe that, by avoiding the S and O features of the language, it is only possible to write formulae with at most two free variables. For this reason, every Z A D E-formula belongs to the two-variable fragment of ﬁrst-order logic [ ﬁnite-model property and a NExpTime-complete satisﬁability problem [ generalise d when the C feature is added to the picture. However, the gained a dditional expressive powe r does not come without a price, since the ﬁnite-model pro perty is not preserved. Theorem 11. The non-recu rsive C fragment of SCL does not enjoy the ﬁnite-model property (on both sentences and formulae) and has a NExpTime-hard satisﬁability problem. Nevertheless, the ﬁnite and unrestricted satisﬁability problems for the ZADEC fragment are NExpTime-Complete. Proof. As for the proof of Theorem belongs to the two -variable fragment of ﬁrst-order logic e xtended with counting quantiﬁers. Such a logic does not enjoy the ﬁnite-model property [ contains a sentence that encodes the existence of an injective non-surjective function from the domain of the model to itself. The non-recursive C fragment of SCL allows us to express a similar property via the following sentence ϕ, thus proving the ﬁrst part of the statement: Intuitively, the ﬁrst three conjuncts of ϕ force every mo de l of the sentence to c ontain a distinguished element 0 that (i) does not have any R-predecessor and (ii) is related to an arbitrary but ﬁxed constant c w.r.t. isA. In other words, 0 is contained in the On the other hand, completeness follow s by observing that the universal qua ntiﬁca- .Σ, where nis the nominal for the constant c; (b) ∀U .∀R.Σ; (c) ∀U .(Σ ↔ C), is the concept obtained by translating the ∅- formula ψ into ALCOI. To derive properties of the Z A D E fragment, together with its sub-fragments (two of The embedding in the two-variable fragment used in the previous theorem can be ψ(x) , ¬∃y. R(x, y); ψ(x) , ∃y. (R(x, y) ∧ isA(y, c)) ∧ ¬∃y. R(x, y). domain of the relation isA, but is not contained in the image of the relation R. Then, the ﬁnal conjunct of ϕ ensures that every element related to c w.r.t. isA has exactly one R-successor, also related to c in the same way, and at most one R-predec e ssor. Thus, a model of ϕ must contain an inﬁnite chain of elements pairwise connected by the functional relation R. present at the level of constraints, a s witnessed by the following C-formula, where the constant 0 is replaced by the existentially quantiﬁed variable x, where ψ are the previously introduced formulae with one free variable: semantically subsumes the description logic ALC extended with inverse roles, nominals, and cardinality restrictions (ALCOIQ) [3]. Indeed, every qualiﬁed ca rdinality restriction (≥ n R.C) (resp., (≤ n R.C)) precisely corresponds to the SCL construct ∃ of the concept C. Thus, the hardness result for C follows by recalling that the speciﬁc ALC language has a NExpTime-hard satisﬁability problem [ order logic with counting quantiﬁers has decidable ﬁnite and unrestricted satisﬁa bility problems. Speciﬁcally, both can be solved in NExpTime, even in the case of binary encoding of the cardinality constants [ follows as well. embedding in the unary-negation fragment of ﬁrst-order logic [6]. When the T feature is considered, the same embedding can be adapted to rewrite S Z A T D into the e xtension of the mentioned ﬁrst-order fragment with regula r path expres sions [ as for the addition of the C feature to Z A D E, we need to pay the price of losing the ﬁnite-model property. Theorem 1 2. The SZAD fragment of SCL enjoys the ﬁnite-model property, while the non-recursive STD fragment does not ( on both sentences and formulae). Nevertheless, the ﬁnite and unrestricted satisﬁability problems for the SZATD fragment are s olvable in 2ExpTime. Proof. By inspec ting the SCL gra mmar, one can notice that every formula that does not make use of the T, E, O, and C constructs can be translated into the standard ﬁrst-order logic syntax, with conjunctions and disjunctions as unique bina ry Boolean connectives, where negation is only applied to formulae with at most one fre e variable. For this reason, every S Z A D-formula semantically belong s to the unary-negation fragment of ﬁrst-order logic, which is known to enjoy the ﬁnite-model property [ of ﬁrs t-order logic extended with regular path expressions [16]. Indeed, the gramma r rule π(x, y) of SCL, precisely resembles the way the regular path expressions are constructed in the considered logic, whe n one avoids the test construct. Unfortunately, as for the two-variable fragment with counting quantiﬁers, this logic also fa ils to satisfy It is interesting to observe that the ability to model an inﬁnity axiom is already eψ(z) , (z = c) ∧ ∃x. (isA(z, x) ∧ ψ(x)) ∧ ∀x. isA(z, x) → ψ(x). By generalising the proof of Theorem9, one can notice that the C fragment of SCL (y) (resp., ¬∃y. R(x, y) ∧ ψ(y)), where ψrepresents the recursive translation On the positive side, however, the extension of the two-variable fragment of ﬁrst- For the S Z A D fra gment, we obta in model-theoretic and complexity results via an Mutatis mutandis, every S Z A T D-formula belongs to the unary-negation fragment the ﬁnite-model property since it is able to enc ode the existence of a non-terminating path without cycles. The non-r ecursive S T D fragment of SCL allows us to express the same property, as described in the following. First of all, consider the S T-path-formula π(x, y) , ∃z. (R and y of a model iﬀ there exists a non-trivial R-path (of arbitrary positive length) that, starting in y, leads to x. Now, by wr iting the S T D- formula ψ(x) , ¬∃y. (π(x, y)∧R(x, y)), we ex press the fact that an element x does not belong to any R-cycle since, otherwise, there would be an R-succes sor y able to reach x itself. Thus, by ensuring that every element in the model has an R-successo r, but does not belong to any R-cycle, we can enforce the existence of an inﬁnite R-path. The non-rec ursive S T D sentence ϕ expresses exactly this property, where c is an arbitrary but ﬁxed constant: order logic with arbitrary transitive relations or, more generally, with regular path expressions has decidable ﬁnite and unrestricted satisﬁability problems. Speciﬁcally, both can be solved in 2ExpTime [ very weak form of co unting restriction which is, however, powerful enough to describe an inﬁnity axiom. Theorem 13. The non-recursive O and EO model property (on both sentences and formulae). Proof. Similarly to the use of the C construct of SCL, a simple combination of just few instances of the O feature allows us to write the following sentence ϕ encoding the existence of an injective function that is not surjective. Indeed, a weaker version of the r ole of the counting quantiﬁer is played here by the O’ construct that enfor ces the functionality of the two relations R and S . Then, by applying both O’ and O to the inverse o f R and S, we e nsure that S is equal to R latter is functional as well. Hence, the statement of the theorem immediately follows. enough to re place the last two applications of the O’ and O features with the E-formula ∀y. R with one free variable, where ψ ϕ , isA(0, c) ∧ ∀x. isA(x, c) → (ψ(x) ∧ ∃y. (R(x, y) ∧ isA(y, c))). The same can be stated via the following non-r ecursive S T D-formula: eψ(z) ,(z = c) ∧ isA(0, z) ∧ ∀x. isA(z, x) → (ψ(x) ∧ ∃y. (R(x, y) ∧ isA(y, c))). On the positive side, however, the extension of the unary-negation fr agment of ﬁrst- At this po int, it is interesting to obser ve that the O feature allows us to express a ϕ , isA(0, c) ∧ Σ(0) ∧ ∀x. Σ(x) ↔ ψ(x) ∧ ∀x. isA(x, c) → ψ(x); ψ(x) , ¬∃y. R(x, y); ψ(x) , ∃y. (R(x, y) ∧ isA(y, c)) ∧ ∀y, z. R(x, y) ∧ R(x, z) → y ≤ z ∧ ∀y, z. S (x, y) ∧ S (x, z) → y ≤ z ∧ ∀y, z. R(x, y) ∧ S(x, z) → y ≤ z ∧ ∀y, z. R(x, y) ∧ S(x, z) → y ≥ z. To s how that the E O’ fragment does not enjoy the ﬁnite-model property too, it is (x, y) ↔ S (x, y), which clearly ensures the functionality of R, being S functional. Notice that also in this case we can express the a bove property at the level of formulae eψ(z) , (z = c) ∧ ∃x. (isA(z, x) ∧ ψ(x)) ∧ ∀x. isA(z, x) → ψ(x). 7.2. Undecidability Results problem for several fragments of SCL through a semi-conservative re duction from the standard domino problem [ tiling system hT, H , V i is a s tructure built on a non-empty set T of domino types, a.k.a. tiles, and two horizontal and vertical matching relations H , V ⊆ T × T. The domino problem asks for a compa tible tiling of the ﬁrst quadrant N×N of the discrete plane, i.e., a solution mapping ð : N ×N → T such that, for all x, y ∈ N, both (ð(x, y), ð(x+1, y)) ∈ H and (ð(x, y), ð(x, y + 1)) ∈ V hold true. Theorem 14. The sentence satisﬁability problems of the non-recursive SO, SAC, SEC, SEO Proof. The main idea behind the proof is to embed a tiling system into a model of a particular SCL sentence ϕ that is satisﬁable iﬀ the tiling system a llows for an admissible tiling. The hardes t part in the reduction consists in the deﬁnition of a satisﬁable sentence all of whose models homomorphically contain the inﬁnite grid of the tiling problem. In other words, this sentence should admit an inﬁnite square grid graph as a minor of the model unwinding. Give n that, the remaining part of the reduction can be carried out in the base language ∅. deﬁnition: Intuitively, the ﬁrst conjunct ensures the existence of the point 0, i.e., the orig in of the grid, labelled by some arbitrary tile in the set T. Notice that T is lifted to a set of constants in SCL. The second conjunct, then, states that all points x, labelle d by some tile t, need to satisfy the properties expressed by the two monadic formulae ψ tiling, while the second one, called grid formula, forces all models of ϕ to necessarily embed a grid. The ﬁrst conjunct of the tiling formula ψ argument x is la belled by no other tile than t itself. The second part, instead, ensures that the points y on the right or above of x are labelled by some tile t t, w.r.t. the constraints imposed by the horizontal H a nd vertical V matching relations, respectively. Notice here that the relation symbols H and V are the syntactic counterpart of H and V , respectively. In the remaining part of this section, we show the undecidability of the sa tis ﬁability , and SZAE fragments of SCL are undecidable. Independently of the fragment we choose to prove undecidable, consider the following ϕ ,WisA(0, t)∧V∀x. isA(x, t) → (ψ(x) ∧ ψ(x)). (x). The ﬁrst one, called tiling formula, is used to ensure the admissibility o f the ψ(x) ,¬isA(x, t) ∧∀y. H(x, y) →isA(y, t)∧∀y. V(x, y) →isA(y, t). The ﬁrst two conjuncts gua rantee the existence of an horizontal and vertical adjacent of the point x, while the subformula γ(x), whose deﬁnition depends on the considered fragment of SCL, needs to enfo rce the fact that x is the origin of a square. In other words, this means that, going horizontally and then vertically or, vice versa, vertically and then horizontally, the same point is reached. To do this, we make use of the two S-pathformulae π cases, we also conside r the S A-path-formula π previous ones, which implicitly deﬁne a diagonal relation. We now proceed by a case analysis on the speciﬁc fragment. At this point, we can focus on the grid formula ψ(x) deﬁned as follows: • [SO] B y assuming the existence of a non- empty relation D connecting a point with its opp osite in the square, i.e., the diagonal point, we can express the fact that all points reachable through πor πare, actually, the same unique po int: The S O-formula γ(x) ensures that the relation D is both no n-empty and functional and that all points reachable via πor πare necessarily the single one reachable through D. • [SAC] By applying a counting quantiﬁer to the formula π, which encodes the union of the p oints reachable through πor π, we can ensure the existence of a single diagonal point: • [SEC] As for the S O fragment, here we use a diagonal relation D, which needs to contain all and only the points r eachable via πor π. By means of the counting quantiﬁer, we enforce its functionality: • [SEO] This case is similar to the previous one, where the functionality of D is obtained by means of the O’ construct: Now, it is not hard to see that the above sentence ϕ (one for each fragment) is satisﬁable iﬀ the domino instance on which the reduction is based on is solvable. Indeed, on the one hand, every compatible tiling ð : N × N → T of a tiling system hT, H , V i induces a grid model that trivially satisﬁes ϕ. On the other hand, a model of ϕ neces sarily embed a grid whose points are labelled by tiles satisfying the horizontal and vertical relations. Theorem 15. The formula satisﬁability problems of the non-recursive STO, SATC, STEC, STEO • [SZAE] The proof for this ﬁnal case is inspired by the one proposed for the undecidability of the guarded fragment extended with transitive closure of binary relations [13]. This time, the functionality of the diag onal relation D is indirectly ensured by the conjunction of the four formulae γ(x), γ(x), γ(x), and γ(x) that exploit all the features of the frag ment: where γ(x) , ∀y.D(x, y)↔ D(x, y), γ(x) ,¬∃y. D(x, y)∧∀y. D(x, y) → ∃z. D(y, z), γ(x) ,∀y.x = y ∨ D(x, y) ∨ D(x, y)↔ E(x, y), and γ(x) ,∀y.(∃z. (E(x, z) ∧ E(z, y))) ↔ E(x, y). Intuitively, γasserts that D is the union of the two accessory relations Dand D, while γguarantees that a point can only have adjacents w.r.t. just one relation Dand that these adjacents can only a ppear as ﬁrst argument of the opposite relation D. In addition, γensures that the additional relation Eis the reﬂexive symmetric closure of Dand γforces Eto be transitive too. We can now prove that the relation D is functional. Suppose by contradiction that this is not case, i.e., there exist va lue s a, b, and c in the domain of the model of the sentence ϕ, with b 6= c such that b oth D(a, b) and D(a, c) hold true. By the formula γand the ﬁrst conjunct of γ, we have that D(a, b) and D(a, c) hold for exactly one index i ∈ {0, 1}. Thanks to the full γ, we surely know that a 6= b, a 6= c, and neither D(b, c) nor D(c, b) can hold. Indeed, if a = b then D(a, a). This in turn implies D(a, d) for some value d due to the second conjunct of γ. Hence, there would be pairs with the same ﬁrst element in both relations, triv ially violating the ﬁrst conjunct of γ. Similarly, if D(b, c) holds, then D(c, d) needs to hold as well, for some value d, leading again to a contradiction. Now, by the formula γ, both E(b, a) and E(a, c) hold, but E(b, c) does not. However, this clearly contradicts γ. As a consequence, D is necessarily functional. , and SZATE fragments of SCL are undecidable. Proof. The proof of this theorem builds on top of the one of the previous result, by showing that, with the addition of the transitive closure operator, we can encode the solution of a domino problem as the existence of a consta nt satisfying the following SCL formula ψ(x), where the r elation symbols H and V and the tiling and grid formulae ψ and ψ Intuitively, the for mula ψ(x) is satisﬁed by a constant c if this element is labelled by a tile in T and every other element y, reachable from c via an arbitrary numbers of horizontal steps followe d by another arbitrary number of vertical steps, satisﬁes both the tiling and grid formulae. Obviously, ψ(x) is satisﬁed at the root of a grid model induced by a compatible tiling ð : N × N → T of a tiling sy stem hT, H , V i. Indeed, every node in the grid is reachable from the root by following a ﬁrst-horizontal then-vertical path. Moreover, its labe lling is coherent with what is prescribed by the two matching relations H and V , so, ψ satisfying ψ(c) induces a compatible tiling, as the set of elements reachable from c form a grid, due to the formula ψ 8. Conclusion documents and shape constraints. In order to do so, we examined several recursive semantics proposed in the literature and proved that they all coincide for non-re cursive documents. As well, we proved that one can focus only o n total assignments sema ntics since partial assignments semantics reduces to it. We then provided a complete translation between: (1) non-recursive SHACL and SCL, a new fragment of ﬁrst-order logic extended with counting quantiﬁers and transitive closure, (2) recursive SHACL and MSCL, a n extension of SCL into a monadic second-order logic, where shape names become monadic second-order variables. These translations into ma thematical logic are eﬀective since, ﬁrstly, they oﬀer a standard framework to model the language, contrary to previous ad hoc modellings, and, secondly, they allow us to study several for mal properties: from capturing the semantics of ﬁlters (that have not been addressed in literature before), to laying out a detailed map of SHACL fragments for which we are able to prove (un)decidability alo ng with complexity results, for our decision problems. We also expose semantic pr operties and asymmetries within SHACL which might inform a future update of the W3C language speciﬁcation. Although the satisﬁability and containment problems are b oth undecidable for the full SHACL, decidability can be achieved by restricting the usage of certain SHACL components, such as cardinality restrictions over shape or path properties. Nevertheless, the status of some weak fragments of SHACL, such as O, S C, and S E, remains an open question for further investigation. are deﬁned as in Theo rem14: ψ(x) ,isA(x, t) ∧ ∀y.(∃z. (H(x, z))∧ (V(z, y))) →isA(y, t) → (ψ(y) ∧ ψ(y)). (y) necessarily holds at every no de of the grid. Vice versa, every structure In this article we have studied the satisﬁability and containment pr oblems for SHACL Acknowledgements ing Enhancement Project and a UoS Web Science Institute Stimulus Fund. F. Mogavero has been partially supported by the GNCS 2020 project “Ragionamento Strategico e Sintesi Automatica di Sistemi Multi-Agente”. G. Kons tantinidis has been partially supported by an Alan Turing Fellowship, a Tur-