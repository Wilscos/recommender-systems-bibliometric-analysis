Formal methods (FMs) have been an active research area for decades. Theoretical foundations [36], method applications [2, 10, 2 7], as well as eﬀective ways to trans fer [47, 50] them to the practising engineer have been thoroughly discussed and empir ically evidenced [5 2, 57]. The resources to learn about these methods range from early syllabuses [24] to recent course materials, papers (e.g., [8]), tool manuals, wiki. teaching-based transfer is still missing [23, 26]. Driven by the inspiration and critique of expert voices from academia [4, 11, 29, 42, 45, 51] and industry [1], formal methods are co nsidered to be one gleirscher@uni-bremen.de, Univer sity of Bremen, Germany jim.woodcock@york.ac.uk, University of York, United Kingdom Formal methods were frequently shown to be eﬀective and, perhaps because of that, practitioners are interested in using them more often. Still, these methods are far less applied than expected, particularly, in critical domains where they are strongly recommended and where they have the greatest potential. Our hypothesis is that formal methods still seem not to be applicable enough or ready for their intended use. In critical software engineering, what do we mean when we sp eak of a formal method ? And what does it mean for such a method to be applicable both from a scientiﬁc and practical viewpoint? Based on what the literature tells abou t t he ﬁrst question, with this manifesto, we lay out a set of principles that when followed by a formal method give rise t o its mature applicability in a given scope. Rather than ex ercising criticism of past developments, this manifesto strives to foster an increased use of formal metho ds to the maximum beneﬁt. However, evidence on successful formal method teaching, training, and of the most promising tools to develop highly dependable software for critical applications [23]. Developers of formal methods have always aimed at applicability in pr actical contexts, notably with diﬀerent degrees of success. Indeed, many practitioners believe in the high potential of such methods and would use them to their maximum beneﬁt, w hether directly or through p owerful software tools [26]. Although, there is wide interest in applying these methods in the engineering practice of dependable systems and software, this domain has not yet successfully adopted formal methods. It is observed (e.g., [23, 2 6]) that their use is still signiﬁcantly weaker than expected, most alarmingly, even in critical domains [25] where their application is, in parts a nd through a wide range of standards (e.g., IEC 6 1508 and 62443, DO -178), strongly recommended. It is thus reasonable to assume that FMs (still or again) seem not to be applicable enough (or ready) for their intended purpose. An alternative explanation would be that modern programming languages and environments implicitly support a good part of what would have been called formal development in the period from the 1970s to the 1990s and avoid many of the hard sought-after errors, FMs were originally supposed to unveil. This explanation is, however, only reasonable if we ignor e the mas sive inc rease in software and hardware complexity since then and the increa se in use of software in critica l ar eas. Consequently, new kinds of problems and er rors have shown up and the original justiﬁcation for the use of FMs remains valid, albeit at diﬀerent levels of abstraction. In that light, the beneﬁcial use of formal methods is hindered, for example, by poor scalability, miss ing or inadequate tools, sc arce tea ching and tra ining, and thus a lack of trained personnel [26]. The lack of recent knowledge about these obstacles and the eﬀectiveness and productivity of formal methods [25] raise a high demand for formal method research and goal-directed collaborations between academia, regulato rs, and industry. To help research and transfer eﬀorts gain momentum and foster success, we suggest some guiding principles of applicable formal methods in fo rm a manifesto. Outline. The Sections 2 and 3 provide the background and motivation of this manifesto and highlight related work. Section 4 presents the manifesto and its principles. Section 5 highlights several formal methods succe ss stories. Section 6 summarises aims, suggests actions to implement the manifesto, a nd outlines expected impacts of these actions. Section 7 warns about potential consequences of inaction by the community, and Section 8 concludes. What is a “formal method”? There are many useful characterisations available from the litera ture. For example, the IEEE Software Engineering Body of Knowledge says: “formal methods are software engine e ring methods used to specify, develop, and verify the software through application of a rigorous mathematically based notation and language” [37, p. 9-7, Sec. 4.2]. This recent deﬁnition [6] covers the relevant aspects quite well, stating that “formal methods are a set of techniques based on logic, mathematics, and theoretical computer science which are used for specifying, developing, and verifying software and hardware systems.” We slightly reﬁne this notion, saying that, by a formal method, we refer to an explicit mathematical model and sound logical reasoning about critical proper ties [55]—such as re liability, safety, security, depe ndability, performance, uncertainty, or cost—of a class of electrical, electronic, a nd programmable electronic or software systems. Mo del checking, theorem proving, abstract interpretation, assertion checking, and formal contrac ts are classical examples of versatile formal methods. What makes formal methods so special? Generally, a method can be thought of as a step-wise recipe providing guidance for its user regarding the next steps to take in certain situations. In analogy to other e ngineering disciplines, a formal method pushes the role of mathematics and logic in software engineering • make objects explicit (e.g., natural processes, information, peoples’ thoughts) • reduce ambiguity about or subjective interpretation of these objects (e.g., • support mechanisation of critical or tedio us tasks (e.g., analysis, veriﬁca- These features enable one to distinguish formal from informal (or “non-formal”) methods. opment or analysis method and diﬀerent from a programming language or a software engineering tool. Although there is no clear boundary between formal and informal methods (formality may occur in degrees), one can be of the opinion tha t a software engineering method is “informa l” if the use of mathematics and logic is neither essential nor required to cr eate reliable results, and it is “formal” other w ise. What do we mean by “applicability”? Generally, “applicable” means capable of being applied, within some deﬁned and practically relevant scope. More speciﬁcally, applying a formal method involves its use in the design, development, and analy sis of a critical system and its substantial integration with the used development metho dologies (e.g., structured de velopment, model-based engineering, as sertion-based programming, test-driven development), speciﬁca tion and modelling notations (e.g., UML, SysML), programming languages, and through notation with a precis e meaning agreed within a domain, a system o r its functioning) and foster a precise understanding of that domain, and tion). A for mal method is more than a (modelling) notation or a develtools. When we use the terms “applicable” or “applicability”, we refer to a desirable degree or level of maturity notion sug gests some quantitative (e.g., performance or economic) assessment to be able to make objective statements about the level of maturity and, thus, the applicability of a formal method. When do we expect a formal method to be applicable? We need applicability whenever we suggest a FM as a critical (quality assurance) instrument to be use d in a critical engineering task. That task will primarily be a practical software engineering task but it can also be an engineering task in computer science research and teaching. We need applicability if the expected beneﬁt from using a forma l method in a task (e.g., early e rror reduction, design improvement, didactic gain, scientiﬁc insight) justiﬁes the expected cost of applying it (e.g., formalisation eﬀort, time, and resources) but it does not justify the cost of not applying it (e.g., late failure handling costs, failure consequences). What makes formal method applicability so special? What makes it diﬀerent from applicability of other modelling or programming methods, techniques, or languages? A formal method requires one to use (through tools and with guidance) mathematical structures to r epresent and make concise the meaning of o bjects (e.g., software or system behaviour, data sets) to be reasoned upon. The proper understanding and eﬃcient use of such structures needs special abstrac tion capabilities, mathematical skills to be ta ught, and continuous application-oriented training. An applicable formal method is a method that addresses these very speciﬁc requirements in this particular context. What is a manifesto and why do we need one? A manifesto can be understood as “a series of technical or expert views o n a particula r engineering task” [43], “a set of commitments” of a community [53], or “a focal point of reference” catalys ing communities [7]. Inspired by successful similar eﬀorts in other domains [7], among stakeholders (e.g., e xperts, thought leaders, user s) in a domain, it is based on corresponding deﬁnitions, it concisely conveys g uidance in terms of principles, it discloses aims a nd commitments in form of an appeal, it suggests actions, and it can join forces and, thus, initiate change. Our manifesto can be seen as a speciﬁc supplement of the Veriﬁed Software Initiative [34], which has the long -term aim to perform wide-ra nging veriﬁcation experiments and case studies, improve the tool landscape , and foster transfer of FM research to industry. Ladkin’s manifesto [43, Ch. 10] includes principles and steps of how formal methods could be used in practical and s tandard-compliant software assurance. While his manifesto covers many areas of software as surance, the section on FM guidance concentrates on the use of FMs in assurance. Our manifesto c omplements Ladkin’s with guidance on how to prepare FMs to be applicable in assurance and beyond. Rae et al.’s manifesto [53] aims at an improvement in the use of research methods in s afety science, not touching on FM applicability in software safety. We present the manifesto with its goa ls, principles, and aims concisely in Table 1 and then explain and comment on each principle in more detail. The Ten Principles of Applicable Formal Methods. In order to evidence applicability both in research and in practical software engineering, a formal method should ideally implement all of the following principle s. Methodology It should provide a step-wise recipe, procedural guidance for Integration It should create beneﬁts through integration w ith other meth- Explainability After a successful application of a formal metho d, it should be and come with c omprehensible guidance on how it is to be applied within that given scope. The restriction to a limited scope can reduce the c omplexity of the formal model and, thus, increase Ease of Us e a nd support other principles. method users regarding poss ible next steps to be taken in corresponding situations. For example, it should support composition, modularity (e.g., using formal reasoning [16] about contrac ts [46]), and reﬁnement, and come with a variety of so und abstraction or simpliﬁcation techniques. ods. For example, it should be integr atedwith (i) an established formal method or (ii) a widely-used modelling technique (e.g., UML State Charts), (iii) programming language (e.g., Java), or (iv) process model (e.g., Scrum). Integration in this way is supposed to increase Usefulness and Ease of Use. clear what has been de monstrated. A minimal requirement is that it can be stated precisely which claim has been established (as in a mathematical theorem). A stricter requirement is that a certiﬁcate can be generated, Automation It should come with tool suppo rt that prevents its user from Scalability It should be applicable at a practically relevant scale, Transfer It should be accompanied with a teaching and training strategy and Usefulness Its e ﬀectiveness should be evidenced. For example, it should be Evaluation It should demonstrate its applicability in a credible way (e.g., with which enables checking the claim independently. L ast but not least, it requires that the claim (including the under lying modeling assumptions) can be communicated to human domain experts and maybe even to end users. Expla inability in this way is suppos ed to increase Usefulness . tedious work steps and helps them to focus on essential and creative steps. In particular, it should provide automation suppor t for any obvious/useful abstraction required to be crafted to apply the method to the maximum bene ﬁt. Automation usually pertains to diﬃcult or tedious tasks and can, thus, inc rease Scalability towards industrial-sized systems. with reasona ble e ﬀo rt as a function of that scale. This principle is likely to be fostered by a clear Methodology (e.g., superior alg orithms, abstraction, modular approaches) and strong Automation. corres ponding mater ials.This strategy and the materials may diﬀer from one formal method to another. However, also averag e graduate students and experienced engineers should be able to learn and apply a method with reasonable eﬀort. demonstrated (e.g., by means of case studies or controlled experiments) what would have been diﬀerent if a c onventional or non-formal alternative had been used instead (e.g., through comparison of relative fault-avoidance or fault-detection eﬀectiveness and the economic impacts of these metrics). Usefulness as the governing factor for applicability will be a result of other principles, such as Explainability. vide concepts, abstractions, or modelling and reasoning primitives that help users with appropriate skills (cf. Training) to apply it with reasonable eﬀort (e.g., low abstraction eﬀort, low proof complexity, high productivity) within the speciﬁe d scope. Ease of use will be a result of other principles, such as Scalability and Automation. Usefulness and Ease of Use refer to the two main constructs of the Technology Acceptance Model [17], a widely used model for the assessment of end-user information technology. representative examples, with tools usable by other resear chers or prac- There is plenty of anecdotal and stronger evidence on applicable formal methods, not least in the form of succes s stories of research integration, application, and transfer. Unifying Theories of Programming (UTP) is Hoare & He’s long-term research ag enda [33]. Their intention is to explore a common basis for understanding the semantics o f the modelling notations and pro gramming languages used in describing the be haviour of computer-bas ed systems. Their technique is to de scribe diverse modelling and programming paradigms in a common semantic setting. They isolate the individual features of these paradigms to emphasise commonalities and diﬀerences. They devise formal, often approximate, links between theories to translate predicates from one theory into another. The links also translate speciﬁcations into designs and prog rams as a development method. Understanding the links between formal metho ds is importa nt, especially for building tool chains for heteroge neous approaches. Beyond the bottom-up construction of tool chains, the AutoFOCUS project [12, 35] is an example of a long-term eﬀort to provide a formally based seamless speciﬁcation, modelling, and development environment, with methodological support from requirements capture down to code generation, testing, and artefact evolution. Several large case studies in model-based development of embedded software were conducted over the years using diﬀerent AutoFOCUS generations. The proﬁt from FMs is suppose d to be maximal, when thoroug hly integrated in a company’s design and veriﬁcation processes [25]. The chip industry was one of the ﬁr st sectors where (automated) theorem provers and model checkers have been routinely applied to scrutinize their ever more complex circuits, for instance at INTEL [22, 30], IBM [9] and Oracle [54]. Perhaps this is due to the fact that chips are ma ss produced, hence the costs of errors are high, thus the eﬀort of applying FMs paid oﬀ early. Another traditional sector fo r the application of formal methods is the railway signalling domain, which can be easily explained by their safety-critical nature. Very e arly applications of formal methods to railways have been reported [20]. Many Euro pea n projects (e.g., FMERail, INESS) and indeed whole conferences (e.g., RSSRail titioners) that it is applicable to the rang e of engineering problems and systems in its speciﬁed scope. It should provide information about both its beneﬁts and foreseen challenges, limitatio ns, or barriers when applied. This principle integrates the scientiﬁc method into the argumentation of FM applicability. railway domain. Although this could still be an academic ex ercise, increas ingly the agenda of formal methods in railways is set by engineering companies (SHIFT2RAIL are fastly building up expertise centers in model based so ftware engineering and formal veriﬁcation. In the past, a successful route to the wider deployment of formal methods in practice has been the standardisa tion of their notations, for example, through ISO. Notable standardisation eﬀo rts in this regard are, for instance, LOTOS [38], SDL [40], a nd the Z notation [39]. Finally, formal methods are now also applied routinely in purely softwarebased platforms. An important initial example was the SLAM project at Microsoft [3], aimed at Windows de vice driver complia nc e . Also Facebook [18, 50] and Amazon Web Services [15, 48] have reported on the application of formal methods for their infrastructure at a mas sive scale. Perhaps, this happened because FMs have matured. Another possible explanation is that the availability and secur ity requirements to contemporary software platforms ar e extremely high. These platforms have taken up the role of critical infrastructur e . Other highlights in veriﬁed software are the formally veriﬁed optimizing compiler CompCert [44] and the formally veriﬁed Operating System Microkernel s eL4 [31]. It could be argued that an even wider adoption can only be realized by making FM available to average software engineers, who have received a MSc degree in computing or engineering. Apa rt from professional, easy to use tool support, this requires insight in the trade-oﬀ between investments in and beneﬁts from FM application, a s advocated in [21]. It also require s an integration of FM tools with other artefacts in the usual des ign processes, for instance in agile development [28]. The evidence available from these success stories range s from single to aggrega ted opinions of experts as well as anecdotal to very systematic case studies and thorough yet sporadic tool evaluations. However, data from across a representative range of samples has hardly ever been rigorously measure d (e.g., using controlled method experiments). Hence, albeit impressive, this ev ide nc e is still insuﬃcient to underpin a strong argument for a wider deployment of formal methods in industry. And without such a deployment, further FM research is at risk of getting inapplicable. A manifesto should of course follow a certain aim, suggest possible actions, disclose the vario us impa cts hoped for, and disc uss relevant implications. Overview of Expected Impacts of the Manifesto. We expect a manifesto on applicable formal methods to: 1. Foster the collection (and curation) of real (small, medium, large) 2. Provide guidance on how to perform for mal method case studies and 3. Stimulate new research proposals and interdisciplinary research col- 4. Strengthen the community of researchers that (i) perform evalua- We detail some of these impact categories below. Impact on the Conduct, Writing, and Review of Formal Method Research. Showing the novelty of research on applicable formal methods w.r.t. the state o f the art is more complicated than showing the novelty of a particular formal technique. A formalism and its expressive power can be explained by examples and the superiority of an algorithm or tool can be demonstrated by experiments, e.g., comparing a range of settings. However, the evaluation of the applicability of a formal method as a whole is more intricate. So, what is the recommended way for resea rch on applicable formal methods? How can one demonstrate its novelty w.r.t. the state of the ar t? A few (old) answers [5] within software engineering research are: ca se studies [59], action research [56, Sec. 5.5] and controlled method experiments [58] [56, Ch. 8]. Following these methods would gre atly beneﬁt the FM community; Yin’s guidelines will eﬀectively aid researchers in conducting evaluation rese arch, writing up results, and performing peer reviews in a repeatable, standardised, and fair manner. The principles of the manifesto (Section 4) may serve as an initial template for such guidelines. open problems (inspired by the success stories in Section 5) to be tackled by formal methods. At the lowest level, these can be benchmarks deﬁned by practitioners, formal method users, or regulators (e.g., a “FM with industry week” with short-term interactions to identify problems at a national or international level and follow-up commitments). write cas e s tudy papers a nd how to review them. We deﬁne a case study as an intensive examination of a single example with an aim to generalise across a larger set of examples. It’s this generalis ation that makes case studies useful in teaching and in industrial practice. laboration, for example, to improve the interface between diﬀerent formal methods and their users (e.g., increase trust through Explainability, see Table 1), to investigate the economic beneﬁts through formal metho ds (e.g., economical value, metrics), or to develop new business models integrating such methods. tions of existing formal approaches and new variants in practical contexts, (ii) develop new formal approaches with an interest on achieving applicability early, and (iii) support the transfer of these methods into depe ndable systems practice. and Wohlin et al.’s procedures provide welcome guidance. Speciﬁc Implications of the Manifesto on Future Formal Method Teaching. It is important to have good case studies that are relevant to students. They must be able to re cognise the problem being solved. The y should have realistic case s tudies for every important co nc e pt in the course. This is particularly important for industrial courses, where it helps if the pr esenter has good industrial experience using the formal method. Robust to ols are important. T he re must be parsers and type checkers. Model checkers are attractive, but can disappoint if newcomers have diﬃculty in scaling their use. Theorem provers have a higher entry barrier but their success can be inspiring. A successful course teaches not just one formal method, but families of forma l methods: students like to see the connections between diﬀerent formal methods. Industrial courses should show how formal methods ﬁt into software management processes and popular methodologies. This includes combining formal methods with testing strategies and their role in formal domain engineering as part of requirements engineering. Impact on the Evaluation of Future Formal Method Research. We expect the manifesto to motivate re searchers to carry out comparative method and tool evaluations (e.g., [19]), realistic case studies and goal-directed action resear ch, and controlled metho d experiments improving over previous lessons learnt [52, 57]. For example, in the ABZ community there are ong oing activities to create a case study library for such pur poses. VerifyThis collaborative long-term veriﬁcation challenge bringing together FM resear chers to show “that deductive program veriﬁcation can produce relevant results for rea l systems with acceptable eﬀor t”. The manifesto has the potential to create new lines and for mats of resea rch funding speciﬁcally shaped to the needs of formal method evaluation and tool development, such as funding for experiments and entrepreneurship funding fo r spin-oﬀs. Comparative method experiments and usable tool interfaces require resources going beyond PhD projects or beyond the pure response to scientiﬁc questions. Only appropriately funded resear ch projects will create convincing evidence. Impact on the Further Development of the Formal Methods Community. The manifesto could reduce the cur rent fragmentation of the formal methods c ommunity by subseq ue ntly integrating selective sub-communities, for example, communities working on common semantic frameworks (e.g., the UTP community the “Formal Methods in Industrial Critical Systems (FMICS)”, “Integrated Formal Methods (iFM)”, “NASA Formal Methods (NFM)”, and “Software Engineering and Formal Methods (SEFM)” confere nc e series ) or forma l method integration (e.g., the sub-communities a round ifesto could inspire new actions of researchers to work towards a collection of formal methods that follow the proposed principles. Impact on Software Engineering as a Legally Recognised Profession. In his Turing Award acceptance speech about 40 years ago, Tony Hoare reviewed type safety precautions in programming la nguages and concluded: “In any respectable branch of engineering, failure to observe such elementary precautions would have long been against the law” [32]. In this regard, for example, U.S. law still does not recognise computing (including software engineering) as a profession [14], oppos ing ACM’s self-perception [13]. This is mainly becaus e software practitioners’ work is not subject to malpractice claims based on a legal concept known as “customary care”. Customary care deﬁnes (i.e., s tandardises) best practice more stringently to any occ upation or business. From a computing standpoint, o ngoing juristic debates about which other occupations could be advanced by this manifesto, corroborate codes such as ACM’s Code of Ethics and Professional Conduct, formal methods community as cre dible best practices underpinning such codes. In Denmark, 51% of the developers hired by the IT companies developing software do not have a BSc/ MSc degree in computing. that this situation can be generalised to other European c ountries and, to a smaller degree, also to critical application domains . Hence, this manifesto could aid in the expansion of existing software eng ine e ring professionalism such domains. Above, we summarised actions and expected outcomes of a successful implementation o f the manifesto. However, some negative long-term conseq uenc es of not fo llowing an agenda implied by the manifesto are to be fo reseen. First, the prog ress of formal method research might be further threatened by missing scalability, vacuous proofs, lack of user education and training, poor tool integration, lack of researcher engagement and, thus, research funding [25, pp. 117:23,29]. Secondly, formal methods might be w iped out by opportunistic trends or powerful convenience technologies (e.g., relying too much on search- or AI-based software engineering) that can make the highlighted problems worse. It can be observed that softwar e solutions constructed thro ugh a utomatic search may require signiﬁcant further investments into the reverse engineering of these solutions in order to verify them. This may happen fre quently in cases where not all critical properties to be veriﬁed can be encoded into the search criteria. Ultimately, decreasing global coordination among formal method researchers can lead to an extinction of the formal methods community, which is currently rather fragmented. It is diﬃcult for the community to maintain too many notations and too many tools and make fast progress. This situation seems quite unique among related or other s cientiﬁc disciplines (i.e., STEM a proliferation of formal method conferences and workshops that are competing for the same r esources (i.e., papers, reviewers, etc.). Ideally, a representative, coordinated approach could lead to an authoritative voice towards the scientiﬁc, governmental, and industrial communities. The manifesto for applicable formal methods expresses aims a nd intentions and shall help formal methods researchers to implement a moder n research agenda for developing formal methods that can arguably be used for critical software engineering research but, even more importantly, in the practical engineering of systems and software whose functioning is critical and who se failure would have unacceptable consequences. Rather than exercising criticism of past developments, the manifesto strives to foster progress of a currently dissatisfying situation found in the science of formal methods.