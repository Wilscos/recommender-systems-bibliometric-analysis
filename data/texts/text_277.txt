Collaborative ltering (CF) is a widely studied research topic in recommender systems. The learning of a CF model generally depends on three major components, namely interaction encoder, loss function, and negative sampling. While many existing studies focus on the design of more powerful interaction encoders, the impacts of loss functions and negative sampling ratios have not yet been well explored. In this work, we show that the choice of loss function as well as negative sampling ratio is equivalently important. More specically, we propose the cosine contrastive loss (CCL) and further incorporate it to a simple unied CF model, dubbed SimpleX. Extensive experiments have been conducted on 11 benchmark datasets and compared with 29 existing CF models in total. Surprisingly, the results show that, under our CCL loss and a large negative sampling ratio, SimpleX can surpass most sophisticated state-of-the-art models by a large margin (e.g., max 48.5% improvement in NDCG@20 over LightGCN). We believe that SimpleX could not only serve as a simple strong baseline to foster future research on CF, but also shed light on the potential research direction towards improving loss function and negative sampling. • Information systems → Recommender systems;Collaborative ltering. Recommender systems; collaborative ltering; graph neural networks; contrastive loss Nowadays, personalized recommendation is ubiquitous in various applications, such as video recommendation in YouTube [5], product recommendation in Amazon [24], and news recommendation in Bing [34]. The goal of recommendation is to predict whether a user will interact (e.g., click or purchase) with an item and thus help users discover potential items of interests. Collaborative ltering (CF) [27] is a fundamental task in recommendation that leverages the collaborative information among users and items to predict users’ preferences on candidate items. The simplicity and eectiveness make it one of the most popular techniques in recommender systems. Generally, the learning process of a CF model can be separated to three major components, including interaction encoder, loss function, and the negative sampling strategy used when only positive (i.e.,implicit) feedbacks are available. Most existing studies focus on the design of more powerful interaction encoders to capture collaborative signals among users and items. Especially, the prevalence of deep learning motivates a rich line of work that applies various neural networks to CF, including multi-layer perceptrons (MLPs) [5,11], auto-encoders [16], attention networks [3], transformers [28], graph neural networks (GNNs) [10], and so on. Nevertheless, these models tend to become more and more complex to show performance improvements. This somehow limits their practical applicability in industrial recommender systems that demand high eciency. On the contrary, few research eorts have been devoted to investigating the impacts of the latter two components. Specically, while multiple loss functions have been used in CF, such as Bayesian personalized ranking (BPR) loss [22], binary cross-entropy loss [11], softmax cross-entropy loss [5], pairwise hinge loss [12], and mean square error loss [2], there is still a lack of systematic evaluation and comparisons among dierent loss functions. Furthermore, many recent GNN-based studies [10,29,30,32,33] experiment with the BPR loss [22] and simply set the negative sampling ratio to a small value (i.e., sampling 1 or 10 negative samples per positive useritem pair). In this way, they can justify the superiority of their proposed interaction encoders, but they neglect the importance of loss functions and negative sampling in the learning of CF models. In fact, we empirically observed that training with the BPR loss and a small negative sampling ratio results in inferior results for many CF models. In this paper, we show that choosing a suitable loss function and a proper number of negative samples plays an equal or more important role than an interaction encoder. Towards this goal, we systematically compare multiple commonly-used loss functions and also investigate the impact of negative sampling ratio on each loss function. Moreover, inspired by the widely used contrastive loss [8,38] in computer vision, we propose a cosine contrastive loss (CCL) tailored for CF. Our CCL loss optimizes the embedding by maximizing the cosine similarity of a positive useritem pair, while minimizing the similarity of a negative pair to a certain margin. Surprisingly, we found that even a simple model (e.g., MF), if paired with our proposed CCL loss, is sucient to surpass many sophisticated state-of-the-art models. These ndings raise questions about whether the current baselines are strong enough to verify the performance improvements of the state-of-the-art CF models, and how much these sophisticated models have really improved. Our work aims to answer these questions. We argue that the current baselines might not be strong enough, which could mislead us to overestimate the real improvements of many new CF models. Instead of criticizing the contributions of any existing work, the main goal of our work is to build a simple and strong baseline model to foster future research on CF. In the design of SimpleX, we keep simplicity in mind and borrow ideas from several existing studies (e.g., average pooling in YouTubeNet [5], attention in ACF [3]). We build Simplex as a unied model that integrates matrix factorization and user behaviour modeling. Specically, it comprises a behavior aggregation layer (e.g., average pooling) to obtain a user’s preference vector from the historically interacted items, and then fuses with the user embedding vector via a weighted sum. More importantly, SimpleX is optimized with our CCL loss and a large negative sampling ratio. Although the interaction encoder of SimpleX seems quite simple and might not be novel at all, we show that it could serve as a super-strong baseline model and have great potential for industrial applications because of its high eciency. For evaluation, we conduct comprehensive experiments on 11 benchmark datasets in total and compare with a total of 29 popular CF models of dierent types. The results show that SimpleX outperforms most sophisticated state-of-the-art methods by a large margin (up to 48.5% improvement in NDCG@20 over LightGCN [10] on Amazon-Books). We also empirically compare the performance of six representative loss functions and investigate the impact of dierent negative sampling ratios on each loss function, which demonstrates the superiority of our proposed CCL loss for CF tasks. Furthermore, we evaluate the eciency of SimpleX, which shows more than 10x speedup over the simplied GNN-based CF model, LightGCN [10]. We hope that our work could not only serve as a simple and strong baseline to foster future research on CF, but also attract more research eorts towards the co-design of interaction encoders, loss functions, and negative sampling strategies. The main contributions of our work are summarized as follows: •We highlight the importances of loss functions and negative sampling in CF, and propose the cosine contrastive loss accordingly. •We present a simple and strong baseline model, SimpleX, which could even attain much better performance than most sophisticated state-of-the-art models. •We perform experiments on 11 benchmark datasets and compare SimpleX with 29 existing CF models to show its superiority in terms of both eectiveness and eciency. In this section, we rst give a formulation of collaborative ltering and point out three important aspects in CF modeling. We then summarize dierent categories of CF models. The research of collaborative ltering includes implicit CF and explicit CF. Implicit CF models learn from implicit feedback data, e.g., click, visit, and purchase, while explicit CF models learn from explicit feedbacks such as ratings. In this work, we focus on implicit CF since it is more common in real recommendation scenarios. Besides, it is also easy to transform explicit feedback to implicit feedback via binarization. In implicit CF, a matrixYis used to denote the user-item interactions, where𝑦=1 if user u has observed interaction with item i and 𝑦= 0 otherwise. As mentioned in Section 1, we highlight three vital aspects that have a large impact to the learning process of CF models: (1) Interaction Encoder.The function of the interaction encoder is to learn embeddings for each user and each item, which capture collaborative signals in the interaction matrix that reect the behavioral similarity between users (or items). It is undoubtedly the core of CF models and has been well studied. We give a brief summary of interaction encoders in section 2.2. (2) Loss Function.In general, there are two common types of loss functions in CF. Pointwise loss functions such as binary crossentropy (BCE) and mean square error (MSE) treat the learning process as a binary classication or a regression task. Pairwise loss such as Bayesian personalized ranking loss (BPR) is optimized to make the similarities of positive user-item pairs larger than the negative ones. (3) Negative Sampling.Since there are a lot of unobserved entries, in most cases we need to perform negative sampling to improve training eciency. A few studies have been made to improve the uniform random sampling for recommendation, including mining informative negative samples (e.g., RNS [6], and NBPO [41]), tackling the selection bias of implicit user feedback (e.g., MSN [36]) and so on. In this work, we mainly investigate the inuence of the negative sampling ratio. The existing studies are complementary to our work and potential to be applied to our SimpleX model for further improvement. We summarize representative CF methods into four categories: (1) MF-based methods.Matrix factorization (MF) based algorithms decompose the user-item interaction matrix into two lowdimensional latent matrices for user and item representation. Due to its eectiveness, MF has been wildly studied in CF. Manotumruksa et al. proposed GRMF [19] that smoothed MF through adding the graph Laplacian regularizer to introduce graph information. Yang et al. devised a unied and ecient method called HOP-Rec [37] that incorporated both MF and graph-based models for implicit CF. Chen et al. designed ENMF [2], which is an ecient MF-based CF model with modied MSE loss function. It can be optimized eciently without negative sampling for implicit feedback. (2) Autoencoder-base d methods.Autoencoder-based CF methods leverage the autoencoder network architectures to learn item embeddings. Such models are suitable to perform inductive recommendation, i.e., learning from one group of users while performing recommendation for another group of users with the same candidate items. For example, Liang et al. proposed Mult-VAE [16], which applied variational autoencoder (VAE) for CF. Ma et al. proposed MacridVAE [18] by disentangling user intents behind user-item and leveraging𝛽-VAE to simulate the generative process of a user’s personal history interactions. Steck et al. designed a linear model called EASE[26] that is geared toward sparse data, in particular implicit feedback data, for the recommendation. (3) GNN-based methods.Since the interaction data can be naturally modelled as a user-item bipartite graph, recent studies propose graph neural network (GNN) based CF models and report state-of-the-art performance. GNN-based methods model the recommendation as the link prediction task between user nodes and item nodes, where the higher-order collaborative signals can be effectively captured through multi-layers message passing. Ying et al. proposed PinSage [39] that improved GraphSage [9] to model the item-item relationships for Pinterest. Wang et al. devised NGCF [32] that explicitly encoded the collaborative signals as high-order connectivities by performing embedding propagation. He et al. proposed LightGCN [10], which removed the feature transformation and non-linear activation in NGCF and improved both performance and eciency. These successful applications of GNN in recommendation further inspire many good studies, including BGCF [29] which models the uncertainty in the user-item graph with bayesian graph neural networks, DGCF [33] which models a distribution over intents for each user-item interaction, NIA-GCN [30] and NGAT4Rec [25] that learn neighborhood relationships, and SGLED [35], DHCF [14], LCFN [40], and so on. (4) Others.We put methods that do not fall into the rst three categories into this “Others” category. Here we list some representative models such as SLIM [21] which is a simple linear model that combines the advantages of neighborhood- and model-based CF approaches, MLPs-based NeuMF [11] and YouTubet [5], memory network-based CMN [7], metric learning-based CML [12], and NBPO [41] that leverages noisy-label robust learning techniques. In this section, we rst present our cosine contrastive loss and the SimpleX model architecture for CF. We then analyze its connections to other existing models. In the CF literature, many dierent loss functions have been employed, including BPR loss [22], binary cross-entropy [11], softmax cross-entropy [5], pairwise hinge loss [12], etc. However, there is still a lack of a systematic comparison among them, leaving their eects on model performance not well understood. In this work, we not only make such a comparison, but also propose a new loss function for CF, namely cosine contrastive loss (CCL). Given a positive user-item pair (𝑢,𝑖) and a set of randomly sampled negative samples (i.e., N), the CCL loss is expressed as follows: L(𝑢, 𝑖) = (1 −ˆ𝑦) +𝑤|N |max(0,ˆ𝑦 whereˆ𝑦calculates the cosine similarity between the representation vectors of user𝑢and item𝑖.|N |denotes the number of negative samples.𝑚is the margin to lter negative samples, which is usually set to 0∼1. Intuitively, CCL is optimized to maximize the similarity between positive pairs and minimize the similarity of negative pairs below the margin𝑚.𝑤is a hyper-parameter to control the relative weights of positive-sample loss and negative-sample loss. Design Choices. The formulation of CCL is simple and largely inspired by the widely used contrastive loss [8,38] in the computer vision tasks, such as face recognition and image retrieval. But we make several design choices that dier from most widely-used loss functions in CF and greatly facilitate model training. First, instead of applying dot product (e.g., in LightGCN [10]) or Euclidean distance (e.g., in CML [12]) to measure the similarity (or distance) between a user-item pair, we choose to compute the cosine similarity between them. By applying L2 normalization on both representation vectors, cosine similarity only calculates the angle dierence and thus avoid the eect of representation magnitude. This is favorable since the magnitude of a user/item representation could be strongly biased by its popularity in CF tasks. This is also similar to the calculation of word similarity in Word2Vec [20], where cosine similarity is usually used. Second, when the number of negative samples becomes large, there usually exist many redundant yet uninformative samples. But existing loss functions (e.g., BPR [22]) treat every negative sample equivalently. As such, model training could be overwhelmed by these uninformative samples, which signicantly degrade the model performance and also slows the convergence. In contrast, CCL alleviates this problem by using a proper margin𝑚to lter uninformative negative samples. Intuitively, uninformative negative samples will get zero loss in CCL when they have a small cosine similarity below the margin𝑚. As a result, it helps automatically identify those hard negative samples with cosine similarity larger than 𝑚, and thus facilitates better training of the model. Third, we found that directly summing or averaging the loss terms of all negative samples could degrade the model performance, especially when the number of negative samples is large. This is partially due to the high imbalance between positive and negative samples (e.g., 1:1000 when|N | =1000). We thus introduce a datadependent weight𝑤to control the balance between positive loss and negative loss. We emphasize that it also achieves a similar eect to the condence weight imposed on negative samples in weighted matrix factorization [13]. To leverage the advantages of CCL, we further propose a simple CF model, dubbed SimpleX. In the design of SimpleX, we keep simplicity in mind and borrow ideas from several successful models such as YouTubeNet [5], ACF [3], and PinSage [39]. Figure 1 illustrates the overall architecture of SimpleX. It largely follows the mechanism of MF, which factorizes users and items into a common latent space. Yet, SimpleX also takes the interacted item sequence of each user as additional input to better model user behaviors. This also has been shown eective in many existing studies, such as YouTubeNet [5] and ACF [3]. The key part of SimpleX lies in its aggregation layer for behavior sequence aggregation. Figure 1: The Simple Mo del Architecture of SimpleX. Here we introduce three common aggregation choices, including average pooling, self-attention, and user-attention, but Simplex is a unied architecture that any other aggregation method should also be applicable. Suppose the historically interacted item set of user𝑢asH, and we set its maximal size to𝐾. For users with a dierent size of interacted items, either padding or chunking can be applied accordingly. As such, the aggregated vector can be obtained as follows: where𝑒∈ Ris the𝑑-dimensional embedding vector of item 𝑘.𝐼denotes the mask indices toHduring padding, where𝐼= 0 indicates a padding token; otherwise𝐼=1.𝛼denotes the aggregation weight, which can be computed according to dierent aggregation types as follows. , if self-attention or user-attention. Average pooling provides a straightforward way to aggregate the interacted items, which has been successfully applied in YouTubeNet [5]. But it treats each item equally and fails to account for the relative importances of dierent items as well as a user’s preference on each item. The attention mechanism, such as self-attention and user-attention, can be applied in such cases as calculated in the lower part of Equation 3. The dierence between them lies in the computation of 𝛽, which is: where𝑞 ∈ Ris a learnable global query vector for self-attention and𝑒is the user-specic query vector for user𝑢in user-attention. 𝑾, 𝑾∈ Rand𝑏, 𝑏∈ Rare learnable parameters. Note that similar attention mechanisms can be found in some existing work [3, 34]. However, after behavior aggregation via Equation 2, the pooling vector𝑝may lie in a dierent latent space with user vector𝑒. We further fuse both parts to get the nal user representation ℎ: where𝑽 ∈ Ris a learnable parameter and𝑔is a hyperparameter weight. Finally, we measure the cosine similarityˆ𝑦𝑖between user 𝑢 and item 𝑖 as the input to our CCL loss. The above three aggregation layers provide dierent views for aggregation, including global-average view, global-weighed view and user-specic weighted view. The choice among them is quite data-dependent. In our experiment, we show that average-pooling is a robust aggregation method that always demands a rst attempt when applying SimpleX. The other two usually needs more eorts to tune and in some cases brings marginal improvements. SimpleX is also related to multiple popular CF models. • MF. MF is the most common model for CF. SimpleX follows the similar mechanism of MF. When setting g = 1 in SimpleX, it reduces to a MF model trained with CCL (i.e., MF-CCL). • YouTubeNet. YouTubeNet is a successful model that has been widely used in industry. SimpleX can be also seen as a simplied YouTubeNet model (without using side features) when average pooling is employed. The only dierence is that YouTubeNet employs concatenation instead of weighted sum to fuse𝑒and𝑝. But the latter performs better in our experiments. • GNN-based models. Simplex is also similar to GNN-based models. For instance, when choosing the user-attention aggregation layer, it almost equals to a graph attention (GAT) layer applied on user nodes only. If using the self-attention aggregation layer, it works like the neighbor interaction in NIA-GCN [30] as well. We emphasize that although the design of SimpleX is simple and might not be novel to some extent, it unies several key components in existing CF models.Surprisingly, such a simple mo del is sufcient to surpass most state-of-the-art CF mo dels by a large margin, which could serve as simple and strong baseline for future research. In this section, we conduct comprehensive experiments to evaluate SimpleX, including: 1) studying the impacts of loss functions and negative sampling ratios, 2) making performance comparisons to existing models on three main datasets, 3) incorporating CCL to other models, 4) performing parameter analysis and eciency evaluation, 5) further validating SimpleX on some other datasets. 4.1.1 Dataset. We use 11 benchmark datasets in our study. For fairness and ease of comparison, we choose those open datasets that have been already split and preprocessed. Specically: (1) We employ three main datasetsAmazon-Books,Yelp2018, andGowalla, which are commonly used in recent GNN-based CF models [4,10,25,32,33,35]. We perform most of our experiments on them and further make comparisons to these GNN-based models. Table 1: Performance of MF under dierent loss functions. The best result in each column is marked in bold. (2) To demonstrate the universality of SimpleX, we further test SimpleX on some other datasets adopted by studies published in toptier conferences. Three of them,Amazon-CDs,Amazon-Movies, Amazon-Beauty, are adopted by the work NIA-GCN [30] and BGCF [29]. The other three,Amazon-Electronics,CiteUlikeA, andMovielens-1M, are provided by NBPO [41], DHCF [14], and LCFN [40], respectively. Specically, we compare SimpleX with the corresponding models on the corresponding datasets that adopted in their original papers. For example, we will compare with DHCF [14] on CiteUlike-A dataset because DHCF adopts this dataset in their original paper. (3) The last two areMovielens-20MandMillionSongData, which are commonly used by autoencoder-based CF models, such as Mult-VAE [16] and RecVAE [23]. We follow the strong generalization setting, which split train/validation/test sets with dierent sets of users, and specially make comparison with those autoencoderbased CF models to further demonstrate the eectiveness of SimpleX. 4.1.2 Compared Methods. We compare SimpleX with 29 existing CF models of dierent types: •Five methods based on MF and its variants, including MF- BPR [15], GRMF [19], HOP-Rec [37], NeuMF [11], and ENMF [2]; •Four autoencoder-based methods, including Mult-VAE [16], MacridVAE [18], EASE[26], and RecVAE [23]; •Fourteen GNN-based methods, including GC-MC [1], Pinsage [39], GAT [31], NGCF [32], DisenGCN [17], LR-GCCF [4], NIA-GCN [30], LightGCN [10], DGCF [33], NGAT4Rec [25], SGL-ED [35], BGCF [29], DHCF [14], and LCFN [40]; •Six methods of other types, including ItemPop, SLIM [21], CML [12], YouTubeNet [5], CMN [7], and NBPO [41]. 4.1.3 Implementation Details. We implement SimpleX in PyTorch. Specically, we set the batch size to 1024 by default. We use the Adam optimizer and tune the learning rate among [1e-3, 5e-4, 1e-4]. We also employ𝐿regularization on the embedding parameters and search the regularization weight between 1e-9∼1e-2 with an increase ratio of 5. For cosine contrastive loss, we search the number of negative samples from 1 to 2000. In many cases, we pick 100, 500, or 1000. The margin𝑚is tuned among 0∼1 at an interval of 0.1, for example, we set 0.4, 0.9, and 0.9 on Amazon-Books, Yelp2018, and Gowalla, respectively. Meanwhile, we use the same embedding size with the compared model, for example, 64 in LightGCN and 128 in LCFN. For fairness of comparison with existing models, we report the results using the same evaluation metrics (e.g., Recall@20 and NDCG@20) and duplicate the reported results on their papers for consistency. To facilitate reproducible research in the community, we have contributed our source code and detailed benchmark settings to the public Open-CF-Benchmark. While most studies focus on the interaction encoder design, they neglect the importance of loss functions in the learning of a CF model. We make a systematic comparison on the impacts of dierent loss functions. For this purpose, we choose one of the simplest baseline CF models, i.e., MF, as the backbone to perform the experiments, since simple models tend to be more illustrative. In addition to our CCL loss, we evaluate MF on the following representative loss functions: • Bayesian personalized ranking (BPR)loss encourages the similarity of a positive user-item pair to be higher than that of each negative user-item pair. It is one of the most commonly used loss function for CF research [10,22,32,33]. • Pairwise hinge loss (PHL), is also known as max-margin objective, which has been used in CML [12]. PHL forces the distance of a negative user-item pair to be larger than a positive one by at least the marginal distance. • Binary cross-entropy (BCE)loss is commonly used for binary classication, which has been adopted in the early work NeuMF [11]. • Softmax cross-entropy (SCE)loss is widely used for multiclass classication. YouTubeNet [5] cast item prediction as a multi-class classication task through the SCE loss. • Mean square error (MSE)has been widely used for CF, such as WMF [13] and ENMF [2]. Table 1 shows the results of training MF with dierent loss functions on Amazon-Books, Yelp2018, and Gowalla. Note that every model has been trained with enough epochs to reach convergence and the best results are reported. From the results, we have the following observations: 1) CCL consistently achieves the best performance on all the three datasets, outperforming the other loss functions by at least 16.7%, 9.2% and 13.7% w.r.t. Recall@20 on Amazon-Books, Yelp2018 and Gowalla, respectively. 2) BPR only appears to be strong on Gowalla and performs not well on both Amazon-Books and Yelp2018. This demonstrates that using BPR for training is probably sub-optimal, and thus the results reported by many previous papers may need careful re-examination and are likely to be further improved with our CCL loss. Figure 2: The eect of number of negative samples across dierent loss functions on Amazon-Bo oks. Why CCL performs better than the other loss functions? In addition to the design choices analyzed in Section 3.1, we further highlight the advantages of CCL with some concrete comparisons. First, in contrast to BPR, BCE, SCE, and MSE, CCL can automatically lter out hard negative samples that are hard to distinguish (i.e., large cosine similarity) by the model via its margin mechanism. For example, if we set𝑚 =0.8, only those negative pairs withˆ𝑦>0.8 will contribute to the loss. Dierent from the above loss functions that treat each negative sample equally, CCL allows the model to emphasize on the learning of hard negative samples and thus generate more discriminative representations. Second, compared with PHL that also applies a margin mechanism, CCL is more eective for CF. The PHL loss is determined by the relative distance between positive samples and negative samples. Even if a negative sample is actually hard to be distinguished (e.g.,ˆ𝑦=0.8), it will not contribute to learning if the corresponding positive sample has ˆ𝑦=0.9. CCL avoids such ambiguity by penalizing the absolute similarityˆ𝑦of each negative sample. We argue that negative sampling ratio is also important in the learning of CF models, which has been largely ignored by existing studies. To support our claims, we compare the performance of MF trained with 1∼2000 negative samples on Amazon-Books. We also repeat the experiment on dierent loss functions. We train each model until convergence and report the best results, as shown in Figure 2. We have the following observations from the results: 1) The number of negative samples does matter for CF model training. Generally, increasing it within a certain range leads to improvements. This suggests that we should carefully consider the impact of the number of negative samples in the evaluation. 2) MF trained with CCL is consistently better than training with the other loss functions under dierent negative sampling ratios, further demonstrating the superiority of our CCL. 3) The performances of PHL, MSE, and BPR become stable when the number of negative samples increases to 50. In contrast, CCL, BCE, and SCE can keep performance gains with the increase of number of negative samples, even when it reaches to 1000. In summary, our experimental results show that both loss functions and negative sampling ratios can have a large impact on model performance. Training with the CCL loss and a large negative sampling ratio appears to be a promising setting for CF methods to gain higher performance. We therefore call for more future research towards this direction. In this section, we provide a comprehensive comparison results of SimpleX and other 23 CF models on three main datasets, i.e., Amazon-Books, Yelp2018, and Gowalla, which are very commonly adopted in CF studies (especially in GNN-based CF), to demonstrate the superiority of SimpleX. Table 2 shows our performance comparisons on Amazon-Books, Yelp2018, and Gowalla under the same evaluation protocol, and we have the following observations: 1) Our SimpleX achieves the best overall performance on all the three datasets. In particular, compared with the most recent LightGCN, SimpleX makes 41.9%, 8.0%, and 2.3% performance improvements on Recall@20 for Amazon-Books, Yelp2018, and Gowalla, respectively, demonstrating the high eectiveness of SimpleX. Besides, note that we do not report the results of SGL-ED [35] and NGAT4Rec [25] on Gowalla since they are not evaluated on Gowalla but only evaluated on the other two datasets in their original papers too, and the authors have not released their code. As the experimental settings of SGL-ED and NGAT4Rec are exactly same as us, we just report their results on Amazon-Books and Yelp2018. 2) The performance of MF-CCL is surprising. When using CCL as the loss function, the performance of MF is not only much better than the results of MF-BPR reported in the previous paper, but also reaches a new state-of-the-art performance (if leaving out our SimpleX) on Amazon-Books and Yelp2018. On Gowalla, it also achieves comparable performance compared to the previous best model DGCF. Such results strongly suggest that loss functions can make a big dierence and should be carefully chosen and studied. 3) YouTubeNet, CML, and SLIM are three models that we added and have not been tested on these three datasets before by the existing work. We found that they achieve pretty good performance. Specically, these three models can averagely outperform a representative GNN-based CF model – NGCF, by more than 24% and 28% w.r.t. Recall@20 and NDCG@20, respectively. This implies that the current baselines are relatively weak, which may lead us to overestimate how much real progress we have made in CF. 4) In CF tasks, more complex models not always lead to better performance. The designs of SLIM, YouTubeNet, CML, MF-CCL, and our SimpleX are all much more concise than most of autoencoderbased (e.g., Mult-VAE and MacridVAE) and GNN-based models (e.g., NGCF, NIA-GCN, and DGCF), but they can achieves better performance. This also reveals that the current trend in CF research, which pays too much attention to the design of sophisticated interaction encoders while ignoring the impacts of loss functions and negative sampling, needs to be improved. In Table 2, we have shown that one of the simplest models, i.e., MF, can even largely outperforms most of state-of-the-art models if training with CCL. We are curious about how other models will perform if incorporated with CCL instead of their original losses. Therefore, in this part, we take experiments with two eective CF models in addition, i.e., YouTubeNet and LightGCN with CCL, and report the results on Amazon-Books and Yelp2018 in Table 3. Table 2: Performance comparison to popular CF models. We highlight the top-5 best results in each column. RI stands for relative improvement. We also report the average RI over NGCF for each model if applicable. For models marked with of the results are duplicated from existing papers for consistency. From the results, we nd that training YouTubeNet and LightGCN with CCL instead of their original loss functions, i.e, SCE and BPR respectively, can bring good improvements. This demonstrates that CCL is likely to be a more promising loss function to help CF models achieve better performance. Besides, we observe that the improvements brought by CCL on YouTubeNet and LightGCN are not as signicant as those on MF. CCL seems to improve these models to a similar level of performance. This may be because of the following reason: Generally, valuable collaborative information can be captured by both the interaction encoder and the loss function. As the encoders of YouTubeNet and LightGCN are sophisticated and stronger to learn biased collaborative signals, by contrast, the impact of the loss function to them appears relatively small. In addition, it is worth noting that our main focus is to question the value of sophisticated encoders and provide a simple strong baseline, but not to improve current state-of-the-art CF models by exhaustingly trying of various loss functions. Based on the experiments with MF, YouTubeNet, and LightGCN, we demonstrate and highlight that the loss function is a large bottleneck in CF models. We expect our work could inspire more research to study Table 3: Performance of dierent models trained with CCL v.s. their original losses. ModelRecall@20 NDCG@20 Recall@20 NDCG@20 the co-design of the interaction encoder, loss function, and negative sampling. We investigate the performance of three dierent behavior aggregation layers, the fusing weight𝑔, and the negative loss weight𝑤. Results on Amazon-Books and Yelp2018 are shown in Table 4. We can make the following observations: 1) Average pooling, self-attention, Table 4: Parameter analysis results on SimpleX. AblationsRecall@20 NDCG@20 Recall@20 NDCG@20 Table 5: Eciency comparison on Amazon-Books, w.r.t. the average training time per epoch, the number of epochs to converge, and the total training time. and user-attention obtain very similar results on Amazon-Books and Yelp2018, respectively. This shows the robustness of apply average pooling for behavior aggregation in practice. SimpleX with 𝑔 =0.5 reaches higher performance compared with the other two settings on Amazon-Books, which shows that importance of fusing user embedding with user behavior aggregation. 2) The negative weight𝑤which adjusts the ratio of positive and negative losses is vital to model’s performance. In general, too small (𝑤 =1) or too large (𝑤 =1000) dierence between positive and negative losses leads to performance reduction. Our SimpleX has high eciency due to its simple design. We numerically compare the training time of SimpleX with two state-of-the-art CF models, i.e., ENMF and LightGCN, which are relatively ecient in their respective categories, on Amazon-Books. The eciency experiments are conducted on the same Intel(R) Xeon(R) Silver 4210 CPU @2.20GHz machine with one GeForce RTX 2080 GPU. We compare them under the same implementation framework, using the same acceleration methods (e.g., implementing the sampling with C++) to ensure fairness. Specically, we present the averaged training time per epoch, the number of epochs that the model needs to reach the level of performance reported in the original paper, and the total training time (test time is not included), in Table 5. It turns out that SimpleX is much more ecient than ENMF and LightGCN overall. Specically, SimpleX only needs around 30 epochs to converge in training, which is more convenient for real application. The total training time of SimpleX with a 1000:1 negative sampling ratio has around 2x and 10x speedup compared with ENMF and LightGCN respectively. Moreover, if we decrease the negative sampling ratio to 100:1, the training time for one epoch of SimpleX can be optimized to 40s, nally resulting in only 19 minutes total training time. Certainly, the performance slightly drops compared with using a 1000:1 negative sampling ratio, but it still maintains a pretty good level (much better than ENMF and LightGCN). Such high eciency makes our model promising to be applied in large-scale real recommender systems. In addition to the three main datasets used in the above sub-sections, we additionally evaluate SimpleX on 8 more datasets to further demonstrate the generability of SimpleX. Table 6 shows the comparison results to some state-of-the-art CF models published in 2020. For fairness of comparison, we use the same data preprocessing and experimental settings (embedding dimensions and evaluation metrics) provided by the corresponding papers. We observed that SimpleX consistently outperforms all the compared models on dierent datasets. The performance improvements are especially large (12.8% to 33.6% improvement in NDCG@20) on Amazon-CDs, Amazon-Movies and Amazon-Beauty compared to BGCF, a recent GNN-based model. This again strongly veries the eectiveness and robustness of SimpleX to serve as a strong baseline in future work. Moreover, we also make a comparison to some autoencoderbased models, including SLIM, Mult-VAE, EASE, and RecVAE. It is worth noting that our experiment also follows the same setting with them. In particular, we adopt the strong generalization protocol, where the training, validation and test sets are disjoint in terms of users. This requires the model to perform inductive learning during inference. That is, only item embeddings can be learned during training and then transferred to the validation and test sets for prediction. To achieve this, we simplify SimpleX by setting𝑔 =0 in this experiment and only learn user representations from their historically interacted items. Table 7 presents the evaluation results on Movielens-20M and MillionSongData. We can see that SimpleX obtains better performance than SLIM, which is a well-known strong baseline for CF. But it does not surpass Mult-VAE, EASEand RecVAE given their complete forms. This is reasonable because all of them use many more parameters (O(|𝐼 | ∗600)for Mult-VAE and RecVAE,O(|𝐼 | ∗ |𝐼 |) for EASE) than SimpleX, as shown in the “#Params" columns. Note that both Mult-VAE and RecVAE use 600 as the dimension of the rst hidden layer. As the number of items (|𝐼 |) easily reaches millions to billions in industrial recommender systems, we choose a small embedding dimension (i.e., 64) and results in parameters in the scale ofO(|𝐼 | ∗64). To make the comparison more fair, we reduce the embedding dimensions of baseline models accordingly. Specically, for Mult-VAE and RecVAE, we set its encoder and decoder as a single(|𝐼 | ∗64)-dimensional dense layer. For EASE, we decompose its item similarity matrix (denoted as B) to two (|𝐼 | ∗64)-dimensional sub-matrices by truncated SVD, and multiply the two sub-matrices to approximate the item similarity matrix to perform predictions. In this setting, SimpleX clearly outperform these autoencoder based CF models. Overall, our comprehensive experimental results on various datasets show that our SimpleX is simple and strong to serve as a Table 6: Performance comparison to some more models published in 2020. We use the same dataset settings and report the same metrics with the original papers. We also duplicate their reported results for consistency. new baseline model to facilitate future research on CF. The availability of this baseline would allow for more solid experimental evaluations and more fair comparisons among CF models. In this paper, we study the progress made in CF research and identify three key aspects for CF modeling. While most research focuses on interaction encoders, the impacts of loss functions and negative sampling on CF models have been largely neglected. In this work, we highlight their impacts and further propose the cosine contrastive loss together with a simple and strong baseline for CF, dubbed SimpleX. It outperforms most state-of-the-art CF models by a large margin. Our work released the simple and strong baseline model and the whole benchmarking results for foster future research on CF. We conduct extensive experiments to validate the eectiveness and eciency of SimpleX. We suggest that the CF community should pay more attention to other key components in addition to interaction encoders and encourage researchers to conduct more robust empirical evaluation. This work was supported in part by the National Natural Science Foundation of China (61972219), the Research and Development Program of Shenzhen (JCYJ20190813174403598, SGDX20190918101201696), the National Key Research and Development Program of China (2018YFB1800601), and the Overseas Research Cooperation Fund of Tsinghua Shenzhen International Graduate School (HW2021013).